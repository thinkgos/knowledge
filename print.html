<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>knowledge</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">knowledge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/thinkgos/knowledge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<ul>
<li><a href="rust/./00-tools.html">工具</a></li>
<li><a href="rust/./01-memory-model.html">内存模型</a></li>
<li><a href="rust/./02-owner-borrow.html">所有权机制-借用规则</a></li>
<li><a href="rust/./03-type-system.html">内存系统</a></li>
<li><a href="rust/./04-concurrent.html">并发模型</a></li>
<li><a href="rust/./05-macro.html">宏</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资料"><a class="header" href="#资料">资料</a></h1>
<h2 id="0-book"><a class="header" href="#0-book">0. book</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/">Rust book</a> 官方教程</li>
<li><a href="https://doc.rust-lang.org/nomicon/">Rust 死灵书</a> 官方Rust死灵书,主要是如何何撰写和使用 <strong>unsafe Rust</strong></li>
<li><a href="https://doc.rust-lang.org/stable/std/">Rust标准库</a> 标准库</li>
<li><a href="https://github.com/rust-lang/rustlings">Rustlings</a> 小练习, 用来夯实对知识和概念的理解</li>
<li><a href="https://github.com/rust-lang/this-week-in-rust">This week in Rust</a></li>
<li><a href="https://github.com/RustMagazine/rust_magazine_2021">Rust 语言开源杂志</a> 每月一期, 囊括了大量优秀的 Rust 文章</li>
<li><a href="https://www.youtube.com/playlist?list=PLlrxD0HtieHjbTjrchBwOVks_sr8EVW1x">Beginner’s Series to: Rust</a> 微软推出的一系列Rust培训</li>
<li><a href="https://google.github.io/comprehensive-rust/welcome.html">Comprehensive Rust</a> google 出品</li>
<li><a href="https://doc.rust-lang.org/nomicon/intro.html">The Rustonomicon</a> unsafe rust</li>
<li><a href="https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ">Jon Gjengset</a> 大佬youtube, 他的视频面向中高级 Rust 用户, 适合学习完本课程后再去观看</li>
<li><a href="https://cheats.rs/">cheat rs</a> Rust Language Cheat Sheet</li>
<li><a href="rust/">Rust for Rustaceans</a> Rust for Rustaceans</li>
<li><a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a></li>
</ul>
<h2 id="1-工具"><a class="header" href="#1-工具">1. 工具</a></h2>
<ul>
<li>
<p>代码安全</p>
<ul>
<li><a href="https://crates.io/crates/cargo-tarpaulin">cargo-tarpaulin</a> 代码覆盖率</li>
<li><a href="https://github.com/rust-lang/rust-clippy#clippy">clippy</a> 代码检查</li>
<li><a href="https://crates.io/crates/cargo-audit">cargo-audit</a> <code>Cargo.lock</code>安全审核</li>
<li>cargo-flamegraph 在跟踪代码中的性能热点时给了我们巨大的帮助.</li>
<li>cargo-geiger 帮助我们快速评估外部依赖, 以解决可能的安全性 (或正确性) 问题.</li>
<li>cargo tree (最近集成进了 cargo) 显示了一个依赖树, 它在许多方面都很有用, 但主要用于找出最小化依赖项的途径</li>
<li><a href="https://crates.io/crates/cargo-udeps">cargo-udeps</a> 可以识别未使用的依赖项, 并尽可能减少我们的构建时间</li>
<li><a href="https://github.com/EmbarkStudios/cargo-deny">cargo-deny</a> 检查依赖</li>
</ul>
</li>
<li>
<p>调试工具</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/blob/master/src/etc/rust-gdb">rust-gdb</a></li>
<li><a href="https://github.com/rust-lang/rust/blob/master/src/etc/rust-lldb">rust-lldb</a></li>
</ul>
</li>
<li>
<p>编译</p>
<ul>
<li><a href="https://crates.io/crates/cargo-watch">cargo-watch</a> 即时编译</li>
<li><a href="https://github.com/mozilla/sccache">sccache</a> sccache is ccache with cloud storage, Shared Compilation Cache</li>
</ul>
</li>
<li>
<p>平台编译打包</p>
<ul>
<li><a href="https://github.com/cross-rs/cross">cross</a> 零设置的跨平台 交叉编译和交叉测试</li>
<li><a href="https://crates.io/crates/cargo-deb">cargo-deb</a> 打包成.deb</li>
<li><a href="https://github.com/cat-in-136/cargo-generate-rpm">cargo-generate-rpm</a> 打包成rpm</li>
<li><a href="https://crates.io/crates/cargo-aur">cargo-aur</a> 打包成 Arch Linux User Repository</li>
</ul>
</li>
</ul>
<h2 id="2-crate"><a class="header" href="#2-crate">2. crate</a></h2>
<ul>
<li><a href="https://github.com/johnthagen/min-sized-rust"><code>mini-sized-rust</code></a> How to minimize Rust binary size</li>
<li><a href="https://github.com/RustCrypto/password-hashes"><code>password-hashed</code></a> Password hashing functions / KDFs</li>
<li><a href="https://github.com/tokio-rs/tracing"><code>tracing</code></a> Application level tracing for Rust.</li>
<li><a href="https://github.com/pest-parser/pest"><code>pest</code></a> The Elegant Parser</li>
<li><a href="https://github.com/Geal/nom"><code>nom</code></a> Rust parser combinator framework</li>
<li><a href="https://github.com/pola-rs/polars"><code>polars</code></a> Fast multi-threaded, hybrid-streaming DataFrame library in Rust | Python | Node.js</li>
<li><a href="https://github.com/sfackler/r2d2"><code>r2d2</code></a> A generic connection pool for Rust</li>
</ul>
<h2 id="3-建议"><a class="header" href="#3-建议">3. 建议</a></h2>
<h3 id="31-密码建议"><a class="header" href="#31-密码建议">3.1 密码建议</a></h3>
<ul>
<li>如果 <code>Argon2id</code> 可用, 那么使用 <code>Argon2id</code> (需要目标机器至少有 15MB 内存) .</li>
<li>如果 <code>Argon2id</code> 不可用, 那么使用 <code>bcrypt</code> (算法至少迭代 10 次) .</li>
<li>最后再考虑 <code>scrypt</code> / <code>PBKDF2</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存模型"><a class="header" href="#内存模型">内存模型</a></h1>
<p>类型的布局是其大小 (size) 、对齐方式 (align) 及其字段的相对偏移量. 对于枚举, 如何布局和解释判别式也是类型布局的一部分.  对于 Sized 的数据类型, 可以在编译时知道内存布局, 可以通过 <a href="https://doc.rust-lang.org/stable/std/mem/fn.size_of.html">size_of</a> 和 <a href="https://doc.rust-lang.org/stable/std/mem/fn.align_of.html">align_of</a> 获得其 size 和 align.</p>
<pre><code class="language-text">The layout of a type is its size, alignment, and the relative offsets of its fields. 
For enums, how the discriminant is laid out and interpreted is also part of type layout.
Type layout can be changed with each compilation.
</code></pre>
<p><strong>Note: 本文内存模型不考虑优化,是广文上的模型,实际中 Rust会对一些数据类型做优化.</strong></p>
<h2 id="1-整型"><a class="header" href="#1-整型">1. 整型</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>size(bytes)</th><th>align(bytes)</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td>1</td><td>1</td></tr>
<tr><td><code>i8</code></td><td>1</td><td>1</td></tr>
<tr><td><code>u16</code></td><td>2</td><td>2</td></tr>
<tr><td><code>i16</code></td><td>2</td><td>2</td></tr>
<tr><td><code>u32</code></td><td>4</td><td>4</td></tr>
<tr><td><code>i32</code></td><td>4</td><td>4</td></tr>
<tr><td><code>i64</code></td><td>8</td><td>8</td></tr>
<tr><td><code>u64</code></td><td>8</td><td>8</td></tr>
<tr><td><code>i128</code></td><td>16</td><td>16</td></tr>
<tr><td><code>u128</code></td><td>16</td><td>16</td></tr>
</tbody></table>
</div>
<h2 id="2-浮点型"><a class="header" href="#2-浮点型">2. 浮点型</a></h2>
<p>The IEEE 754-2008 "binary32" and "binary64" floating-point types are <code>f32</code> and <code>f64</code>, respectively.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>size(bytes)</th><th>align(bytes)</th></tr></thead><tbody>
<tr><td><code>f32</code></td><td>4</td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td><td>8</td></tr>
</tbody></table>
</div>
<h2 id="3-usized--isized"><a class="header" href="#3-usized--isized">3. <code>usized</code> &amp; <code>isized</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>size(bytes)/ 32位系统</th><th>size(bytes)/ 64位系统</th></tr></thead><tbody>
<tr><td><code>usize</code></td><td>4</td><td>8</td></tr>
<tr><td><code>isize</code></td><td>4</td><td>8</td></tr>
</tbody></table>
</div>
<h2 id="4-str"><a class="header" href="#4-str">4. str</a></h2>
<h3 id="41-char-类型"><a class="header" href="#41-char-类型">4.1 char 类型</a></h3>
<p><code>char</code>表示：一个 32 位(4 Bytes)长度字符, Unicode 标量值 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode Scalar Value</a> 范围为 0x0000 - 0xD7FF 或者是 0xE000 - 0x10FFFF.</p>
<h3 id="42-str-类型"><a class="header" href="#42-str-类型">4.2 str 类型</a></h3>
<p>str 与 [u8] 一样表示一个 u8 的 slice. Rust 中标准库中对 str 有个假设：符合 UTF-8 编码. 内存布局与 [u8] 相同.</p>
<h2 id="5--和t-引用"><a class="header" href="#5--和t-引用">5. <code>&amp;</code> 和<code>&amp;[T]</code> 引用</a></h2>
<h3 id="51"><a class="header" href="#51">5.1 <code>&amp;</code></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: i32 = 25;
let b: &amp;i32 = &amp;a;
let c: &amp;&amp;i32 = &amp;b;

stack
      |  a |    | b  |    │  c │
      +––––+––––+––––+––––+––––+
      │ 25 │    │ *  │    │ *  │ 
      +––^–+––––+–│^–+––––+–│––+
         │        │|________|
         │________│
<span class="boring">}</span></code></pre></pre>
<h3 id="52-t-slice-引用"><a class="header" href="#52-t-slice-引用">5.2 <code>&amp;[T]</code> slice 引用</a></h3>
<p>slice 的使用必须要通过指针, <code>&amp;[T]</code> 是一个胖指针, 保存指向数据的地址和元素个数.  slice 的内存布局与其指向的 array 部分相同.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// array &amp;[T]
let a:[i32;3] = [55,66,77];
let b:&amp;[i32] = &amp;a[..2]


stack       [––––  a   ––––|   |–––  b ––|
            +––––+––––+––––+–––+––––+––––+
            │ 55 │ 66 │ 77 │   |  * |  2 | 
            +––––+––––+––––+–––+––––+––––+
            |         |          /     /
            –––––––––––&lt;––––––––/     / 
                               /  length
                        buffer point
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vec&lt;T&gt; &amp;[T]
let a:Vec&lt;i32&gt; = vec![55,66,77];
let b:&amp;[i32] = &amp;a[..2]

stack       [–––  a   ––|     |–––  b ––|
            +–––+–––+–––+     +––––+––––+
            │ • │ 3 │ 4 │     |  * |  2 | 
            +–│–+–––+–––+     +–│––+––––+
              │                 │
heap          │                 │
            +–V––+––––+––––+    │
            │ 55 │ 66 │ 77 │    │
            +––––+––––+––––+    │
            |         │         │ 
            –––––––––––&lt;––––––––/
<span class="boring">}</span></code></pre></pre>
<h2 id="6-strstr-和-string-的区别"><a class="header" href="#6-strstr-和-string-的区别">6. <code>&amp;str</code>,<code>str</code> 和 <code>String</code> 的区别</a></h2>
<h3 id="61-string"><a class="header" href="#61-string">6.1 <code>String</code></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>String: let s: String = String::from("hello");


              buffer point
                  /   capacity
                 /   /  length
stack           /   /   /
            +–––+–––+–––+
            │ • │ 8 │ 5 │ 
            +–│–+–––+–––+
              │
heap          │
            +–V–+–––+–––+–––+–––+–––+–––+–––+
            │ h │ e │ l │ l │ o │   │   │   │
            +–––+–––+–––+–––+–––+–––+–––+–––+
            [––––––– length ––––]
            [–-–––––––– capacity –––––––––––]
<span class="boring">}</span></code></pre></pre>
<h3 id="62-str和str"><a class="header" href="#62-str和str">6.2 <code>str</code>和<code>&amp;str</code></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;str: let s: &amp;str = "hello";

          buffer point
                /   length
stack          /   /  
            +–––+–––+
            │ • │ 5 │    &amp;str
            +–│–+–––+
              │                       
read-only     │ 
memory        │                     
            [–│–––––– str ––––––] 
            +–V–+–––+–––+–––+–––+
            │ h │ e │ l │ l │ o │  
            +–––+–––+–––+–––+–––+
<span class="boring">}</span></code></pre></pre>
<h2 id="7-tuple"><a class="header" href="#7-tuple">7. tuple</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: (char, u8, i32) = ('a', 7, 356)

stack
            [–––––––––––––– 12 Bytes –––––––––––––––––––|
            +–––––––––––––+–––––+–––––––––+–––––––––––––+
            │      'a'    │  7  │ padding │      356    │  
            +–––––––––––––+–––––+–––––––––+–––––––––––––+
            |–– 4 Bytes ––|    4 Bytes    |–– 4 Bytes ––|
<span class="boring">}</span></code></pre></pre>
<h2 id="8-struct"><a class="header" href="#8-struct">8. struct</a></h2>
<p>结构体是带命名的复合类型, rust有三种结构体类型: <code>struct</code>, <code>StructExprStruct</code>,<code>StructExprUnit</code></p>
<h3 id="81-struct-含有字段的结构体"><a class="header" href="#81-struct-含有字段的结构体">8.1 <code>struct</code> 含有字段的结构体</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Data {
    nums: Vec&lt;u8&gt;,
    a: u8,
}

stack       [––– nums ––|– a –]
            +–––+–––+–––+–––––+
            │ • │ 8 │ 5 │  10 |
            +–│–+–––+–––+–––––+
              │
heap          │
            +–V–+–––+–––+–––+–––+–––+–––+–––+
            │ 0 │ 0 │ 0 │ 0 │ 0 │   │   │   │
            +–––+–––+–––+–––+–––+–––+–––+–––+
<span class="boring">}</span></code></pre></pre>
<h3 id="82-structexprtuple-元组结构体"><a class="header" href="#82-structexprtuple-元组结构体">8.2 <code>StructExprTuple</code> 元组结构体</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Data(i32, i32, i32);

stack       [––– Data ––|
            +–––+–––+–––+
            │ 1 │ 2 │ 3 │
            +–––+–––+–––+
<span class="boring">}</span></code></pre></pre>
<h3 id="83-structexprunit-单元结构体"><a class="header" href="#83-structexprunit-单元结构体">8.3 <code>StructExprUnit</code> 单元结构体</a></h3>
<p>单元结构体没有任何数据,所以Rust编译器甚至不会为它分配任何内存.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Data;
<span class="boring">}</span></code></pre></pre>
<h2 id="9-enum"><a class="header" href="#9-enum">9. enum</a></h2>
<h3 id="91-c风格枚举"><a class="header" href="#91-c风格枚举">9.1 C风格枚举</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 占一个字节
enum HTTPStatus {
    Ok;
    NotFound,
}

HTTPStatus::Ok
stack
            +–––+
            │ 0 │
            +–––+

HTTPStatus::NotFound
stack
            +–––+
            │ 1 │
            +–––+
<span class="boring">}</span></code></pre></pre>
<h3 id="92-c风格指定值枚举"><a class="header" href="#92-c风格指定值枚举">9.2 C风格指定值枚举</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 占两个字节
enum HTTPStatus {
    Ok = 200;
    NotFound = 404,
}

HTTPStatus::Ok
stack
            +–––––+
            │ 200 │
            +–––––+

HTTPStatus::NotFound
stack
            +–––––+
            │ 404 │
            +–––––+
<span class="boring">}</span></code></pre></pre>
<h3 id="93-变体枚举"><a class="header" href="#93-变体枚举">9.3 变体枚举</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Data {
    Empty;
    Number(i32),
    Array(Vec&lt;i32&gt;),
}

stack

Data::Empty
            +–––––+––––––––––––––––––––––––––––––––––––––––––––––+
            │  0  │ padding                                      │  
            +–––––+––––––––––––––––––––––––––––––––––––––––––––––+
            | mark|     
Data::Number
            +–––––+–––––––––+–––––––––––+––––––––––––––––––––––––+
            │  1  │ padding │     0     │      padding           │  
            +–––––+–––––––––+–––––––––––+––––––––––––––––––––––––+
            | mark|         |––  i32 –––|
                            |–– value ––|

Data::Array(Vec&lt;i32&gt;)
            [––––––––––––––––––––– 32 Bytes –––––––––––––––––––––|
            +–––––+–––––––––+–––––––––––+––––––––––––+–––––––––––+
            │  2  │ padding │    none   │      0     │     0     │  
            +–––––+–––––––––+–––––––––––+––––––––––––+–––––––––––+
            | mark|         |–––––––––––––  Vec&lt;i32&gt; ––––––––––––|
                            |– pointer –|– capacity –|– length  –|
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
 enum Data {
    Empty;
    Number(i32),
    Array(Box&lt;Vec&lt;i32&gt;&gt;),
}

stack

Data::Empty
            +–––––+–––––––––––––––––––––+
            │  0  │ padding             │  
            +–––––+–––––––––––––––––––––+
            | mark|     
Data::Number
            +–––––+–––––––––+–––––––––––+
            │  1  │ padding │     0     │ 
            +–––––+–––––––––+–––––––––––+
            | mark|         |––  i32 –––|
                            |–– value ––|

Data::Array(Vec&lt;i32&gt;)
            [––––––– 16 Bytes ––––––––––|
            +–––––+–––––––––+–––––––––––+
            │  2  │ padding │      *    │    
            +–––––+–––––––––+––│––––––––+
            | mark|         |– │ Box&lt;T&gt;–|
                            |– │ pointer|
                               │
heap                           V
                       +–––––––––––+––––––––––––+–––––––––––+
                       │    none   │      0     │     0     │  
                       +–––––––––––+––––––––––––+–––––––––––+           
<span class="boring">}</span></code></pre></pre>
<h3 id="94-optiont"><a class="header" href="#94-optiont">9.4 <code>Option&lt;T&gt;</code></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Option&lt;Box&lt;i32&gt;&gt;

None
            +–––––+–––––––––––––––––––––+
            │  0  │ padding             │  
            +–––––+–––––––––––––––––––––+
            | mark|  
Some(Box&lt;i32&gt;)
            +–––––+–––––––––+–––––––––––+
            │  1  │ padding │     *     │ 
            +–––––+–––––––––+–––––––––––+
            +–––––+–––––––––+––│––––––––+
            | mark|         |– │ Box&lt;T&gt;–|
                            |– │ pointer|
                               │
heap                           V
                       +–––––––––––+
                       │     0     │    
                       +–––––––––––+

// 因为智能指针的值都不允许为0, 所以实际上上面会进行优化成下面的方式
None
            +–––––––––––+
            │     0     │  
            +–––––––––––+
            | mark|   
Some(Box&lt;i32&gt;)
            +–––––––––––+
            │     *     │ 
            +–––––––––––+
            +––│––––––––+
            |– │ Box&lt;T&gt;–|
            |– │ pointer|
               │
heap           V
               +–––––––––––+
               │     0     │    
               +–––––––––––+
<span class="boring">}</span></code></pre></pre>
<h2 id="10-arrayt和vect"><a class="header" href="#10-arrayt和vect">10. <code>array</code>,<code>[T]</code>和<code>Vec&lt;T&gt;</code></a></h2>
<h3 id="101-array"><a class="header" href="#101-array">10.1 <code>array</code></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a:[i32;3] = [55,66,77];

stack       [––––  a   ––––|
            +––––+––––+––––+
            │ 55 │ 66 │ 77 │
            +––––+––––+––––+
<span class="boring">}</span></code></pre></pre>
<h3 id="102-t"><a class="header" href="#102-t">10.2 <code>[T]</code></a></h3>
<p><code>[T]</code>即<code>slice</code> 是<code>DST</code> 类型, 是类型 T 序列的一种视图. 所以它只能使用<code>&amp;[T]</code>宽指针进行引用,参考[&amp;[T] 引用](# 5. &amp; 和&amp;[T] 引用)</p>
<h3 id="103-vect"><a class="header" href="#103-vect">10.3 <code>Vec&lt;T&gt;</code></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a:Vec&lt;i32&gt; = vec![55,66,77];

stack       [–––  a   ––|
            +–––+–––+–––+
            │ • │ 3 │ 4 │
            +–│–+–––+–––+
              │
heap          │
            +–V––+––––+––––+
            │ 55 │ 66 │ 77 │
            +––––+––––+––––+
<span class="boring">}</span></code></pre></pre>
<h2 id="11-智能指针"><a class="header" href="#11-智能指针">11. 智能指针</a></h2>
<h3 id="111-boxt"><a class="header" href="#111-boxt">11.1 <code>Box&lt;T&gt;</code></a></h3>
<p><code>Box&lt;T&gt;</code>单所有权,只适用于单线程</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Box&lt;Vec&lt;i32&gt;&gt; = Box::new(vec![55,66,77]);

stack    
            [ v ]  
            +–––+   
            │ * │      
            +–│–+    
              |
heap          |
            +–V–+–––+–––+
            │ * │ 3 │ 3 │
            +–│–+–––+–––+
              │
              │
            +–V––+––––+––––+
            │ 55 │ 66 │ 77 | 
            +––––+––––+––––+
<span class="boring">}</span></code></pre></pre>
<h3 id="112-rct"><a class="header" href="#112-rct">11.2 <code>Rc&lt;T&gt;</code></a></h3>
<p><code>Rc&lt;T&gt;</code> 多所有权,只适用于单线程,且只可用于不可变借用.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Rc&lt;Vec&lt;i32&gt;&gt; = Rc::new(vec![55,66,77]);
let v2 = v.clone()

stack    
            [ v ]       [ v2 ]
            +–––+       +–––+
            │ * │       * │ 
            +–│–+      +–│–+
              |___________|
heap          |
            +–V–+–––+–––+–––+
            │ 2 │ * │ 3 │ 3 |
            +–––+–│–+–––+–––+
              /   │
 ref count&lt;– /    │
                +–V––+––––+––––+
                │ 55 │ 66 │ 77 | 
                +––––+––––+––––+
                
<span class="boring">}</span></code></pre></pre>
<h3 id="113-arct"><a class="header" href="#113-arct">11.3 <code>Arc&lt;T&gt;</code></a></h3>
<p><code>Arc&lt;T&gt;</code> 数据模型同<code>Rc&lt;T&gt;</code>但可使用于多线程, 多所有权,只可用于不可变借用.</p>
<p><code>Arc&lt;T&gt;</code> 与<code>Rc&lt;T&gt;</code>区别在于,引用计数是原子计数</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stack    
            [ptr |meta]
            +–––-+–––+
            │ *  │   │ 
            +–│-–+--–│
              |
heap          |
            +–V–+–––+–––+
            │   │   │ T │
            +–––+--–+–––+
              /   │
 ref count &lt;–/    V 
            weak ref count
<span class="boring">}</span></code></pre></pre>
<h2 id="12-trait-object"><a class="header" href="#12-trait-object">12. trait object</a></h2>
<p>官方定义：</p>
<pre><code class="language-text">A trait object is an opaque value of another type that implements a set of traits. 
The set of traits is made up of an object safe base trait plus any number of auto traits.  
</code></pre>
<p>trait 是 <code>DST</code> 类型 ,对trait的引用称之为 trait object, trait object是个胖指针, 包含两个普通指针分别为 <code>data</code>和 <code>vtable</code>.</p>
<p><img src="rust/../assets/202205141636711.jpeg" alt="2" /></p>
<h2 id="13-dynamically-sized-typesdst-动态类型"><a class="header" href="#13-dynamically-sized-typesdst-动态类型">13. Dynamically Sized Types(DST) 动态类型</a></h2>
<p>一般来说大多数类型, 可以在编译阶段确定大小和对齐属性, <a href="https://doc.rust-lang.org/stable/reference/special-types-and-traits.html#sized">Sized trait</a> 就是保证了这种特性.</p>
<p>非 size (<code>?Sized</code>) 及 <code>DST</code> 类型.</p>
<ul>
<li>DST 类型有 slice 和 trait object.</li>
<li>DST 类型必须通过指针来使用,需要注意：</li>
<li>DST 可以作为泛型参数, 但是需要注意泛型参数默认是 <code>Sized</code>, 如果是 DST 类型需要特别的指定为 <code>?Sized</code>.</li>
</ul>
<h2 id="14-空类型-empty-types"><a class="header" href="#14-空类型-empty-types">14. 空类型 (Empty Types)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}
<span class="boring">}</span></code></pre></pre>
<p>空类型的一个主要应用场景是在类型层面声明不可到达性. 假如, 一个 API 一般需要返回一个 Result, 但是在特殊情况下它是绝对不会运行失败的. 这种情况下将返回值设为 Result&lt;T, Void&gt;, API 的调用者就可以信心十足地使用 unwrap, 因为不可能产生一个 Void 类型的值, 所以返回值不可能是一个 Err.</p>
<h2 id="15-function"><a class="header" href="#15-function">15. function</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stack    
            [ f |  
            +–––+   
            │ * │      
            +–│–+    
              |
        machine code of function
<span class="boring">}</span></code></pre></pre>
<h2 id="16-closure"><a class="header" href="#16-closure">16. closure</a></h2>
<p>闭包相当于一个捕获变量的结构体, 实现了 <code>FnOnce</code> 或 <code>FnMut</code> 或 <code>Fn</code>.</p>
<h2 id="17-reference"><a class="header" href="#17-reference">17. Reference</a></h2>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_6/ant-rust-data-layout.html">Rust数据内存布局</a></li>
</ul>
<h2 id="18-生命周期"><a class="header" href="#18-生命周期">18. 生命周期</a></h2>
<p><img src="rust/../assets/202211112240020.png" alt="image-20221111224011998" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权机制"><a class="header" href="#所有权机制">所有权机制</a></h1>
<ul>
<li><strong>一个值只能被一个变量所拥有, 这个变量被称为所有者</strong>(Each value in Rust has a variable that’s called its owner).</li>
<li><strong>一个值同一时刻只能有一个所有者</strong>(There can only be one owner at a time), 也就是说不能有两个变量拥有相同的值. 所以对应刚才说的变量赋值、参数传递、函数返回等行为, 旧的所有者会把值的所有权转移给新的所有者, 以便保证单一所有者的约束.</li>
<li><strong>当所有者离开作用域</strong>, 其拥有的值被丢弃(When the owner goes out of scope, the value will be dropped), 内存得到释放.</li>
</ul>
<h2 id="1-copy-trait"><a class="header" href="#1-copy-trait">1. Copy trait</a></h2>
<ul>
<li>原生类型, 包括函数、不可变引用和裸指针实现了 Copy；</li>
<li>数组和元组, 如果其内部的数据结构实现了 Copy, 那么它们也实现了 Copy；</li>
<li>可变引用没有实现 Copy；</li>
<li>非固定大小的数据结构, 没有实现 Copy</li>
</ul>
<h2 id="2-copy语义和move语义"><a class="header" href="#2-copy语义和move语义">2. Copy语义和Move语义</a></h2>
<p>是否实现 <code>Copy Trait</code> 区分 <code>Copy</code>语义和 <code>Move</code> 语义</p>
<ul>
<li><code>Copy</code>语义按位复制</li>
<li><code>Copy</code>语义对应值类型</li>
<li><code>Move</code>语义对应引⽤类型.</li>
</ul>
<p>所有权机制:  保证内存安全和性能
所有权转移.  每个值都有⼀个所有者.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // Box没有实现copy trait
    let a = Box::new(5);
    let b = a;
    println!("{:?}", a); // a move to b, compile error
}</code></pre></pre>
<h3 id="21-struct-enum"><a class="header" href="#21-struct-enum">2.1 Struct, Enum</a></h3>
<h4 id="struct成员均实现copy-trait-但rust并不会默认为struct实现copy"><a class="header" href="#struct成员均实现copy-trait-但rust并不会默认为struct实现copy">Struct成员均实现Copy trait, 但rust并不会默认为struct实现copy</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct A {
    // 成员虽然是copy语义, 但rust并不会默认为struct实现copy
	a: i32,
	b: i32
}

// 显示指定struct实现copy trait
#[derive(Debug, Copy, Clone)]
struct B {
	a: i32,
	b: i32
}

fn main() {
    let a = A{a: 1, b: 2};
    let b = a;
    println!("{:?}", a); // a move to b, compile error
}</code></pre></pre>
<h4 id="struct需要显式实现copy-trait使用copy宏"><a class="header" href="#struct需要显式实现copy-trait使用copy宏">Struct需要显式实现Copy trait,使用Copy宏.</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">// 显式指定struct实现copy trait
#[derive(Debug, Copy, Clone)]
struct A {
	a: i32,
	b: i32
}

fn main() {
    let a = A{a: 1, b: 2};
    let b = a;
    println!("{:?}", a); // a copy to b
}</code></pre></pre>
<h4 id="struct成员含有未实现copy-trait-那么copy宏显式指定将导致编译失败"><a class="header" href="#struct成员含有未实现copy-trait-那么copy宏显式指定将导致编译失败">Struct成员含有未实现Copy trait, 那么Copy宏显式指定将导致编译失败</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone)]
struct A {
	a: i32,
    // 当成员有未实现Copy trait的成员,即使手动指定也会编译失败
	b: Box&lt;i32&gt;
}

fn  main() {
    let a = A{a: 1, b: Box::new(5)};
    let b = a;
    println!("{:?}", a); // a move to b, compile error
}
<span class="boring">}</span></code></pre></pre>
<h3 id="22-tuple-option-array"><a class="header" href="#22-tuple-option-array">2.2 Tuple, Option, Array</a></h3>
<p><em><strong>语言默认的,成员实现则其实现Copy  trait</strong></em></p>
<h4 id="221-tuple"><a class="header" href="#221-tuple">2.2.1 Tuple</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn  main() {
    let a =  (String::from("a"), String::from("b"))
    let b = a;
    println!("{:?}", a); // a move to b, compile error
    
    let c =  (1, 2, 3)
    let d = c;
    println!("{:?}", c); // c copy to d
}
<span class="boring">}</span></code></pre></pre>
<h4 id="222-arrary"><a class="header" href="#222-arrary">2.2.2 Arrary</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = [1, 2, 3];
    foo(v); // copy
    assert_eq!([1, 2, 3], v)
}

fn foo(mut v: [i32; 3]) -&gt; [i32; 3] {
    v[0] = 3;
    assert_eq!([3, 2, 3], v);
    v
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut v = [1, 2, 3];
    foo(&amp;mut v); // borrow
    assert_eq!([3, 2, 3], v)
}

fn foo(v: &amp;mut [i32; 3]) {
    v[0] = 3;
}
</code></pre></pre>
<h2 id="3-借用规则"><a class="header" href="#3-借用规则">3. 借用规则</a></h2>
<ul>
<li>借⽤的⽣命周期不能⻓于出借⽅.         --&gt; 防⽌出现悬垂指针.</li>
<li>可变借⽤不能有别名.                           --&gt; 独占, 可变借⽤不能共享, 只能独占, 只能有⼀个.</li>
<li>不可变借⽤可以多个共享.                    --&gt; 共享不可变</li>
<li>不可变借用和可变借用不可同时存在(作用域内).</li>
</ul>
<h2 id="4-解引用操作会获取所有权"><a class="header" href="#4-解引用操作会获取所有权">4. 解引用操作会获取所有权</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型系统"><a class="header" href="#类型系统">类型系统</a></h1>
<h2 id="1-概述"><a class="header" href="#1-概述">1. 概述</a></h2>
<ul>
<li>类型大小, 类型在内存中对⻬、布局</li>
<li>类型推导</li>
<li>泛型</li>
<li><code>Trait</code></li>
<li>类型转换</li>
<li>多态</li>
</ul>
<p><code>Rust</code>是一⻔<strong>显式静态强类型的类型安全语言</strong></p>
<ul>
<li>显式: 是因为它的类型推导在某些时候需要显示指定</li>
<li>静态: 表明它在编译期进行类型检查</li>
<li>强类型: 表明它不允许类型自动隐式转换,不同类型无法进行计算</li>
<li>类型安全: 表明它保证运行时的内存安全, 只能按照被允许的方法, 访问它被授权访问的内存</li>
</ul>
<p><img src="rust/../assets/202211121059386.png" alt="image-20221112105907209" /></p>
<h2 id="2-类型大小"><a class="header" href="#2-类型大小">2 类型大小</a></h2>
<h3 id="21-可确定大小类型"><a class="header" href="#21-可确定大小类型">2.1 可确定大小类型</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use std::mem;

fn main() {
    println!("{}", mem::size_of::&lt;bool&gt;());
    println!("{}", mem::size_of::&lt;u8&gt;());
    println!("{}", mem::size_of::&lt;i8&gt;());
    println!("{}", mem::size_of::&lt;u16&gt;());
    println!("{}", mem::size_of::&lt;i16&gt;());
    println!("{}", mem::size_of::&lt;u32&gt;());
    println!("{}", mem::size_of::&lt;i32&gt;());
    println!("{}", mem::size_of::&lt;f32&gt;());
    println!("{}", mem::size_of::&lt;f64&gt;());
    println!("{}", mem::size_of::&lt;char&gt;());
    println!("{}", mem::size_of::&lt;()&gt;());
}</code></pre></pre>
<h3 id="22-动态大小类型"><a class="header" href="#22-动态大小类型">2.2 动态大小类型</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let str = "hello world";
    let prt = str.as_ptr();
    let len = str.len();

    println!("{:p}", prt);
    println!("{:?}", len);
}
</code></pre></pre>
<h3 id="23-零值类型"><a class="header" href="#23-零值类型">2.3 零值类型</a></h3>
<p>零值类型: 类型的特别是可以提高性能或实现某些<code>trait</code>而不关心其数据</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::mem;

// 零大小类型, 不分配内存空间.
enum Void {}  // 空枚举
struct Foo;   // 单元结构体
struct Bar {
    foo: Foo,
    qux: (), 		// 单元类型
    bax: [u8; 0],   // 空数组
}

fn main() {
    println!("{}", mem::size_of::&lt;()&gt;());
    println!("{}", mem::size_of::&lt;Void&gt;());
    println!("{}", mem::size_of::&lt;Foo&gt;());
    println!("{}", mem::size_of::&lt;Bar&gt;());
    println!("{}", mem::size_of::&lt;[(); 10]&gt;());
}
</code></pre></pre>
<h2 id="3-类型推导"><a class="header" href="#3-类型推导">3. 类型推导</a></h2>
<h3 id="31-自动推导"><a class="header" href="#31-自动推导">3.1 自动推导</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">// Rust大部份情况下可以根据上下文明推导类型
fn main() {
    let a = 1; // 没有标注类型. 
    let b = 2; // 没有标注类型.
    sum(a, b); // Rust 自动推导了a和b的类型.
    let elem = 5u8;
    let mut vec = Vec::new();
    vec.push(elem);
}

fn sum(a: u32, b: i32) -&gt; u32 {
    a + (b as u32)
}</code></pre></pre>
<h3 id="32-手动标注"><a class="header" href="#32-手动标注">3.2 手动标注</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">// 引入 turbofish 操作符 ::&lt;&gt;
fn main() {
    let x = "1";
    println!("{:?}", x.parse::&lt;u32&gt;().unwrap());
}
</code></pre></pre>
<h2 id="4-泛型"><a class="header" href="#4-泛型">4. 泛型</a></h2>
<p>单态化 零成本抽象的一种实现,</p>
<p>其实在 <code>Rust</code> 里, 生命周期标注也是泛型的一部分, 一个生命周期<code> 'a</code> 代表任意的生命周期, 和 <code>T</code> 代表任意类型是一样的</p>
<h2 id="5-trait"><a class="header" href="#5-trait">5. <code>Trait</code></a></h2>
<p>Rust的<code>trait</code>提供了零成本抽象能力, 它定义了类型使用这个接口的行为</p>
<p>在 <code>trait</code> 中, 方法可以有缺省的实现.</p>
<p>在定义方法的时候, 频繁看到两个特殊的关键字：<code>Self</code> 和 <code>self</code>.</p>
<ul>
<li><code>Self</code> 代表当前的类型, 比如 <code>File</code> 类型实现了 <code>Write</code>, 那么实现过程中使用到的 <code>Self</code> 就指代 <code>File</code>.</li>
<li><code>self</code> 在用作方法的第一个参数时, 实际上是 <code>self: Self</code> 的简写, 所以 <code>&amp;self</code> 是 <code>self: &amp;Self</code>, 而 <code>&amp;mut self</code> 是 <code>self: &amp;mut Self</code>.</li>
</ul>
<p><code>trait</code> 的"继承"</p>
<p>在 <code>Rust</code> 中, 一个 <code>trait</code> 可以“继承”另一个 <code>trait</code> 的关联类型和关联函数. 比如 <code>trait B: A</code> , 是说任何类型 <code>T</code>, 如果实现了 <code>trait B</code>, 它也必须实现 <code>trait A</code>, 换句话说, <code>trait B</code> 在定义时可以使用 <code>trait A</code> 中的关联类型和方法</p>
<p><code>Trait</code> 如何定义和使用</p>
<p><img src="rust/../assets/202211062149694.png" alt="image-20221106214938533" /></p>
<p><code>Trait Object</code> 实现原理</p>
<p><img src="rust/../assets/202211062151668.png" alt="image-20221106215145601" /></p>
<h2 id="6-类型转换"><a class="header" href="#6-类型转换">6. 类型转换</a></h2>
<p>无歧义完全限定语法</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait A {
    fn test(&amp;self, i: i32) {
        println!("from trait A: {:?}", i)
    }
}

trait B {
    fn test(&amp;self, i: i32) {
        println!("from trait B: {:?}", i)
    }
}

struct S(i32);

impl A for S {}
impl B for S {}

fn main() {
    let s = S(1);
    A::test(&amp;s, 2);
    &lt;S as A&gt;::test(&amp;s, 2);
    B::test(&amp;s, 2);
    &lt;S as B&gt;::test(&amp;s, 2);
}</code></pre></pre>
<p><img src="rust/../assets/202211121122156.png" alt="image-20221112112230032" /></p>
<h2 id="7-多态"><a class="header" href="#7-多态">7. 多态</a></h2>
<p>静态类型系统, 多态可以通过<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism"><strong>参数多态(parametric polymorphism)</strong></a>、<a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism"><strong>特设多态(adhoc polymorphism)</strong></a>和<a href="https://en.wikipedia.org/wiki/Subtyping"><strong>子类型多态(subtype polymorphism)实现</strong></a>.</p>
<ul>
<li><strong>参数多态</strong>是指, 代码操作的类型是一个满足某些约束的参数, 而非具体的类型.  <code>Rust</code>通过泛型支持.</li>
<li><strong>特设多态</strong>是指同一种行为有多个不同实现的多态. 比如加法, 可以 1+1, 也可以是 “abc” + “cde”、matrix1 + matrix2、甚至 matrix1 + vector1. 在面向对象编程语言中, 特设多态一般指函数的重载. <code>Rust</code>通过<code>trait</code>支持.</li>
<li><strong>子类型多态</strong>是指, 在运行时, 子类型可以被当成父类型使用.  <code>Rust</code>通过<code>trait object</code>支持.</li>
</ul>
<p>在 <code>Rust</code> 中, <strong>参数多态</strong>通过泛型来支持、<strong>特设多态</strong>通过 <code>trait</code> 来支持、<strong>子类型多态</strong>可以用 <code>trait object</code> 来支持,</p>
<h3 id="71--参数多态"><a class="header" href="#71--参数多态">7.1  参数多态</a></h3>
<p>它包括<strong>泛型数据结构</strong>和<strong>泛型函数</strong></p>
<ul>
<li>
<p><strong>泛型数据结构</strong>: <code>Rust</code> 对数据结构的泛型, 或者说参数化类型, 有着完整的支持. 例: <code>Option&lt;T&gt;</code></p>
</li>
<li>
<p><strong>泛型函数</strong>: 在声明一个函数的时候, 我们还可以不指定具体的参数或返回值的类型, 而是由泛型参数来代替</p>
</li>
</ul>
<h3 id="72-特设多态"><a class="header" href="#72-特设多态">7.2 特设多态</a></h3>
<p>包括运算符重载, 是指同一种行为有很多不同的实现</p>
<h3 id="73-子类型多态"><a class="header" href="#73-子类型多态">7.3 子类型多态</a></h3>
<p>子类型当成父类型使用, 通过 <code>trait object</code> 来支持,</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无畏并发"><a class="header" href="#无畏并发">无畏并发</a></h1>
<ul>
<li><code>Concurrent</code>: 程序的不同部分之间独立的运行, 同时处理很多事情的能力.</li>
<li><code>Parallel</code>: 程序的不同部分同时运行, 同时执行很多事情的手段.</li>
</ul>
<h2 id="1-sync和send-trait"><a class="header" href="#1-sync和send-trait">1. <code>Sync</code>和<code>Send</code> trait</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe auto trait Send {}
pub unsafe auto trait Sync {}
<span class="boring">}</span></code></pre></pre>
<p>这两个<code>trait</code>(<code>std::marker::Sync</code>和<code>std::marker::Send</code>)都是 <code>unsafe auto trait</code>,  <code>auto</code> 意味着编译器会在合适的场合, 自动为数据结构添加它们的实现,  而 <code>unsafe</code> 代表实现的这个 <code>trait</code> 可能会违背 <code>Rust</code> 的内存安全准则,  如果开发者手工实现这两个 <code>trait</code>, 要自己为它们的安全性负责.</p>
<p><code>Send/Sync</code> 是 <code>Rust</code> 并发安全的基础:</p>
<ul>
<li>
<p><code>Send</code>: 允许线程间<strong>转移所有权</strong>, <code>Rc&lt;T&gt;</code>没有实现<code>Send</code>,它只用于单线程的情景.</p>
<ul>
<li>任何完全由<code>Send</code>类型组成的类型也被标记为<code>Send</code></li>
<li>除了原始指针之外,几乎所有的基础类型都是实现了<code>Send</code></li>
</ul>
</li>
<li>
<p><code>Sync</code>: 允许从<strong>多线程访问</strong>.</p>
<ul>
<li>实现了<code>Sync</code>的类型可以安全的被多个线程引用</li>
<li>如果<code>T</code>是<code>Sync</code>,那<code>&amp;T</code>就是<code>Send</code>, 引用可以被安全的送往另一个线程.</li>
</ul>
</li>
<li>
<p>手动来实现<code>Send</code>和<code>Sync</code>是很难保证安全的,需要很谨慎的使用<code>unsafe</code>代码.</p>
<ul>
<li>
<p>如果一个类型 <code>T</code> 实现了 <code>Send trait</code>,  意味着 <code>T</code> 可以安全地从一个线程移动到另一个线程,  也就是说所有权可以在线程间移动.</p>
</li>
<li>
<p>如果一个类型 <code>T</code> 实现了 <code>Sync trait</code>,  则意味着 <code>&amp;T</code> 可以安全地在多个线程中共享. 一个类型 <code>T</code> 满足 <code>Sync trait</code>,  当且仅当 <code>&amp;T</code> 满足 <code>Send trait</code>.</p>
</li>
</ul>
</li>
</ul>
<p>对于 <code>Send/Sync</code> 在线程安全中的作用,  可以这么看, <strong>如果一个类型 <code>T: Send</code>, 那么 <code>T</code> 在某个线程中的独占访问是线程安全的；如果一个类型 <code>T: Sync</code>, 那么 <code>T</code> 在线程间的只读共享是安全的.</strong></p>
<p>对于我们自己定义的数据结构,  如果其内部的所有域都实现了 <code>Send</code> / <code>Sync</code>,  那么这个数据结构会被自动添加 <code>Send</code> / <code>Sync</code>.</p>
<p>标准库中, 不支持 <code>Send</code> / <code>Sync</code> 的数据结构主要有:</p>
<ul>
<li>裸指针 <code>*const T</code> /<code>*mut T</code>. 它们是不安全的,  所以既不是 <code>Send</code> 也不是 <code>Sync</code>.</li>
<li><code>UnsafeCell</code> 不支持 <code>Sync</code>. 也就是说,  任何使用了 <code>Cell</code> 或者 <code>RefCell</code> 的数据结构不支持 <code>Sync</code>.</li>
<li>引用计数 <code>Rc</code> 不支持 <code>Send</code> 也不支持 <code>Sync</code>. 所以 <code>Rc</code> 无法跨线程.</li>
</ul>
<h2 id="2-并发常见工作模式"><a class="header" href="#2-并发常见工作模式">2. 并发常见工作模式</a></h2>
<p><img src="rust/../assets/202211080809744.png" alt="image-20221108080915636" /></p>
<ul>
<li><strong>自由竞争模式</strong>下, 多个并发任务会竞争同一个临界区的访问权</li>
<li><strong>map/reduce 模式</strong>, 把工作打散, 按照相同的处理完成后, 再按照一定的顺序将结果组织起来</li>
<li><strong>DAG 模式</strong>, 把工作切成不相交的、有依赖关系的子任务, 然后按依赖关系并发执行.</li>
</ul>
<h2 id="3-atomic"><a class="header" href="#3-atomic">3. Atomic</a></h2>
<p><code>Atomic</code>是所有并发原语的基础, 它为并发任务的同步奠定了坚实的基础.可以通过一条指令读取某个内存地址, 判断其值是否等于某个前置值, 如果相等, 将其修改为新的值. 这就是 <code>Compare-and-swap</code> 操作, 简称<a href="https://en.wikipedia.org/wiki/Compare-and-swap"><code>CAS</code></a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compare_exchange(
    &amp;self,
    current: bool,
    new: bool,
    success: Ordering,
    failure: Ordering
) -&gt; Result&lt;bool, bool&gt;

pub enum Ordering {
    Relaxed,
    Release,
    Acquire,
    AcqRel,
    SeqCst,
}
<span class="boring">}</span></code></pre></pre>
<p>可以看到 <code>compare_exchange</code>函数有两个和<code>Ordering</code>的奇怪参数, <a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>是一个 <code>enum</code>.</p>
<ul>
<li><code>Relaxed</code> : 最宽松的规则, 它对编译器和CPU不做任何限制, 可以乱序执行.</li>
<li><code>Release</code>, 当我们<strong>写入数据</strong>时, 那么
<ul>
<li>对于当前线程, 任何读取或写入操作都不能被乱序排在这个 store 之后.</li>
<li>对于其它线程, 任何使用了<code>Acquire</code>来读取这个<code>atomic</code>的数据, 那么它们看到的是修改后的结果.</li>
</ul>
</li>
<li><code>Acquire</code>, 当我们<strong>读取数据</strong>时, 那么
<ul>
<li>对于当前线程, 任何读取或者写入操作都不能被乱序排在这个读取之前.</li>
<li>对于其它线程, 如果使用了 <code>Release</code> 来修改数据, 那么, 修改的值对当前线程可见.</li>
</ul>
</li>
<li><code>AcqRel</code>是<code>Acquire</code>和<code>Release</code>的结合, 同时拥有<code>Acquire</code>和<code>Release</code>的保证. 这个一般用在 <code>fetch_xxx</code> 上, 比如你要对一个<code>atomic</code>自增1, 你希望这个操作之前和之后的读取或写入操作不会被乱序, 并且操作的结果对其它线程可见.</li>
<li><code>SeqCst</code> 是最严格的<code>Ordering</code>,除了<code>AcqRel</code>的保证外,它还保证所有线程看到的所有<code>SeqCst</code>操作的顺序是一致的.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while self
    .locked
    .compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)
    .is_err()
{
    // 性能优化: compare_exchange 需要独占访问, 当拿不到锁时, 我们
    // 先不停检测 locked 的状态, 直到其 unlocked 后, 再尝试拿锁
    while self.locked.load(Ordering::Relaxed) == true {}
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意, 我们在 <code>while loop</code> 里, 又嵌入了一个 <code>loop</code>. 这是因为 <code>CAS</code> 是个代价比较高的操作, 它需要获得对应内存的独占访问 (<code>exclusive access</code>) , 我们希望失败的时候只是简单读取 atomic 的状态, 只有符合条件的时候再去做独占访问, 进行 <code>CAS</code>. 所以, 看上去多做了一层循环, 实际代码的效率更高.</p>
</blockquote>
<h2 id="4-mutex"><a class="header" href="#4-mutex">4. Mutex</a></h2>
<p><code>SpinLock</code>, 顾名思义,就是线程通过<strong>CPU 空转</strong>(<code>spin</code>, 就像前面的 while loop)忙等 (busy wait) , 来等待某个临界区可用的一种锁. 这种通过 <code>SpinLock</code>做互斥的实现方式有使用场景的限制: 如果受保护的临界区太大, 那么整体的性能会急剧下降,  CPU 忙等, 浪费资源还不干实事, 不适合作为一种通用的处理方法.</p>
<p>通用的解决方案是: 当多个线程竞争同一个 <code>Mutex</code> 时, 获得锁的线程得到临界区的访问, 其它线程被挂起, 放入该 <code>Mutex</code> 上的一个等待队列里. 当获得锁的线程完成工作, 退出临界区时, <code>Mutex</code> 会给等待队列发一个信号, 把队列中第一个线程唤醒, 于是这个线程可以进行后续的访问. 整个过程如下:</p>
<p><img src="rust/../assets/202211090854786.png" alt="image-20221109085449640" /></p>
<p>当然, 这样实现会带来公平性的问题: 如果新来的线程恰巧在 <code>spin</code> 过程中拿到了锁, 而当前等待队列中还有其它线程在等待锁, 那么等待的线程只能继续等待下去, 这不符合 <code>FIFO</code>, 不适合那些需要严格按先来后到排队的使用场景. 为此, <a href="https://github.com/Amanieu/parking_lot"><code>parking_lot</code></a> 提供了 <code>fair mutex</code>.</p>
<h2 id="5-condvar"><a class="header" href="#5-condvar">5. Condvar</a></h2>
<p>操作系统还提供了 <code>Condvar</code>. <code>Condvar</code> 有两种状态:</p>
<ul>
<li>等待 (wait) : 线程在队列中等待, 直到满足某个条件.</li>
<li>通知 (notify) : 当<code>condvar</code>的条件满足时, 当前线程通知其他等待的线程可以被唤醒. 通知可以是单个通知, 也可以是多个通知, 甚至广播 (通知所有人).</li>
</ul>
<h2 id="6-channel"><a class="header" href="#6-channel">6. Channel</a></h2>
<p><code>Channel</code> 把锁封装在了队列写入和读取的小块区域内, 然后把读者和写者完全分离, 使得读者读取数据和写者写入数据, 对开发者而言, 除了潜在的上下文切换外, 完全和锁无关, 就像访问一个本地队列一样. 所以, 对于大部分并发问题, 我们都可以用 <code>Channel</code> 或者类似的思想来处理 (比如 actor model).</p>
<p><code>Rust</code>提供了以下四种<code>Channel</code>:</p>
<ul>
<li>
<p><code>oneshot</code>: 这可能是最简单的 <code>Channel</code>, 写者就只发一次数据, 而读者也只读一次. 这种一次性的、多个线程间的同步可以用 <code>oneshot channel</code> 完成. 由于 <code>oneshot</code> 特殊的用途, 实现的时候可以直接用 <code>atomic swap</code> 来完成</p>
</li>
<li>
<p><code>rendezvous</code>: 很多时候, 我们只需要通过 <code>Channel</code> 来控制线程间的同步, 并不需要发送数据. <code>rendezvous channel</code> 是 <code>channel size</code> 为 <strong>0</strong> 的一种特殊情况.</p>
</li>
<li>
<p><code>bounded</code>: <code>bounded channel</code> 有一个队列, 但队列有上限. 一旦队列被写满了, 写者也需要被挂起等待. 当阻塞发生后, 读者一旦读取数据, <code>channel</code> 内部就会使用 <code>Condvar</code> 的 <code>notify_one</code> 通知写者, 唤醒某个写者使其能够继续写入.</p>
</li>
<li>
<p><code>unbounded</code>: <code>queue</code> 没有上限, 如果写满了, 就自动扩容. 我们知道, <code>Rust</code> 的很多数据结构如 <code>Vec</code> 、<code>VecDeque</code> 都是自动扩容的. <code>unbounded</code> 和 <code>bounded</code> 相比, 除了不阻塞写者, 其它实现都很类似.</p>
</li>
</ul>
<p><img src="rust/../assets/202211091117761.png" alt="image-20221109111700680" /></p>
<p>根据 <code>Channel</code> 读者和写者的数量, <code>Channel</code> 又可以分为:</p>
<ul>
<li><code>SPSC</code>: Single-Producer Single-Consumer, 单生产者, 单消费者. 最简单, 可以不依赖于 <code>Mutex</code>, 只用 <code>atomics</code> 就可以实现.</li>
<li><code>SPMC</code>: Single-Producer Multi-Consumer, 单生产者, 多消费者. 需要在消费者这侧读取时加锁.</li>
<li><code>MPSC</code>: Multi-Producer Single-Consumer, 多生产者, 单消费者. 需要在生产者这侧写入时加锁.</li>
<li><code>MPMC</code>: Multi-Producer Multi-Consumer. 多生产者, 多消费者. 需要在生产者写入或者消费者读取时加锁.</li>
</ul>
<h2 id="7-actor"><a class="header" href="#7-actor">7. Actor</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Actor_model"><code>actor model</code></a>, <code>actor</code> 是一种有栈协程. 每个 <code>actor</code>, 有自己的一个独立的、轻量级的调用栈, 以及一个用来接受消息的消息队列 (<code>mailbox</code> 或者 <code>message queue</code>) , 外界跟 <code>actor</code> 打交道的唯一手段就是, 给它发送消息.</p>
<h2 id="9-参考"><a class="header" href="#9-参考">9. 参考</a></h2>
<ul>
<li>Robe Pike 的演讲 <a href="https://go.dev/blog/waza-talk">concurrency is not parallelism</a></li>
<li>Jon Gjengset 的视频: <a href="https://www.youtube.com/watch?v=rMGWeSjctlY">Crust of Rust: Atomics and Memory Ordering</a></li>
<li>Rust 的 <a href="https://github.com/mvdnes/spin-rs">spin-rs crate</a> 提供了 <code>Spinlock</code> 的实现</li>
<li><a href="https://github.com/actix/actix">atcix</a> actor 实现</li>
<li><a href="https://github.com/bastion-rs/bastion">bastion</a> actor 实现</li>
<li>concurrent hash map: <a href="https://github.com/xacrimon/dashmap">dashmap</a> , <a href="https://github.com/jonhoo/left-right">left-right</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏-macro"><a class="header" href="#宏-macro">宏 macro</a></h1>
<p>宏在 Rust 里指的是一组相关特性的集合称谓:</p>
<ul>
<li>使用<code>macro_rules!</code> 构建的声明宏 (declarative macro)</li>
<li>3 种过程宏
<ul>
<li>自定义<code>#[derive]</code>宏, 用于struct 或enum, 可以为其指定随 <code>derive</code> 属性添加的代码</li>
<li>类似属性的宏, 在任何条目上添加自定义属性</li>
<li>类似函数的宏, 看起来像函数调用, 对其指定为参数的 token 进行操作</li>
</ul>
</li>
</ul>
<h2 id="1-宏与函数的差别"><a class="header" href="#1-宏与函数的差别">1. 宏与函数的差别</a></h2>
<ul>
<li>
<p>宏是用来编写可以生成其它代码的代码, 即所谓的 <strong>元编程</strong>(metaprogramming)</p>
</li>
<li>
<p>函数在定义签名时, 必须声明参数的个数和类型,</p>
</li>
<li>
<p>宏可处理可变的参数</p>
</li>
<li>
<p>编译器会在解释代码前展开宏</p>
</li>
<li>
<p>宏的定义比函数复杂得多,  难以阅读,理解, 维护</p>
</li>
<li>
<p>在某个文件调用宏时, 必须提前定义宏或将宏引入当前作用哉</p>
</li>
<li>
<p>函数可以在任何位置定义,并在任何位置使用</p>
</li>
</ul>
<h2 id="2-macro_rules声明宏"><a class="header" href="#2-macro_rules声明宏">2. <code>macro_rules!</code>声明宏</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x: expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    }
}
// 此处有一个单边模式 ( $( $x: expr ),* ), 后跟 =&gt; 和模式相关的代码块. 如果模式匹配, 代码将被执行. 更复杂的宏会有多个单边模式.
// $x: expr 匹配任何rust的表达式,并命名为x
// $( $x: expr ),* 表示匹配*号前0个或1个表达式
<span class="boring">}</span></code></pre></pre>
<h2 id="3-过程宏"><a class="header" href="#3-过程宏">3. 过程宏</a></h2>
<p>这种形式更像函数</p>
<ul>
<li>接收并操作输入的Rust代码</li>
<li>生成另外一些Rust代码结果</li>
</ul>
<p>三种过程宏:</p>
<ul>
<li>自定义派生</li>
<li>属性宏</li>
<li>函数宏</li>
</ul>
<p><strong>Note: 创建过程宏时, 宏定义必须单独放在它们自己的包中, 并使用特殊的包类型</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包closure-fnonce-fnmut-fn"><a class="header" href="#闭包closure-fnonce-fnmut-fn">闭包(closure): FnOnce, FnMut, Fn</a></h1>
<h2 id="1-闭包定义"><a class="header" href="#1-闭包定义">1. 闭包定义</a></h2>
<blockquote>
<p>闭包是将函数, 或者说代码和其环境一起存储的一种数据结构. 闭包引用的上下文中的自由变量, 会被捕获到闭包的结构中, 成为闭包类型的一部分</p>
</blockquote>
<p>在 Rust 里, 闭包可以用 <code>|args| { code }</code> 来表述, 除了用引用来捕获自由变量之外, 还有另外一个方法使用 <code>move</code> 关键字 <code>move |args| { code }</code></p>
<p>图中闭包 <code>c</code> 捕获了上下文中的 <code>a</code> 和 <code>b</code>, 并通过<strong>引用</strong>来使用这两个自由变量:</p>
<p><img src="rust/../assets/202301142131136.png" alt="image-20230114213128033" /></p>
<h2 id="2-闭包的本质"><a class="header" href="#2-闭包的本质">2. 闭包的本质</a></h2>
<ul>
<li>
<p>闭包是一种匿名类型, <strong>一旦声明, 就会产生一个新的类型</strong>, 但这个类型无法被其它地方使用. <strong>这个类型就像一个结构体, 会包含所有捕获的变量</strong>.</p>
</li>
<li>
<p><strong>闭包的大小跟参数、局部变量都无关, 只跟捕获的变量有关.</strong></p>
</li>
<li>
<p><strong>闭包是存储在栈上, 并且除了捕获的数据外, 闭包本身不包含任何额外函数指针指向闭包的代码</strong></p>
</li>
<li>
<p>闭包变量的所有权:</p>
<ul>
<li>如果不使用 <code>move</code> 转移所有权, 闭包会引用上下文中的变量, <strong>这个引用受借用规则的约束</strong>, 所以只要编译通过, 那么闭包对变量的引用就不会超过变量的生命周期, 没有内存安全问题.</li>
<li>如果使用 <code>move</code> 转移所有权, 上下文中的变量在转移后就无法访问, <strong>闭包完全接管这些变量</strong>, 它们的生命周期和闭包一致, 所以也不会有内存安全问题.</li>
</ul>
</li>
</ul>
<h2 id="3-闭包类型"><a class="header" href="#3-闭包类型">3. 闭包类型</a></h2>
<p><code>FnOnce</code> / <code>FnMut</code> / <code>Fn</code> 这三种闭包类型有什么区别.</p>
<h3 id="31-fnonce"><a class="header" href="#31-fnonce">3.1 FnOnce</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    
    extern "rust-call" fn call_once(self, args: Args) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p><code>FnOnce</code>有一个关联类型, 这是闭包的返回值类型, 还有一个方法 <code>call_once</code>, 注意<code>call_once</code>第一个参数是<code>self</code>,它会转移<code>self</code>的所有权到<code>call_once</code>函数中.</p>
<p>这也是为什么<code>FnOnce</code>被称为 <strong>Once</strong>: <strong>它只能被调用一次</strong>, 再次调用, 编译器将报变量已被 move 的所有权错误.</p>
<p><code>FnOnce</code> 的参数, 是一个叫 <code>Args</code> 的泛型参数, 它并没有任何约束.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let name = String::from("Tyr");
    // 这个闭包啥也不干, 只是把捕获的参数返回去
    // 这是一个FnOnce闭包
    let c = move |greeting: String| (greeting, name);

    let result = c("hello".to_string());

    println!("result: {:?}", result);

    // 无法再次调用
    let result = c("hi".to_string());
}</code></pre></pre>
<h2 id="32-fnmut"><a class="header" href="#32-fnmut">3.2 FnMut</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern "rust-call" fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>FnMut</code> “继承”了 <code>FnOnce</code>, 所以 <code>FnMut</code> 也拥有 <code>Output</code> 这个关联类型和 <code>call_once</code> 这个方法. 此外, 它还有一个 <code>call_mut()</code> 方法. <strong>注意 <code>call_mut()</code> 传入 <code>&amp;mut self</code>, 它不移动 <code>self</code>, 所以 <code>FnMut</code> 可以被多次调用.</strong></li>
<li><code>FnMut</code> “继承”了 <code>FnOnce</code>, 所以, 一个 <code>FnMut</code> 闭包, 可以被传给一个需要 <code>FnOnce</code> 的上下文, 此时调用闭包相当于调用了 <code>call_once()</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut name = String::from("hello");
  
    // 捕获 &amp;mut name
    let mut c = || {
        name.push_str(" Tyr");
        println!("c: {}", name);
    };

    call_mut(&amp;mut c);
    call_once(c);
}

// 在作为参数时, FnMut 也要显式地使用 mut, 或者 &amp;mut
fn call_mut(c: &amp;mut impl FnMut()) {
    c();
}

// 为啥 call_once 不需要 mut？
fn call_once(c: impl FnOnce()) {
    c();
}</code></pre></pre>
<h2 id="33-fn"><a class="header" href="#33-fn">3.3 Fn</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern "rust-call" fn call(&amp;self, args: Args) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Fn</code>“继承”了 <code>FnMut</code>. 这也就意味着任何需要 <code>FnOnce</code> 或者 <code>FnMut</code> 的场合, 都可以传入满足 <code>Fn</code> 的闭包</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = vec![0u8; 1024];

    // Fn, 不移动所有权
    let mut c = |x: u64| v.len() as u64 * x;
    // Fn, 移动所有权
    // let mut c = move |x: u64| v.len() as u64 * x;

    println!("direct call: {}", c(2));
    println!("call: {}", call(3, &amp;c));
    println!("call_mut: {}", call_mut(4, &amp;mut c));
    println!("call_once: {}", call_once(5, c));
}

fn call(arg: u64, c: &amp;impl Fn(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_mut(arg: u64, c: &amp;mut impl FnMut(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_once(arg: u64, c: impl FnOnce(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}</code></pre></pre>
<h2 id="34-闭包使用场景"><a class="header" href="#34-闭包使用场景">3.4 闭包使用场景</a></h2>
<ul>
<li>
<p>作为参数</p>
</li>
<li>
<p>作为函数返回值</p>
</li>
<li>
<p>为它实现某个<code>trait</code></p>
<ul>
<li>使其能表现出其他行为, 而不仅仅作为函数被调用. 比如有些接口既可以传入一个结构体, 又可以传入一个函数或者闭包.</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/hyperium/tonic">tonic</a> (Rust 下的 gRPC 库) 的<a href="https://docs.rs/tonic/0.5.2/src/tonic/service/interceptor.rs.html#41-53">例子</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Interceptor {
    /// Intercept a request before it is sent, optionally cancelling it.
    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;;
}

impl&lt;F&gt; Interceptor for F
where
    F: FnMut(crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;,
{
    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt;  Result&lt;crate::Request&lt;()&gt;, Status&gt; {
        self(request)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Interceptor</code> 有一个 <code>call</code> 方法, 它可以让 gRPC Request 被发送出去之前被修改, 一般是添加各种头, 比如 <code>Authorization</code> 头.</p>
</blockquote>
<h2 id="4总结"><a class="header" href="#4总结">4.总结</a></h2>
<p><code>Rust</code> 闭包的效率非常高. 首先闭包捕获的变量, 都储存在栈上, 没有堆内存分配. 其次因为闭包在创建时会隐式地创建自己的类型, 每个闭包都是一个新的类型. 通过闭包自己唯一的类型, <code>Rust</code> 不需要额外的函数指针来运行闭包, 所以闭包的调用效率和函数调用几乎一致.</p>
<p><img src="rust/../assets/202211051621413.png" alt="image-20221105162134886" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<h2 id="1-option-和-result"><a class="header" href="#1-option-和-result">1. Option 和 Result</a></h2>
<p><code>Option</code> 是一个 <code>enum</code>, 它可以承载有值 / 无值这种最简单的错误类型.</p>
<p>其定义如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Option&lt;T&gt; {
    None,
    Some(T),

<span class="boring">}</span></code></pre></pre>
<p><code>Result</code> 是一个更加复杂的 <code>enum</code>, 当函数出错时, 可以返回 Err(E), 否则 Ok(T).</p>
<p>其定义如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use = "this `Result` may be an `Err` variant, which should be handled"]
pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="2--操作符"><a class="header" href="#2--操作符">2. ? 操作符</a></h2>
<p>好在 <code>Rust</code> 除了有强大的类型系统外, 还具备元编程的能力, 所以在 <code>Rust</code> 代码中, 如果你只想传播错误, 不想就地处理, 可以用 <code>?</code> 操作符.</p>
<p><code>?</code> 操作符内部被展开成类似下面的代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match result {
  Ok(v) =&gt; v,
  Err(e) =&gt; return Err(e.into())
}
<span class="boring">}</span></code></pre></pre>
<p>在不同的错误类型之间是无法直接使用的, 注意上面的 <code>e.into()</code>, 需要实现 <code>From trait</code> 在二者之间建立起转换的桥梁</p>
<h2 id="3-函数式错误处理"><a class="header" href="#3-函数式错误处理">3. 函数式错误处理</a></h2>
<p><code>Rust</code> 还为 <code>Option</code> 和 <code>Result</code> 提供了大量的辅助函数, 如 <code>map</code> / <code>map_err</code> / <code>and_then</code>, 你可以很方便地处理数据结构中部分情况. 如下图所示:</p>
<p><img src="rust/../assets/202301151832614.png" alt="image-20230115183216477" /></p>
<p>通过这些函数, 你可以很方便地对错误处理引入<a href="https://www.slideshare.net/ScottWlaschin/railway-oriented-programming">Railroad oriented programming</a> 范式</p>
<h2 id="4-panic-和-catch_unwind"><a class="header" href="#4-panic-和-catch_unwind">4. panic! 和 catch_unwind</a></h2>
<p><code>panic!</code> 是不可恢复或者不想恢复的错误, 我们希望在此刻, 程序终止运行并得到崩溃信息.</p>
<p><code>Rust</code> 标准库下提供了 <code>catch_unwind()</code> , 把调用栈回溯到 <code>catch_unwind</code> 这一刻你就可以把 <code>Rust</code> 代码整个封装在 <code>catch_unwind()</code> 函数所需要传入的闭包中. 这样, 一旦任何代码中, 包括第三方 <code>crates</code> 的代码, 含有能够导致 <code>panic!</code> 的代码, 都会被捕获, 并被转换为一个 <code>Result</code>.</p>
<h2 id="5-error-trait-和-错误的转换"><a class="header" href="#5-error-trait-和-错误的转换">5. Error trait 和 错误的转换</a></h2>
<p>为了规范这个代表错误的数据类型的行为, <code>Rust</code> 定义了 <code>Error trait</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; { ... }
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt; { ... }
    fn description(&amp;self) -&gt; &amp;str { ... }
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>我们可以使用 <a href="https://github.com/dtolnay/thiserror"><code>thiserror</code></a>和 <a href="https://github.com/dtolnay/anyhow"><code>anyhow</code></a> 来简化这个步骤. <code>thiserror</code> 提供了一个派生宏<code>(derive macro)</code>来简化错误类型的定义.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>在 <code>Rust</code> 中, 凡是需要做资源回收的数据结构, 且实现了 <code>Deref</code>/<code>DerefMut</code>/<code>Drop</code>, 都是智能指针.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    type Target: ?Sized;

    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="1-string-和-str"><a class="header" href="#1-string-和-str">1. String 和 &amp;str</a></h2>
<p>智能指针一定是一个胖指针, 但胖指针不一定是一个智能指针, 比如 &amp;str 就只是一个胖指针, 它有指向堆内存字符串的指针, 同时还有关于字符串长度的元数据.</p>
<p>智能指针 <code>String</code> 和 <code>&amp;str</code> 的区别:</p>
<p><img src="rust/../assets/202301151919034.png" alt="image-20230115191903977" /></p>
<p>但 <code>String</code> 对堆上的值有所有权, 而 <code>&amp;str</code> 是没有所有权的, 这是 <code>Rust</code> 中<strong>智能指针</strong>和<strong>普通胖指针</strong>的区别.</p>
<p><code>String</code> 是用结构体定义的.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>和普通的结构体不同的是, <code>String</code> 实现了 <code>Deref</code> 和 <code>DerefMut</code>, 这使得它在解引用的时候, 会得到 <code>&amp;str</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ops::Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}

impl ops::DerefMut for String {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut str {
        unsafe { str::from_utf8_unchecked_mut(&amp;mut *self.vec) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>由于在堆上分配了数据, <code>String</code> 还需要为其分配的资源做相应的回收. 而 <code>String</code> 内部使用了 <code>Vec</code>, 所以它可以依赖 <code>Vec</code> 的能力来释放堆内存.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for Vec&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // use drop for [T]
            // use a raw slice to refer to the elements of the vector as weakest necessary type;
            // could avoid questions of validity in certain cases
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        }
        // RawVec handles deallocation
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="2-boxt"><a class="header" href="#2-boxt">2. <code>Box&lt;T&gt;</code></a></h2>
<p><code>Box&lt;T&gt;</code> 的定义里, 内部就是一个 <code>Unique&lt;T&gt;</code> 用于致敬 C++, <code>Unique&lt;T&gt;</code> 是一个私有的数据结构, 我们不能直接使用, 它包裹了一个 <code>*const T</code> 指针, 并唯一拥有这个指针.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Unique&lt;T: ?Sized&gt; {
    pointer: *const T,
    // NOTE: this marker has no consequences for variance, but is necessary
    // for dropck to understand that we logically own a `T`.
    //
    // For details, see:
    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
    _marker: PhantomData&lt;T&gt;,
}

pub struct Box&lt;T: ?Sized,A: Allocator = Global&gt;(Unique&lt;T&gt;, A)
<span class="boring">}</span></code></pre></pre>
<h2 id="3-cowa-b"><a class="header" href="#3-cowa-b">3. <code>Cow&lt;'a, B&gt;</code></a></h2>
<p><code>Cow</code> 是 <code>Rust</code> 下用于提供写时克隆 (<code>Clone-on-Write</code>) 的一个智能指针, 它跟虚拟内存管理的写时复制 (<code>Copy-on-write</code>) 有异曲同工之妙: **包裹一个只读借用, 但如果调用者需要所有权或者需要修改内容, 那么它会 <code>clone</code> 借用的数据. **</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt; 
	where B: 'a + ToOwned + ?Sized {
  Borrowed(&amp;'a B),  			// 对类型 B 的只读引用
  Owned(&lt;B as ToOwned&gt;::Owned), // 包含对类型 B 的拥有所有权的数据
}
<span class="boring">}</span></code></pre></pre>
<p>这里引入了两个 trait, 首先是<code>ToOwned</code>, 在<code>ToOwner</code> trait 定义的时候, 又引入了 <code>Borrow</code> trait, 它们都是 <a href="https://doc.rust-lang.org/std/borrow/index.html"><code>std::borrow</code></a> 下的 trait.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    #[must_use = "cloning is often expensive and is not expected to have side effects"]
    fn to_owned(&amp;self) -&gt; Self::Owned;

    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}

pub trait Borrow&lt;Borrowed&gt; where Borrowed: ?Sized {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}</span></code></pre></pre>
<p>首先 <code>Owned: Borrow&lt;Self&gt;</code> 是一个带有关联类型的 trait, 这里的 <code>Owned</code> 关联类型, 需要使用者定义, 并且这里的<code>Owned</code> 不能是任意类型, 它必须满足 <code>Borrow&lt;T&gt;</code> trait. 例如 <a href="https://doc.rust-lang.org/src/alloc/str.rs.html#215-227"><strong><code>str</code>对 <code>ToOwner</code> trait 的实现</strong></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String;
    #[inline]
    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        let mut b = mem::take(target).into_bytes();
        self.as_bytes().clone_into(&amp;mut b);
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>可以看到关联类型 <code>Owned</code> 被定义为 <code>String</code>, 而根据要求, <code>String</code> 必须定义 <code>Borrow</code>, 那这里 <code>Borrow</code> 里的泛型变量 <code>T</code> 是谁呢？</p>
<p><code>ToOwned</code> 要求是 <code>Borrow</code>, 而此刻实现 <code>ToOwned</code> 的主体是 <code>str</code>, 所以 <code>Borrow</code> 是 <code>Borrow&lt;str&gt;</code>, 也就是说 <code>String</code> 要实现 <code>Borrow&lt;str&gt;</code>, 我们看文档, 它的确实现了这个 trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Cow</code>说它是智能指针, 那它自然需要实现 <code>Deref</code> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            Borrowed(borrowed) =&gt; borrowed,
            Owned(ref owned) =&gt; owned.borrow(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>这种根据 <code>enum</code> 的不同状态来进行统一分发的方法是第三种分发手段</strong>, 可以使用泛型参数做<strong>静态分发</strong>和使用 trait object 做<strong>动态分发</strong>.</p>
<h2 id="4-mutexguardt"><a class="header" href="#4-mutexguardt">4. <code>MutexGuard&lt;T&gt;</code></a></h2>
<p><code>MutexGuard&lt;T&gt;</code> 是一类很有意思的智能指针: 它不但通过 <code>Deref</code> 提供良好的用户体验, 还通过 <code>Drop</code> trait 来确保, 使用到的内存以外的资源在退出时进行释放.</p>
<p><code>MutexGuard</code>这个结构是在调用 <code>Mutex::lock</code> 时生成的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
    unsafe {
        self.inner.raw_lock();
        MutexGuard::new(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>MutexGuard</code> 的<a href="https://doc.rust-lang.org/src/std/sync/mutex.rs.html#190-195">定义</a>以及它的 <code>Deref</code> 和 <code>Drop</code> 的实现,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// 这里用 must_use, 当你得到了却不使用 MutexGuard 时会报警
#[must_use = "if unused the Mutex will immediately unlock"]
pub struct MutexGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    poison: poison::Guard,
}

impl&lt;T: ?Sized&gt; Deref for MutexGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; DerefMut for MutexGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    #[inline]
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.poison.done(&amp;self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>MuxteGuard</code> 不允许<code>Send</code>, 只允许<code>Sync</code>. 就是说, 你可以把 <code>MutexGuard</code> 的引用传给另一个线程使用, 但你无法把 <code>MutexGuard</code> 整个 move 到另一个线程.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准-trait"><a class="header" href="#标准-trait">标准 trait</a></h1>
<h2 id="1-内存相关-clonecopydrop"><a class="header" href="#1-内存相关-clonecopydrop">1. 内存相关: <code>Clone</code>/<code>Copy</code>/<code>Drop</code></a></h2>
<h3 id="11-clone-trait"><a class="header" href="#11-clone-trait">1.1 Clone trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
  fn clone(&amp;self) -&gt; Self;

  fn clone_from(&amp;mut self, source: &amp;Self) {
    *self = source.clone()
  }
}
<span class="boring">}</span></code></pre></pre>
<p><code>clone_from</code>方法在实例<code>a</code>已经存在, 在<code>clone</code>过程中会分配内存, 那么用<code>a.clone_from(&amp;b)</code>可以避免内存分配, 提高效率.</p>
<p><code>Clone trait</code>可以通过派生宏直接实现<code>#[derive(Clone)]</code>.</p>
<h3 id="12-copy-trait"><a class="header" href="#12-copy-trait">1.2 Copy trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone {}
<span class="boring">}</span></code></pre></pre>
<p>这个<code>trait</code>没有任何行为, 但它可以用作 <code>trait bound</code> 来进行类型安全检查, 所以叫 <strong>标志<code>trait</code></strong></p>
<p><code>Copy trait</code>可以通过派生宏直接实现<code>#[derive(Copy)]</code>.</p>
<h3 id="13-drop-trait"><a class="header" href="#13-drop-trait">1.3 Drop trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>大部分场景无需为数据结构提供 <code>Drop trait</code>,  系统默认会依次对数据结构的每个域做 <code>drop</code>. 但有两种情况你可能需要手工实现 <code>Drop</code>.</p>
<ul>
<li>希望在数据结束生命周期的时候做一些事情,  比如记日志.</li>
<li>需要对资源回收的场景. 编译器并不知道你额外使用了哪些资源,  也就无法帮助你 <code>drop</code> 它们. 比如说锁资源的释放,  在 <code>MutexGuard </code>中实现了 <code>Drop</code> 来释放锁资源</li>
</ul>
<blockquote>
<p><strong>注意</strong>:</p>
<p><code>Copy trait</code> 和 <code>Drop trait</code> 是互斥的,  两者不能共存,  当你尝试为同一种数据类型实现 <code>Copy</code> 时,  同时也实现 <code>Drop</code>,  编译器就会报错. 这其实很好理解：**<code>Copy</code> 是按位做浅拷贝,  那么它会默认拷贝的数据没有需要释放的资源；而 <code>Drop</code> 恰恰是为了释放额外的资源而生的. **</p>
</blockquote>
<h2 id="2-标记-trait-sizedsendsyncunpin"><a class="header" href="#2-标记-trait-sizedsendsyncunpin">2. 标记 trait: <code>Sized</code>/<code>Send</code>/<code>Sync</code>/<code>Unpin</code></a></h2>
<h3 id="21-sized-trait"><a class="header" href="#21-sized-trait">2.1 Sized trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sized { }
<span class="boring">}</span></code></pre></pre>
<p><code>Sized trait</code> 用于标记有具体大小的类型. 在使用泛型参数时,  <code>Rust</code> 编译器会自动为泛型参数加上 <code>Sized</code> 约束.</p>
<p>大部分时候,  我们都希望能自动添加这样的约束,  因为这样定义出的泛型结构,  在编译期,  大小是固定的,  可以作为参数传递给函数.</p>
<p>在少数情况下, 需要 <code>T</code> 是可变类型的 那么需要<code>?Sized</code> 来摆脱这个约束.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这样B就可以是[T]或者str类型,大小都不固定.
// 注意  Borrowed(&amp;'a B) 大小是固定的, 因为它是对B的一个引用, 而且引用的大小是固定的.
pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,
{
    // 借用的数据
    Borrowed(&amp;'a B),
    // 拥有的数据
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="22-sendsync"><a class="header" href="#22-sendsync">2.2 Send/Sync</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe auto trait Send {}
pub unsafe auto trait Sync {}
<span class="boring">}</span></code></pre></pre>
<p>这两个<code> trait</code> 都是 <code>unsafe auto trait</code>,  <code>auto</code> 意味着编译器会在合适的场合,  自动为数据结构添加它们的实现,  而 <code>unsafe</code> 代表实现的这个 <code>trait</code> 可能会违背 <code>Rust</code> 的内存安全准则,  如果开发者手工实现这两个 <code>trait</code> ,  要自己为它们的安全性负责.</p>
<p><code>Send/Sync</code> 是 <code>Rust</code> 并发安全的基础：</p>
<ul>
<li>如果一个类型 <code>T</code> 实现了 <code>Send trait</code>,  意味着 <code>T</code> 可以安全地从一个线程移动到另一个线程,  也就是说所有权可以在线程间移动.</li>
<li>如果一个类型 <code>T</code> 实现了 <code>Sync trait</code>,  则意味着 <code>&amp;T</code> 可以安全地在多个线程中共享. 一个类型 <code>T</code> 满足 <code>Sync trait</code>,  当且仅当 <code>&amp;T</code> 满足 <code>Send trait</code>.</li>
</ul>
<p>对于 <code>Send/Sync</code> 在线程安全中的作用,  可以这么看,  **如果一个类型 <code>T: Send</code>,  那么 <code>T</code> 在某个线程中的独占访问是线程安全的；如果一个类型 <code>T: Sync</code>,  那么 <code>T</code> 在线程间的只读共享是安全的. **</p>
<p>对于我们自己定义的数据结构,  如果其内部的所有域都实现了 <code>Send</code> / <code>Sync</code>,  那么这个数据结构会被自动添加 <code>Send</code> / <code>Sync</code>.</p>
<p>标准库中,  不支持 <code>Send</code> / <code>Sync</code> 的数据结构主要有：</p>
<ul>
<li>裸指针 <code>*const T</code> /<code> *mut T</code>. 它们是不安全的,  所以既不是 <code>Send</code> 也不是 <code>Sync</code>.</li>
<li><code>UnsafeCell</code> 不支持 <code>Sync</code>. 也就是说,  任何使用了 <code>Cell</code> 或者 <code>RefCell</code> 的数据结构不支持 <code>Sync</code>.</li>
<li>引用计数 <code>Rc</code> 不支持 <code>Send</code> 也不支持 <code>Sync</code>. 所以 <code>Rc</code> 无法跨线程.</li>
</ul>
<h3 id="23-unpin"><a class="header" href="#23-unpin">2.3 Unpin</a></h3>
<p>todo.</p>
<h2 id="3-类型转换-fromintoasrefasmut"><a class="header" href="#3-类型转换-fromintoasrefasmut">3. 类型转换: <code>From</code>/<code>Into</code>/<code>AsRef</code>/<code>AsMut</code></a></h2>
<h3 id="31-from--into-和-tryfrom--tryinto"><a class="header" href="#31-from--into-和-tryfrom--tryinto">3.1 From / Into 和 TryFrom / TryInto</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}

pub trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}

// 实现 From 会自动实现 Into
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {
    fn into(self) -&gt; U {
        U::from(self)
    }
}

// From(Into)是自反的
// 把类型 T 的值转换成类型 T,  会直接返回
impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>From&lt;T&gt;</code> 可以根据上下文做类型推导,  使用场景更多；而且实现了 <code>From&lt;T&gt;</code> 会自动实现 <code>Into&lt;T&gt;</code>,  反之不会. 所以需要的时候,  只要实现 <code>From&lt;T&gt;</code> 即可.</p>
<p>而且<code>From&lt;T&gt;</code>(<code>Into&lt;T&gt;</code>)是自反的, 把类型 <code>T</code> 的值转换成类型 <code>T</code>,  会直接返回, 这样在接口设计时变得灵活, 比如函数接受一个<code>IpAddr</code>为参数, 我们可以使用<code>Into&lt;IpAddr&gt;</code>让更多的类型被这个函数使用.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

fn print(v: impl Into&lt;IpAddr&gt;) {
    println!("{:?}", v.into());
}
<span class="boring">}</span></code></pre></pre>
<p>合理地使用<code>From&lt;T&gt;</code> / <code>Into&lt;T&gt;</code>,  可以让代码变得简洁,  符合 <code>Rust</code> 可读性强的风格,  更符合开闭原则.</p>
<p>注意, 如果你的数据类型在转换过程中有可能出现错误, 可以使用 <code>TryFrom&lt;T&gt;</code> 和 <code>TryInto&lt;T&gt;</code>, 用法与<code>From&lt;T&gt;</code>/ <code>Into&lt;T&gt;</code> 一样</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TryFrom&lt;T&gt; {
    type Error;

    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}
pub trait TryInto&lt;T&gt; {
    type Error;

    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="32-asref--asmut"><a class="header" href="#32-asref--asmut">3.2 AsRef / AsMut</a></h3>
<p><code>AsRef&lt;T&gt;</code> 和 <code>AsMut&lt;T&gt;</code> 就很好理解了,  用于从引用到引用的转换.</p>
<p>在<code> trait</code> 的定义上,  都允许 <code>T</code> 使用大小可变的类型,  如 <code>str</code>、<code>[u8]</code> 等. <code>AsMut&lt;t&gt;</code> 除了使用可变引用生成可变引用外,  其它都和 <code>AsRef&lt;T&gt;</code> 一样.</p>
<p>注意, 如果你的代码出现 <code>v.as_ref().clone()</code> 这样的语句,  也就是说你要对 <code>v</code> 进行引用转换,  然后又得到了拥有所有权的值,  那么你应该实现 <code>From&lt;T&gt;</code>,  然后做 <code>v.into()</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T&gt; where T: ?Sized {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="4-deref--derefmut"><a class="header" href="#4-deref--derefmut">4. <code>Deref</code> / <code>DerefMut</code></a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    // 解引用出来的结果类型
    type Target: ?Sized;
    
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><img src="rust/../assets/202211070826785.png" alt="image-20221107082655636" /></p>
<h2 id="5-debug--display--default"><a class="header" href="#5-debug--display--default">5. <code>Debug</code> / <code>Display</code> / <code>Default</code></a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Debug</code> 和 <code>Display</code> 两个 <code>trait</code> 的签名一样,  都接受一个 <code>&amp;self</code> 和一个 <code>&amp;mut Formatter</code>.</p>
<ul>
<li><code>Debug</code> 是为开发者调试打印数据结构所设计的, 可以通过派生宏直接生成.通过<code>{:?}</code>来打印.</li>
<li><code>Display</code> 是给用户显示数据结构所设计的, 必须手工实现.通过<code>{}</code>打印.</li>
</ul>
<p><code>Default trait</code> 用于为类型提供缺省值. 它也可以通过 <code>derive</code> 宏 <code>#[derive(Default)]</code> 来生成实现,  前提是类型中的每个字段都实现了 <code>Default trait</code>.</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><img src="rust/../assets/202211070834776.png" alt="image-20221107083458598" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型系统-泛型"><a class="header" href="#类型系统-泛型">类型系统: 泛型</a></h1>
<h2 id="1-泛型参数的三种使用场景"><a class="header" href="#1-泛型参数的三种使用场景">1. 泛型参数的三种使用场景</a></h2>
<ul>
<li>使用泛型参数延迟数据结构的绑定</li>
<li>使用泛型参数和 <code>PhantomData</code>, 声明数据结构中不直接使用, 但在实现过程中需要用到的类型.</li>
<li>使用泛型参数让同一个数据结构对同一个<code>trait</code>可以有不同的实现</li>
</ul>
<h3 id="11-泛型参数做延迟绑定"><a class="header" href="#11-泛型参数做延迟绑定">1.1 泛型参数做延迟绑定</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Service 数据结构
pub struct Service&lt;Store = MemTable&gt; {
    inner: Arc&lt;ServiceInner&lt;Store&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>它使用了一个泛型参数Store, 并且这个泛型参数有一个缺省值, 在使用时可以不必提供泛型参数, 直接使用缺省值.  这个泛型参数在随后的实现中可以被逐渐约束.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Store&gt; Service&lt;Store&gt; {
    pub fn new(store: Store) -&gt; Self { ... }
}

impl&lt;Store: Storage&gt; Service&lt;Store&gt; {
    pub fn execute(&amp;self, cmd: CommandRequest) -&gt; CommandResponse { ... }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="12-使用泛型参数和幽灵数据-phantomdata-提供额外类型"><a class="header" href="#12-使用泛型参数和幽灵数据-phantomdata-提供额外类型">1.2 使用泛型参数和幽灵数据 (PhantomData) 提供额外类型</a></h3>
<p>设计一个 User 和 Product 数据结构, 它们都有一个 u64 类型的 id. 然而我希望每个数据结构的 id 只能和同种类型的 id 比较.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

#[derive(Debug, Default, PartialEq, Eq)]
pub struct Identifier&lt;T&gt; {
    inner: u64,
    _tag: PhantomData&lt;T&gt;,
}

#[derive(Debug, Default, PartialEq, Eq)]
pub struct User {
    id: Identifier&lt;Self&gt;,
}

#[derive(Debug, Default, PartialEq, Eq)]
pub struct Product {
    id: Identifier&lt;Self&gt;,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn id_should_not_be_the_same() {
        let user = User::default();
        let product = Product::default();

        // 两个 id 不能比较, 因为他们属于不同的类型
        // assert_ne!(user.id, product.id);

        assert_eq!(user.id.inner, product.id.inner);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>让我们可以用 <code>PhantomData</code> 来持有 <strong>Phantom Type</strong>. <code>PhantomData</code> 中文一般翻译成<strong>幽灵数据</strong>, 这名字透着一股让人不敢亲近的邪魅, 但它被**广泛用在处理, 数据结构定义过程中不需要, 但是在实现过程中需要的泛型参数. **</p>
<h3 id="13-使用泛型参数来提供多个实现"><a class="header" href="#13-使用泛型参数来提供多个实现">1.3 使用泛型参数来提供多个实现</a></h3>
<p>用泛型数据结构来统一相同的逻辑, 用泛型参数的具体类型来处理变化的逻辑.</p>
<p>我们写代码的首要目标是正确地实现所需要的功能, 在正确性的前提下, 优雅简洁的表达才有意义.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型系统-trait"><a class="header" href="#类型系统-trait">类型系统: trait</a></h1>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_trait.html">Trait 使用及实现分析</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/rusts-standard-library-traits.html#%E5%AE%8C%E6%95%B4rust-%E6%A0%87%E5%87%86%E5%BA%93-trait-%E6%8C%87%E5%8D%97">Rust 标准库 Trait 指南</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用于处理借用数据的模块-stdborrow"><a class="header" href="#用于处理借用数据的模块-stdborrow">用于处理借用数据的模块: <code>std::borrow</code></a></h1>
<h2 id="1-borrow"><a class="header" href="#1-borrow">1 Borrow</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Borrow&lt;Borrowed&gt;
where
    Borrowed: ?Sized,
{
    // Required method
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}</span></code></pre></pre>
<p>一个用于借用数据的<code>trait</code>.<br />
通过实现<code>Borrow&lt;T&gt;</code>来表达它们可以作为其个类型<code>T</code>借出.并在<code>trait</code>的<code>borrow</code>方法中提供对<code>T</code>的引用.<br />
例如: <code>String</code>实现了<code>Borrow&lt;str&gt;</code>,则可以作为<code>str</code>进行借出, <code>Box&lt;T&gt;</code>实现了<code>Borrow&lt;T&gt;</code>,则可以作为<code>T</code>进行借出</p>
<h2 id="2-borrowmut"><a class="header" href="#2-borrowmut">2. BorrowMut</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait BorrowMut&lt;Borrowed&gt;: Borrow&lt;Borrowed&gt;
where
    Borrowed: ?Sized,
{
    // Required method
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut Borrowed;
}
<span class="boring">}</span></code></pre></pre>
<p>一个用于可变借用数据的<code>trait</code>.<br />
作为<code>Borrow&lt;T&gt;</code>的补充，该<code>trait</code>允许类型通过提供可变引用来借用底层类型.</p>
<h2 id="3-toowned"><a class="header" href="#3-toowned">3. ToOwned</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;

    // Required method
    fn to_owned(&amp;self) -&gt; Self::Owned;

    // Provided method
    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Clone</code>在借用数据上的泛化.
<code>Clone</code>一般是<code>&amp;T</code>到<code>T</code>, <code>ToOwned</code> trait 将<code>Clone</code>泛化, 可以从给定类型的任何借用中构造拥有数据.</p>
<p>这里关联类型<code>Owned</code>需要满足<code>Borrow&lt;Self&gt;</code> trait, 此处<code>Self</code>为要实现<code>ToOwned</code>的结构.
看下 <a href="https://doc.rust-lang.org/src/alloc/str.rs.html#203-217">str对ToOwned trait 的实现</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String

    // Required method
    fn to_owned(&amp;self) -&gt; Self::Owned { ... }

    // Provided method
    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>关联类型<code>Owned</code>被定义为<code>String</code>, 而根据要求，<code>String</code>必须定义<code>Borrow&lt;T&gt;</code>，那这里<code>Borrow</code>里的泛型变量<code>T</code>是谁呢?<br />
<code>ToOwned</code>要求是<code>Borrow&lt;Self&gt;</code>，而此刻实现 <code>ToOwned</code> 的主体是 <code>str</code>，所以 <code>Borrow&lt;Self&gt;</code> 是 <code>Borrow&lt;str&gt;</code>, 而<code>String</code>的确实现了<code>Borrow&lt;str&gt;</code>.</p>
<h2 id="4-cow"><a class="header" href="#4-cow">4. Cow</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt;
where
    B: 'a + ToOwned + ?Sized,
{
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}</span></code></pre></pre>
<p><code>Cow</code>用于提供写时克隆（Clone-on-Write）的一个智能指针,<strong>包裹一个只读借用，但如果调用者需要所有权或者需要修改内容，那么它会 clone 借用的数据.</strong></p>
<p><code>Cow</code>实现了<a href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#332-341">Deref trait</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            Borrowed(borrowed) =&gt; borrowed,
            Owned(ref owned) =&gt; owned.borrow(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何阅读源码"><a class="header" href="#如何阅读源码">如何阅读源码</a></h1>
<blockquote>
<p>以下是 Rust 文档为例</p>
</blockquote>
<p>读<code>Rust</code>代码的基本顺序:</p>
<ul>
<li>从 <code>crate</code> 的大纲开始, 先了解目标代码能干什么,怎么用.</li>
<li>学习核心 <code>trait</code>, 看看它支持哪些功能.</li>
<li>掌握主要的数据结构, 开始写一些示例代码</li>
<li>围绕自己感兴趣的情景深入阅读.</li>
</ul>
<h2 id="1-从大纲开始"><a class="header" href="#1-从大纲开始">1. 从大纲开始</a></h2>
<p><code>Rust</code> 几乎所有库的文档都在 <a href="https://docs.rs/"><code>docs.rs</code></a> 下, 比如 <code>Bytes</code> 的文档可以通过 <a href="https://docs.rs/bytes/latest/bytes/">docs.rs/bytes</a> 访问</p>
<ul>
<li>trait</li>
<li>struct</li>
<li>函数/方法</li>
</ul>
<p>和写代码的思考方式非常类似:</p>
<ul>
<li>先从需求的流程中敲定系统的行为, 需要定义什么接口 trait；</li>
<li>再考虑系统有什么状态, 定义了哪些数据结构 struct；</li>
<li>最后到实现细节, 包括如何为数据结构实现 trait、数据结构自身有什么算法、如何把整个流程串起来等等.</li>
</ul>
<h2 id="2-熟悉核心-trait-的行为"><a class="header" href="#2-熟悉核心-trait-的行为">2. 熟悉核心 trait 的行为</a></h2>
<p>所以先看 <code>trait</code>, 我们以 <code>Buf trait</code> 为例. 点进去看文档, 主页面给了这个 <code>trait</code> 的定义和一个使用示例.</p>
<p>左侧导航栏的 <strong>“required Methods”</strong> 和 <strong>“Provided Methods”</strong>, 前者是实现这个 <code>trait</code> 需要实现的方法, 后者是缺省方法.</p>
<p>导航栏继续往下拉, 可以看到 <code>bytes</code> 为哪些 <strong>“foreign types”</strong> 实现了 <code>Buf trait</code>, 以及当前模块有哪些 <code>implementors</code>.</p>
<p>可以学习到高手定义 trait 的一些思路：</p>
<ul>
<li>定义好 <code>trait</code> 后, 可以考虑一下标准库的数据结构, 哪些可以实现这个 trait.</li>
<li>如果未来别人的某个类型 <code>T</code> , 实现了你的 <code>trait</code>, 那他的 <code>&amp;T</code>、<code>&amp;mut T</code>、<code>Box</code> 等衍生类型, 是否能够自动实现这个 trait.</li>
</ul>
<h2 id="3-掌握主要的-struct"><a class="header" href="#3-掌握主要的-struct">3. 掌握主要的 struct</a></h2>
<p>和 <code>trait</code> 类似的, 在左侧的导航栏, 有一些值得关注的信息：这个数据结构有哪些方法 (<strong>Methods</strong>) 、实现了哪些 <strong>trait</strong> (Trait implementations) , 以及 <strong>Auto trait</strong> / <strong>Blanket trait</strong> 的实现. 可以看到, <code>Bytes</code> 除了实现了刚才讲过的 <code>Buf trait</code> 外, 还实现了很多标准 <code>trait</code>.</p>
<p>所以: <strong>我们自己的数据结构, 也应该尽可能实现需要的标准 trait</strong>, 包括但不限于：<code>AsRef</code>、<code>Borrow</code>、<code>Clone</code>、<code>Debug</code>、<code>Default</code>、<code>Deref</code>、<code>Drop</code>、<code>PartialEq</code>/<code>Eq</code>、<code>From</code>、<code>Hash</code>、<code>IntoIterator</code> (如果是个集合类型) 、<code>PartialOrd</code>/<code>Ord</code> 等</p>
<h2 id="4-深入研究实现逻辑"><a class="header" href="#4-深入研究实现逻辑">4. 深入研究实现逻辑</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actix-web"><a class="header" href="#actix-web">actix-web</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler-原理"><a class="header" href="#handler-原理">handler 原理</a></h1>
<h2 id="11-剖析"><a class="header" href="#11-剖析">1.1 剖析</a></h2>
<p>在 <code>actix-web</code> 中，路由设置 <a href="https://docs.rs/actix-web/latest/actix_web/struct.Route.html#method.to">handler</a> 的方法 定义如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn to&lt;F, Args&gt;(self, handler: F) -&gt; Self
where
    F: Handler&lt;Args&gt;,
    Args: FromRequest + 'static,
    F::Output: Responder + 'static,
{
    self.service = handler_service(handler);
    self
}
<span class="boring">}</span></code></pre></pre>
<p>参数<code>handler</code>的约束为<code>Handler&lt;Args&gt;</code>, 其定义如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Handler&lt;Args&gt;: Clone + 'static {
    type Output;
    type Future: Future&lt;Output = Self::Output&gt;;

    fn call(&amp;self, args: Args) -&gt; Self::Future;
}
<span class="boring">}</span></code></pre></pre>
<p>这里的<code>Args</code>就代表n个参数.</p>
<p>结合这两个来看, <code>to</code>函数中<code>Handler&lt;Args&gt;</code>的<code>Args</code>需要实现<code>FromRequest</code> trait 就可以作为参数, 而<code>Handler&lt;Args&gt;</code>的关联类型<code>Output</code>需要实现<code>Responder</code> trait.</p>
<p>但是<code>Args</code>是如何实现动态参数的呢, 来看下<code>to</code>函数的<code>handler_service</code>方法:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(crate) fn handler_service&lt;F, Args&gt;(handler: F) -&gt; BoxedHttpServiceFactory
where
    F: Handler&lt;Args&gt;,
    Args: FromRequest,
    F::Output: Responder,
{
    boxed::factory(fn_service(move |req: ServiceRequest| {
        let handler = handler.clone();

        async move {
            let (req, mut payload) = req.into_parts();

            let res = match Args::from_request(&amp;req, &amp;mut payload).await {
                Err(err) =&gt; HttpResponse::from_error(err),

                Ok(data) =&gt; handler
                    .call(data)
                    .await
                    .respond_to(&amp;req)
                    .map_into_boxed_body(),
            };

            Ok(ServiceResponse::new(req, res))
        }
    }))
}
<span class="boring">}</span></code></pre></pre>
<p>这里的<code>handler</code>的约束和上而的<code>to</code>区别不大,看下里面的实现,同上面所说<code>Args</code>只需要实现<code>FromRequest</code>就可以拿来做参数, 换句话说, 实现了 <code>FromRequest</code> 你可以在 <code>Handle</code> 方法中的任意参数位置写上你要的参数名和类型.
通过<code>Args::FromRequest</code>提取出参数,就调用<code>handler.call</code>方法执行你的接口, 如何失败则返回<code>FromRequest</code>中定义的Error, 所以你可以随意定义参数提取失败之后返回的内容.
但是问题来了, <code>Args</code>如何实现支持多个参数, 在源码里找到以下定义:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! tuple_from_req {
        ($fut: ident; $($T: ident),*) =&gt; {
            /// FromRequest implementation for tuple
            #[allow(unused_parens)]
            impl&lt;$($T: FromRequest + 'static),+&gt; FromRequest for ($($T,)+)
            {
                type Error = Error;
                type Future = $fut&lt;$($T),+&gt;;

                fn from_request(req: &amp;HttpRequest, payload: &amp;mut Payload) -&gt; Self::Future {
                    $fut {
                        $(
                            $T: ExtractFuture::Future {
                                fut: $T::from_request(req, payload)
                            },
                        )+
                    }
                }
            }

            pin_project! {
                pub struct $fut&lt;$($T: FromRequest),+&gt; {
                    $(
                        #[pin]
                        $T: ExtractFuture&lt;$T::Future, $T&gt;,
                    )+
                }
            }

            impl&lt;$($T: FromRequest),+&gt; Future for $fut&lt;$($T),+&gt;
            {
                type Output = Result&lt;($($T,)+), Error&gt;;

                fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
                    let mut this = self.project();

                    let mut ready = true;
                    $(
                        match this.$T.as_mut().project() {
                            ExtractProj::Future { fut } =&gt; match fut.poll(cx) {
                                Poll::Ready(Ok(output)) =&gt; {
                                    let _ = this.$T.as_mut().project_replace(ExtractFuture::Done { output });
                                },
                                Poll::Ready(Err(e)) =&gt; return Poll::Ready(Err(e.into())),
                                Poll::Pending =&gt; ready = false,
                            },
                            ExtractProj::Done { .. } =&gt; {},
                            ExtractProj::Empty =&gt; unreachable!("FromRequest polled after finished"),
                        }
                    )+

                    if ready {
                        Poll::Ready(Ok(
                            ($(
                                match this.$T.project_replace(ExtractFuture::Empty) {
                                    ExtractReplaceProj::Done { output } =&gt; output,
                                    _ =&gt; unreachable!("FromRequest polled after finished"),
                                },
                            )+)
                        ))
                    } else {
                        Poll::Pending
                    }
                }
            }
        };
    }


    impl FromRequest for () {
        type Error = Infallible;
        type Future = Ready&lt;Result&lt;Self, Self::Error&gt;&gt;;

        fn from_request(_: &amp;HttpRequest, _: &amp;mut Payload) -&gt; Self::Future {
            ok(())
        }
    }

    tuple_from_req! { TupleFromRequest1; A }
    tuple_from_req! { TupleFromRequest2; A, B }
    tuple_from_req! { TupleFromRequest3; A, B, C }
    tuple_from_req! { TupleFromRequest4; A, B, C, D }
    tuple_from_req! { TupleFromRequest5; A, B, C, D, E }
    tuple_from_req! { TupleFromRequest6; A, B, C, D, E, F }
    tuple_from_req! { TupleFromRequest7; A, B, C, D, E, F, G }
    tuple_from_req! { TupleFromRequest8; A, B, C, D, E, F, G, H }
    tuple_from_req! { TupleFromRequest9; A, B, C, D, E, F, G, H, I }
    tuple_from_req! { TupleFromRequest10; A, B, C, D, E, F, G, H, I, J }
    tuple_from_req! { TupleFromRequest11; A, B, C, D, E, F, G, H, I, J, K }
    tuple_from_req! { TupleFromRequest12; A, B, C, D, E, F, G, H, I, J, K, L }

<span class="boring">}</span></code></pre></pre>
<p>这里把<code>Args</code>的一堆 <code>tuple</code>, <code>()</code>,<code>A</code>,<code>A, B</code>...都实现了,所以在 <code>handler_service</code> 里的 <code>Args</code> 实际上是一个 <code>tuple</code>,并在里面逐个调用参数的<code>from_request</code>, 接口的参数限制最多12个, 当超过12个参数时就会报错. 这就回答了上面<code>Args</code>支持多个参数.</p>
<p>这里又出新了一个新的问题, 参数解析出来了, 但是 <code>handler.call(data)</code>如何支持多个参数, 看实现, <a href="https://docs.rs/actix-web/latest/src/actix_web/handler.rs.html#116"><code>Handler&lt;Args&gt;</code></a> 给<code>fn</code>各种长度参数<code>fn() -&gt; R</code>, <code>fn(A, B, C) -&gt; R</code> 实现了最多12个参数.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Generates a [`Handler`] trait impl for N-ary functions where N is specified with a sequence of
/// space separated type parameters.
///
/// # Examples
/// ```ignore
/// factory_tuple! {}         // implements Handler for types: fn() -&gt; R
/// factory_tuple! { A B C }  // implements Handler for types: fn(A, B, C) -&gt; R
/// ```
macro_rules! factory_tuple ({ $($param:ident)* } =&gt; {
    impl&lt;Func, Fut, $($param,)*&gt; Handler&lt;($($param,)*)&gt; for Func
    where
        Func: Fn($($param),*) -&gt; Fut + Clone + 'static,
        Fut: Future,
    {
        type Output = Fut::Output;
        type Future = Fut;

        #[inline]
        #[allow(non_snake_case)]
        fn call(&amp;self, ($($param,)*): ($($param,)*)) -&gt; Self::Future {
            (self)($($param,)*)
        }
    }
});

factory_tuple! {}
factory_tuple! { A }
factory_tuple! { A B }
factory_tuple! { A B C }
factory_tuple! { A B C D }
factory_tuple! { A B C D E }
factory_tuple! { A B C D E F }
factory_tuple! { A B C D E F G }
factory_tuple! { A B C D E F G H }
factory_tuple! { A B C D E F G H I }
factory_tuple! { A B C D E F G H I J }
factory_tuple! { A B C D E F G H I J K }
factory_tuple! { A B C D E F G H I J K L }
<span class="boring">}</span></code></pre></pre>
<h2 id="12-总结"><a class="header" href="#12-总结">1.2 总结</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust日记"><a class="header" href="#rust日记">rust日记</a></h1>
<ul>
<li>必读概念
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/rusts-standard-library-traits.html">Rust标准库<code>Trait</code>指南</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/coercion_in_rust.html">Rust中的隐式类型转换</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="你应知道的crate"><a class="header" href="#你应知道的crate">你应知道的crate</a></h1>
<h2 id="基础库"><a class="header" href="#基础库">基础库</a></h2>
<ul>
<li><a href="https://github.com/danaugrs/overload">overload</a> Simplified operator overloading in Rust</li>
<li><a href="https://github.com/stephaneyfx/enum-iterator">enum-iterator</a> Tools to iterate over all values of a type</li>
<li><a href="https://github.com/rust-lang/cfg-if">cfg-if</a> A if/elif-like macro for Rust #[cfg] statements</li>
<li><a href="https://github.com/droundy/arrayref">arrayref</a> Two macros for taking array references in rust.</li>
<li><a href="https://github.com/magiclen/educe">Educe</a> This crate provides procedural macros to help you implement Rust-built-in traits quickly.</li>
<li><a href="https://github.com/mcarton/rust-derivative">rust-derivative</a> A set of alternative <code>derive</code> attributes for Rust</li>
<li><a href="https://github.com/myrrlyn/tap">tap</a> Generic extensions for tapping values in Rust.</li>
<li><a href="https://github.com/Peternator7/strum">strum</a> A small rust library for adding custom derives to enums.</li>
<li><a href="https://github.com/JelteF/derive_more">derive_more</a> Some more derive(Trait) options.</li>
<li><a href="https://github.com/colin-kiegel/rust-derive-builder">rust-derive-builder</a>derive builder implementation for rust structs.</li>
<li><a href="https://gitlab.com/antonok/enum_dispatch">enum_dispatch</a> Near drop-in replacement for dynamic-dispatched method calls with up to 10x the speed.</li>
<li><a href="https://github.com/dtolnay/paste">paste</a> Macros for all your token pasting needs.</li>
<li><a href="https://github.com/rust-num/num">num</a> A collection of numeric types and traits for Rust.</li>
<li><a href="https://github.com/bluss/either">either</a> The enum Either with variants Left and Right is a general purpose sum type with two cases.</li>
<li><a href="https://github.com/dtolnay/thiserror">thiserror</a> derive(Error) for struct and enum error types.</li>
<li><a href="https://github.com/rayon-rs/rayon">rayon</a> A data parallelism library for Rust.</li>
<li><a href="https://github.com/crossbeam-rs/crossbeam">Crossbeam</a> About Tools for concurrent programming in Rust.</li>
<li><a href="https://github.com/dtolnay/async-trait">async_trait</a> Type erasure for async trait methods.</li>
<li><a href="https://github.com/andrewhickman/fs-err">fs-err</a> A simple wrapper around filesystem operations to provide more helpful error messages.</li>
<li><a href="https://github.com/Stebalien/tempfile">tempfile</a> Temporary file library for rust.</li>
<li><a href="https://github.com/bincode-org/bincode">bincode</a> A binary encoder / decoder implementation in Rust.</li>
<li><a href="https://github.com/bluss/maplit">maplit</a> Rust container / collection literal macros for HashMap, HashSet, BTreeMap, BTreeSet.</li>
<li><a href="https://github.com/bluss/indexmap">indexmap</a> A hash table with consistent order and fast iteration; access items by key or sequence index.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不可变数据建议rctarct替代vect"><a class="header" href="#不可变数据建议rctarct替代vect">不可变数据建议<code>Rc&lt;[T]&gt;</code>/<code>Arc&lt;[T]&gt;</code>替代<code>Vec&lt;[T]&gt;</code></a></h1>
<p>slice 对于不可变数据, <code>Arc&lt;[T]&gt;</code>可能是比 <code>Vec&lt;T&gt;</code> 更好的选择, 因此, 如果你在构建一个大数据序列, 并且
之后不会修改, 那么考虑 Rc&lt;[T]&gt;, 它非常适合存储的数据或数组或集合或只是传递一般引用.</p>
<p>看下内存模型就明白了:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stack    
            [ptr |meta]
            +–––-+–––+
            │ *  │   │ 
            +–│-–+--–│
              |
heap          |
            +–V–+–––+–––+
            │   │   │ T │
            +–––+--–+–––+
              /   │
 ref count &lt;–/    V 
            weak ref count
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="译rust临时生命周期和super-let1"><a class="header" href="#译rust临时生命周期和super-let1">(译)<code>Rust</code>临时生命周期和"Super Let"<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></a></h1>
<p>在<code>Rust</code>中, 临时变量生命周期是一个复杂但又经常被忽视的话题. 在一些简单的情况下, <code>Rust</code>会让临时变量存活足够长的时间, 这样我们就不必考虑它们了. 然而, 在很多情况下, 我们可能无法立即得到我们想要的东西.</p>
<p>在这篇文章中, 我们将(重新)发掘临时变量生命周期的规则, 介绍一些临时生命周期扩展的用例, 并探索一种新的语言理念--<code>super let,</code>, 为我们提供更多控制.</p>
<h2 id="临时变量"><a class="header" href="#临时变量">临时变量</a></h2>
<p>下面是一条<code>Rust</code>语句, 没有上下文, 使用的是临时<code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>f(&amp;String::from('🦀'));
<span class="boring">}</span></code></pre></pre>
<p>这个临时<code>String</code>的存活时间多长?如果我们今天设计<code>Rust</code>, 基本上有两种选择:</p>
<ol>
<li>在调用 <code>f</code> 之前, 字符串会被立即丢弃. 或者</li>
<li>只有在调用 <code>f</code> 后, 字符串才会被丢弃.</li>
</ol>
<p>如果我们选择方案<strong>1</strong>, 那么上面的语句将始终导致借用检查错误, 因为我们不能让<code>f</code>借用已经消失的东西.
因此, <code>Rust</code>选择了方案<strong>2</strong>: 首先分配字符串, 然后将其引用传递给<code>f</code>, 只有在<code>f</code>返回后, 我们才会丢弃临时字符串.</p>
<h3 id="在一个-let-语句中"><a class="header" href="#在一个-let-语句中">在一个 <code>let</code> 语句中</a></h3>
<p>现在是一个稍难的问题:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = f(&amp;String::from('🦀'));
…
g(&amp;a);
<span class="boring">}</span></code></pre></pre>
<p>再来: 这个临时<code>String</code>的存活时间多长?</p>
<ol>
<li>字符串会在 <code>let</code> 语句结束时丢弃: 即在<code>f</code>返回之后, 但在<code>g</code>被调用之前. 或者</li>
<li>字符串会在调用<code>g</code>之后的同时<code>a</code>被丢弃.</li>
</ol>
<p>如果<code>f</code>被定义为 <code>fn f(s: &amp;str) -&gt; usize</code>(如<code>str::len</code>), 那么在<code>let</code>语句后立即去掉<code>String</code>就完全没问题了.</p>
<p>但是, 如果<code>f</code>被定义为 <code>fn f(s: &amp;str) -&gt; &amp;[u8]</code>(就像 <code>str::as_bytes</code>), 那么 <code>a</code> 就会从临时变量 <code>String</code> 中借用, 因此如果我们将<code>a</code>保留较长时间, 就会出现借用检查错误.</p>
<p>如果采用方案<strong>2</strong>, 在这两种情况下都能正常编译, 但我们可能会在超出必要的存活时间内保留一个临时变量, 这可能会浪费资源或导致微妙的错误(例如, 当<code>MutexGuard</code>比预期时间晚丢弃时会造成死锁).</p>
<p>这听起来像是第<strong>3</strong>种选择: 让它取决于<code>f</code>的签名.</p>
<p>但是, <code>Rust</code>的借用检查器只执行检查, 并不影响代码的行为. 出于各种原因, 这是一个非常重要和有用的属性. 举例来说, 将 <code>fn f(s:&amp;str)-&gt;&amp;[u8]</code>(返回值借用参数)改为 <code>fn f(s:&amp;str)-&gt;&amp;'static[u8]</code>(返回值不借用参数)并不会改变调用位置的任何内容, 例如临时变量被丢弃的位置.</p>
<p>因此, 在方案<strong>1</strong>和方案<strong>2</strong>之间, <code>Rust</code>选择了方案<strong>1</strong>: 在<code>let</code>语句末尾删除临时变量. 很容易手动将<code>String</code>移到单独的<code>let</code>语句中, 让它保持更长的时间.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from('🦀'); // Moved to its own `let` to give it a longer lifetime.
let a = f(&amp;s);
…
g(&amp;a);
<span class="boring">}</span></code></pre></pre>
<h3 id="在嵌套调用中"><a class="header" href="#在嵌套调用中">在嵌套调用中</a></h3>
<p>好吧, 再来一个:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>g(f(&amp;String::from('🦀')));
<span class="boring">}</span></code></pre></pre>
<p>同样, 有两种选择:</p>
<ol>
<li>在调用<code>f</code>之后、调用<code>g</code>之前, 字符串被丢弃. 或者</li>
<li>字符串会在语句结束时丢弃, 所以是在调用<code>g</code>之后.</li>
</ol>
<p>该代码段与前一个代码段几乎完全相同: 临时<code>String</code>的引用被传递给<code>f</code>, <code>f</code>的返回值被传递给<code>g</code>.</p>
<p>不过, 方案<strong>1</strong>可能有效, 也可能无效, 这取决于<code>f</code>的签名, 而方案<strong>2</strong>可能会让临时变量存活更长的时间.</p>
<p>不过, 这次方案<strong>1</strong>会给程序员带来更多惊喜. 例如, 即使是简单的 <code>String::from('🦀').as_bytes().contains(&amp;0x80)</code> 也无法编译, 因为字符串会在 <code>as_bytes(f)</code> 之后、<code>contains (g)</code> 之前被删除.</p>
<p>也可以说, 把临时变量多存活一段时间的坏处要小得多, 因为他们在声明结束时仍然会被丢弃.</p>
<p>因此, Rust选择了方案<strong>2</strong>: 无论<code>f</code>的签名如何, 字符串都会一直存在, 直到语句结束, 直到<code>g</code>被调用.</p>
<h3 id="在一个-if-语句中"><a class="header" href="#在一个-if-语句中">在一个 <code>if</code> 语句中</a></h3>
<p>现在, 我们来看看简单的 <code>if</code> 语句:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if f(&amp;String::from('🦀')) {
    …
}
<span class="boring">}</span></code></pre></pre>
<p>同样的问题: <code>String</code> 何时丢弃?</p>
<ol>
<li>在 <code>if</code> 的条件求值之后, 但在 <code>if</code> 的主体执行之前(即在<code>{</code>处). 或者</li>
<li>在 <code>if</code> 主体执行之后(即在<code>}</code>处).</li>
</ol>
<p>在这种情况下, 就没有理由在<code>if</code>主体中保留临时值. 条件的结果是一个布尔值(只有<code>true</code>或<code>false</code>), 顾名思义, 这并不借用任何东西.</p>
<p>因此, <code>Rust</code>选择方案<strong>1</strong>.</p>
<p>例如, 在使用 <code>Mutex::lock</code> 时, 它就会返回一个临时<code>MutexGuard</code>, 当<code>Mutex</code>被丢弃时, 它就会解锁:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(m: &amp;Mutex&lt;String&gt;) {
    if m.lock().unwrap().is_empty() {
        println!("the string is empty!");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在这里, <code>m.lock().unwrap()</code>中的临时<code>MutexGuard</code>会在<code>.is_empty()</code>之后丢弃, 这样<code>Mutex</code>就不会在<code>println</code>语句中被不必要地锁定.</p>
<h3 id="在-if-let-语句中"><a class="header" href="#在-if-let-语句中">在 <code>if let</code> 语句中</a></h3>
<p>但 <code>if let</code>(和 <code>match</code>)的情况有所不同, 因为此时我们的表达式并不一定是评估布尔值:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let … = f(&amp;String::from('🦀')) {
    …
}
<span class="boring">}</span></code></pre></pre>
<p>再次, 有两种选择:</p>
<ol>
<li>在模式匹配之后、<code>if let</code> 的正文之前(即 <code>{</code> 处)删除字符串. 或者、</li>
<li>在 <code>if let</code> 主体之后(即 <code>}</code> 处)删除字符串.</li>
</ol>
<p>这一次, 我们有理由选择方案<strong>2</strong>而不是方案<strong>1</strong>, 在<code>if let</code>语句或<code>match</code>中借用模式是很常见的.</p>
<p>因此, 在这种情况下, Rust选择了方案<strong>2</strong>.</p>
<p>例如, 如果我们有一个<code>Mutex&lt;Vec&lt;T&gt;&gt;</code>类型的<code>vec</code>, 编译起来就很好:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(x) = vec.lock().unwrap().first() {
    // The mutex is still locked here. :)
    // This is necessary, because we're borrowing `x` from the `Vec`. (`x` is a `&amp;T`)
    println!("first item in vec: {x}");
}
<span class="boring">}</span></code></pre></pre>
<p>我们从<code>m.lock().unwrap()</code>获得一个临时的<code>MutexGuard</code>, 并使用<code>.first()</code>方法借用第一个元素. 由于<code>MutexGuard</code>只在最后一个 <code>}</code>才被丢弃, 因此借用将持续整个<code>if let</code>主体.</p>
<p>不过, 在有些情况下, 这并不是我们想要的. 例如, 如果我们使用<code>pop</code>代替<code>first</code>, 它返回的是值而不是引用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(x) = vec.lock().unwrap().pop() {
    // The mutex is still locked here. :(
    // This is unnecessary, because we don't borrow anything from the `Vec`. (`x` is a `T`)
    println!("popped item from the vec: {x}");
}
<span class="boring">}</span></code></pre></pre>
<p>这可能会<a href="https://marabos.nl/atomics/basics.html#lifetime-of-mutexguard">令人惊讶</a>, 并导致微妙的错误或性能降低.</p>
<p>也许这就是<code>Rust</code>选择错误方案的一个论据, 也许这就是在未来版本的<code>Rust</code>中改变这一规则的一个论据. 关于如何修改这些规则的想法, 请参阅 <a href="https://smallcultfollowing.com/babysteps/blog/2023/03/15/temporary-lifetimes/">Niko’s blog post on this topic</a>.</p>
<p>目前, 解决方法是使用一个单独的<code>let</code> 语句, 将临时生命周期限制在该语句中:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = vec.lock().unwrap().pop(); // The MutexGuard is dropped after this statement.
if let Some(x) = x {
    …
}
<span class="boring">}</span></code></pre></pre>
<h2 id="临时生命周期扩展"><a class="header" href="#临时生命周期扩展">临时生命周期扩展</a></h2>
<p>这种情况如何?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = &amp;String::from('🦀');
…
f(&amp;a);
<span class="boring">}</span></code></pre></pre>
<p>两种选择:</p>
<ol>
<li>字符串会在 <code>let</code> 语句的末尾被丢弃. 或者</li>
<li>在调用 <code>f</code> 后, 字符串与 <code>a</code> 同时被删除.</li>
</ol>
<p>方案<strong>1</strong> 总是会导致借用检查错误. 因此, 方案<strong>2</strong>可能更有意义. 如今<code>Rust</code>也确实是这样工作的: 临时生命周期被扩展了, 因此上面的代码段可以正常编译.</p>
<p>这种临时变量生命周期长于它在声明中出现的时间的现象被称为<strong>临时生命周期扩展</strong>.</p>
<p>临时生命周期扩展并不适用于<em><strong>所有</strong></em>出现在<code>let</code>语句中的临时字符串, 正如我们已经看到的那样: <code>let a = f(&amp;String::from('🦀'))</code>; 中的临时字符串不会超过 <code>let</code>语句的生命周期.</p>
<p>在<code>let a = &amp;f(&amp;String::from('🦀'))</code>;(注意多出的 <code>&amp;</code>)中, 临时生命周期扩展确实适用于最外层的<code>&amp;</code>, 它借用了作为<code>f</code> 返回值的临时, 但不适用于内层的<code>&amp;</code>, 它借用了<code>String</code>.</p>
<p>例如, 用<code>str::len</code> 代替<code>f</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: &amp;usize = &amp;String::from('a').len();
<span class="boring">}</span></code></pre></pre>
<p>在这里, 字符串在 <code>let</code> 语句的末尾被删除, 但 <code>.len()</code>返回的<code>usize</code>和<code>a</code>活的一样长.</p>
<p>这不仅限于 <code>let _ = &amp;...;</code> 语法. 例如</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Person {
    name: &amp;String::from('🦀'), // Extended!
    address: &amp;String::from('🦀'), // Extended!
};
<span class="boring">}</span></code></pre></pre>
<p>在上面的代码段中, 临时字符串的生命周期将被扩展, 因为即使我们对 <code>Person</code> 类型一无所知, 我们也可以肯定, 生命周期扩展对于生成对象之后的可用性是必要的.</p>
<p>关于 <code>let</code> 语句中哪些临时变量的生命周期会被延长, <a href="https://doc.rust-lang.org/stable/reference/destructors.html#temporary-lifetime-extension"><code>temporary lifetime extension in Rust Reference</code></a>中有详细的说明, 但实际上只适用于那些从语法上就能看出有必要延长生命周期的表达式, 而与任何类型、函数签名或特质实现无关:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = &amp;temporary().field; // Extended!
let a = MyStruct { field: &amp;temporary() }; // Extended!
let a = &amp;MyStruct { field: &amp;temporary() }; // Both extended!
let a = [&amp;temporary()]; // Extended!
let a = { …; &amp;temporary() }; // Extended!

let a = f(&amp;temporary()); // Not extended, because it might not be necessary.
let a = temporary().f(); // Not extended, because it might not be necessary.
let a = temporary() + temporary(); // Not extended, because it might not be necessary.
<span class="boring">}</span></code></pre></pre>
<p>虽然这看起来很合理, 但当我们考虑到构造元组结构或元组变体的语法只是一个函数调用时, 确实会感到意外: 从语法上讲, <code>Some(123)</code> 是对函数 <code>Some</code> 的函数调用.</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Some(&amp;temporary()); // Not extended! (Because `Some` could have any signature...)
let a = Some { 0: &amp;temporary() }; // Extended! (I bet you have never used this syntax.)
<span class="boring">}</span></code></pre></pre>
<p>这可能会让人相当困惑.</p>
<p>这也是值得考虑<a href="https://smallcultfollowing.com/babysteps/blog/2023/03/15/temporary-lifetimes/#design-principles">重新修订规则</a>的原因之一.</p>
<h3 id="持续推广"><a class="header" href="#持续推广">持续推广</a></h3>
<p>临时生命周期扩展很容易与另一种叫不断晋升的东西混淆, 后者是临时变量获得比预期生命周期长的另一种方式.</p>
<p>在<code>&amp;123</code>和<code>&amp;None</code>这样的表达式中, 值被认定为常量（<a href="https://doc.rust-lang.org/stable/reference/destructors.html#constant-promotion">without interior mutability and without desctructors</a>）, 因此会自动晋升为永生值. 这意味着这些引用将具有<code>'static</code>生命周期.</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = f(&amp;3); // The &amp;3 here is 'static, regardless if that's necessary for `f()`.
<span class="boring">}</span></code></pre></pre>
<p>This even applies to simple expressions:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = f(&amp;(1 + 2)); // The &amp;3 here is 'static.
<span class="boring">}</span></code></pre></pre>
<p>在同时适用临时生命周期延长和恒定提升的情况下, 后者优先, 因为它延长的生命周期最长:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;1; // constant promotion, not temporary lifetime extension.
<span class="boring">}</span></code></pre></pre>
<p>也就是说, 在上面的代码段中, <code>x</code>是一个<code>'static</code>引用. 值<code>1</code>的寿命甚至比<code>x</code>本身还长.</p>
<h3 id="代码块中的临时生命周期扩展"><a class="header" href="#代码块中的临时生命周期扩展">代码块中的临时生命周期扩展</a></h3>
<p>想象一下, 我们有某种<code>Writer</code>类型, 它持有一个要写入的文件的引用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Writer&lt;'a&gt; {
    pub file: &amp;'a File
}
<span class="boring">}</span></code></pre></pre>
<p>以下代码创建了<code>Writer</code>, 写入新创建的文件:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("opening file...");
let filename = "hello.txt";
let file = File::create(filename).unwrap();
let writer = Writer { file: &amp;file };
<span class="boring">}</span></code></pre></pre>
<p>现在的作用域包含<code>filename</code>、<code>file</code>和<code>writer</code>. 然而, 后面的代码只能通过
<code>Writer</code>写入. 理想的情况是, 在作用域中已经看不到<code>filename</code>, 尤其是<code>file</code>.</p>
<p>由于临时生命周期扩展也适用于代码块的最终表达式, 因此我们可以通过以下方式来实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let writer = {
    println!("opening file...");
    let filename = "hello.txt";
    Writer { file: &amp;File::create(filename).unwrap() }
};
<span class="boring">}</span></code></pre></pre>
<p>现在, <code>Writer</code>的创建被整齐地封装在它自己的作用域中, 这样外层作用域只能看到 <code>writer</code>, 而看不到其他任何东西.得益于临时生命周期的扩展, 在内作用域中作为临时创建的<code>file</code>与 <code>writer</code> 一样的存活时间.</p>
<h3 id="临时生命周期扩展的限制"><a class="header" href="#临时生命周期扩展的限制">临时生命周期扩展的限制</a></h3>
<p>试想一下, 如果我们将<code>Writer</code>结构中的<code>file</code>字段设置为私有, 会是怎样的结果？</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Writer&lt;'a&gt; {
    file: &amp;'a File
}

impl&lt;'a&gt; Writer&lt;'a&gt; {
    pub fn new(file: &amp;'a File) -&gt; Self {
        Self { file }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这样, 我们就不需要对原始用法片段做太多改动了:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("opening file...");
let filename = "hello.txt";
let file = File::create(filename).unwrap();
let writer = Writer::new(&amp;file); // Only this line changed.
<span class="boring">}</span></code></pre></pre>
<p>我们只需调用<code>Writer::new()</code>而不是使用<code>Writer {}</code>语法来构建.</p>
<p>不过, 这对作用域版本无效:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let writer = {
    println!("opening file...");
    let filename = "hello.txt";
    Writer::new(&amp;File::create(filename).unwrap()) // Error: Does not live long enough!
};

writer.something(); // Error: File no longer alive here!
<span class="boring">}</span></code></pre></pre>
<p>正如我们之前看到的, 虽然临时生命周期扩展会通过<code>Writer {}</code>结构语法传播, 但不会通过<code>Writer::new()</code>函数调用语法传播. (例如, 签名可以是<code>fn new(&amp;File) -&gt; Self&lt;'static&gt;</code>或<code>fn new(&amp;File) -&gt; i32</code>, 这样就不需要扩展临时生命周期了).</p>
<p>遗憾的是, 我们无法明确选择临时生命周期扩展.我们必须在最外层作用域中设置一个<code>let file</code>.目前我们能做的最好的办法就是使用延迟初始化:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let file;
let writer = {
    println!("opening file...");
    let filename = "hello.txt";
    file = File::create(filename).unwrap();
    Writer::new(&amp;file)
};
<span class="boring">}</span></code></pre></pre>
<p>但这会使<code>file</code>回到作用域中, 而这正是我们想要避免的.</p>
<p>虽然可以说把<code>let file</code>放在作用域外部并不是什么大问题, 但对于大多数<code>Rust</code>程序员来说, 这种变通方法并不明显.延迟初始化并不是一个常用的功能, 编译器目前在给出临时生命周期错误时也不会建议采用这种变通方法. 即使编译器可以这样做, 这也不是一个小改动.</p>
<p>如果能以某种方式解决这个问题就好了</p>
<h3 id="macros宏"><a class="header" href="#macros宏">Macros宏</a></h3>
<p>如果有一个函数既能创建文件, 又能返回一个 <code>Writer</code> 文件, 可能会很有用.比如</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let writer = Writer::new_file("hello.txt");
<span class="boring">}</span></code></pre></pre>
<p>但是, 由于 <code>Writer</code> 只借用<code>file</code>, 这就要求 <code>new_file</code> 将<code>File</code>存储在某个地方.它可以<code>leak</code>这个<code>File</code>或以某种方式将其存储在<code>static</code>中, 但(目前)它没有办法让<code>file</code>与返回的 <code>Writer</code> 一样长存.</p>
<p>因此, 我们可以使用宏来定义文件和写入器, 无论它在哪里被调用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! let_writer_to_file {
    ($writer:ident, $filename:expr) =&gt; {
        let file = std::fs::File::create($filename).unwrap();
        let $writer = Writer::new(&amp;file);
    };
}
<span class="boring">}</span></code></pre></pre>
<p>使用方法如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let_writer_to_file!(writer, "hello.txt");

writer.something();
<span class="boring">}</span></code></pre></pre>
<p>由于<a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">宏的卫生性</a>, 在此范围内无法访问<code>file</code>.</p>
<p>这样做是可行的, 但如果它看起来更像一个普通的函数调用, 不是更好吗？</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>et writer = writer_to_file!("hello.txt");

writer.something();
<span class="boring">}</span></code></pre></pre>
<p>正如我们之前所见, 在 <code>let writer = ...;</code>语句中创建一个存活时间足够长的临时<code>File</code>的方法是使用临时生命周期扩展:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! writer_to_file {
    ($filename:expr) =&gt; {
        Writer { file: &amp;File::create($filename).unwrap() }
    };
}

let writer = writer_to_file!("hello.txt");
<span class="boring">}</span></code></pre></pre>
<p>这将扩展成:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let writer = Writer { file: &amp;File::create("hello.txt").unwrap() };
<span class="boring">}</span></code></pre></pre>
<p>这将在必要时延长临时<code>File</code>的生命周期.</p>
<p>但如果<code>file</code>不是公开, 我们就不能这样做, 而需要使用 <code>Writer::new()</code> 代替.宏需要在调用它的 <code>let writer = ...;</code>语句之前插入 <code>let file</code>;.这是不可能的.</p>
<h4 id="format_args"><a class="header" href="#format_args">format_args!()</a></h4>
<p>这个问题也是(现在)<code>format_args!()</code> 的结果不能存储在 <code>let</code> 语句中的原因:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = format_args!("{}", 1); // Error!
something.write_fmt(f);
<span class="boring">}</span></code></pre></pre>
<p>原因是 <code>format_args!()</code> 会扩展为类似 <code>fmt::Arguments::new(&amp;Argument::display(&amp;arg), ...)</code> 的内容, 其中一些参数是对临时变量的引用.</p>
<p>临时生命周期扩展不适用于函数调用的参数, 因此 <code>fmt::Arguments</code> 对象只能在同一语句中使用.</p>
<h4 id="pin"><a class="header" href="#pin">pin!()</a></h4>
<p>另一种经常通过宏创建的类型是 <code>Pin</code>.粗略地说, 它表示对某个永远不会移动的东西的引用.(具体细节很复杂, 但现在不是很重要).</p>
<p>它是通过一个名为 <code>Pin::new_unchecked</code> 的<code>unsafe</code>函数创建的, 因为我们需要保证它所引用的值即使在 <code>Pin</code> 本身消失后也不会被移动.</p>
<p>使用该函数的最佳方法是使用<a href="https://doc.rust-lang.org/rust-by-example/variable_bindings/scope.html"><code>shadowing</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut thing = Thing { … };
let thing = unsafe { Pin::new_unchecked(&amp;mut thing) };
<span class="boring">}</span></code></pre></pre>
<p>因为第二个<code>thing</code>会对第一个<code>thing</code>产生<code>shadow</code>, 所以第一个<code>thing</code>(仍然存在)不能再被命名.因为它不能被命名, 所以我们可以确定它不能被移动(即使在放弃第二个<code>thing</code>后), 这正是我们在<code>unsafe</code>块中所承诺的.</p>
<p>因为这是一种常见的模式, 所以通常用宏来捕获这种模式.</p>
<p>例如, 我们可以定义一个 <code>let_pin</code> 宏如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! let_pin {
    ($name:ident, $init:expr) =&gt; {
        let mut $name = $init;
        let $name = unsafe { Pin::new_unchecked(&amp;mut $name) };
    };
}
<span class="boring">}</span></code></pre></pre>
<p>使用方法与之前的 <code>let_writer_to_file</code> 宏类似:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let_pin!(thing, Thing { … });

thing.something();
<span class="boring">}</span></code></pre></pre>
<p>这样做可以很好地封装和隐藏不安全代码.</p>
<p>但是, 就像我们的 <code>Writer</code> 示例一样, 如果它能像下面这样工作, 不是更好吗？</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = pin!(Thing { … });
<span class="boring">}</span></code></pre></pre>
<p>我们都知道, 要做到这一点, 我们必须利用临时生命周期扩展功能, 使<code>Thing</code>的生命周期足够长.而要做到这一点, 我们必须使用 <code>Pin {}</code> 语法来构造 <code>Pin:Pin { pinned: &amp;mut Thing { ... }}</code> 会调用临时生命周期扩展, 但 P<code>in::new_unchecked(&amp;mut Thing { ... })</code> 不会.</p>
<p>这就意味着要将 <code>Pin</code> 的字段公开, 这就违背了 <code>Pin</code> 的初衷.只有在字段是私有的情况下, 它才能提供有意义的保证.</p>
<p>这意味着, 不幸的是, (如今)不可能自己编写这样一个 <code>pin!()</code> 宏.</p>
<p>标准库还是这么做了, 犯了一个可怕的罪行:<code>Pin</code> 的 "私有 "字段实际上被定义为 <code>pub</code>, 但也被标记为 "不稳定", 如果你试图使用它, 编译器就会抱怨.</p>
<p>如果不需要这种黑客手段就好了.</p>
<h2 id="super-let"><a class="header" href="#super-let"><code>super let</code></a></h2>
<h3 id="用户体验和诊断"><a class="header" href="#用户体验和诊断">用户体验和诊断</a></h3>
<h3 id="可能的扩展"><a class="header" href="#可能的扩展">可能的扩展</a></h3>
<p>未来可能的扩展是允许在函数作用域中使用<code>super let</code>. 也就是说, "super"指的是函数的调用者.</p>
<p>正如<a href="https://hachyderm.io/@lorepozo@tech.lgbt/111499621692587962">@lorepozo@tech.lgbt</a>在Mastodon上提到的, 这将使 <code>pin!()</code> 成为一个函数而不是宏. 同样, 它也能让 <code>Writer::new_file(...)</code> 成为可能, 而不必使用宏.</p>
<p>这样做的有效方式是允许某些函数将对象放入调用者的堆栈框架中, 然后可以从返回值中引用这些对象. 这在任何普通的旧函数中都是行不通的；通常情况下, 调用者不会为函数预留放置对象的空间. 这需要成为函数签名的一部分.</p>
<p>也许可以这样?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub placing fn new_file(filename: &amp;str) -&gt; Writer {
    super let mut file = File::create(filename).unwrap(); // Placed into caller's stack frame
    Writer::new(&amp;file) // So we can borrow it in the return value!
}
<span class="boring">}</span></code></pre></pre>
<p>这不是我现在提出的建议的一部分, 但想想也很有趣. ）</p>
<h2 id="临时生命周期-2024-rfc"><a class="header" href="#临时生命周期-2024-rfc">临时生命周期 2024 RFC</a></h2>
<p>几个月前, 我与<em>Niko Matsakis</em>和<em>Ding Xiang Fei</em>分享了我的想法--<code>super let</code>.他们一直在努力制定<code>super let</code>的确切定义和详细规则, 以及下一版<code>Rust</code>的临时生命周期的一些新规则.</p>
<p>这项名为 <a href="https://rust-lang.zulipchat.com/#narrow/stream/403629-t-lang.2Ftemporary-lifetimes-2024"><code>“temporary lifetimes 2024” effort</code></a>的联合工作正在促成一项RFC, 该RFC主要建议尽可能减少临时生命周期, 以防止 <code>if let</code> 或匹配中的临时 <code>MutexGuard</code> 导致的死锁, 并添加 <code>super let</code> 作为选择更长生命周期的一种方式.</p>
<h2 id="反馈"><a class="header" href="#反馈">反馈</a></h2>
<p>你是否有意识地使用过临时延长寿命的方法？或者你被它咬过吗？</p>
<p>你怎么看<code>super let</code>？你会使用它吗？或者你有更好的主意？</p>
<p>请在下面的评论或 <code>GitHub</code> 上告诉我, 或加入 <code>Reddit``、Twitter</code> 或 <code>Mastodon</code> 上的讨论.</p>
<h2 id="引用"><a class="header" href="#引用">引用</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p><a href="https://blog.m-ou.se/super-let/">Rust Temporary Lifetimes and "Super Let"</a> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="宏系统"><a class="header" href="#宏系统">宏系统</a></h1>
<h2 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h2>
<h2 id="过程宏"><a class="header" href="#过程宏">过程宏</a></h2>
<div class="table-wrapper"><table><thead><tr><th>类别</th><th>形式</th><th>函数名称</th><th>函数签名</th></tr></thead><tbody>
<tr><td>函数式</td><td><code>#[paoc_macro]</code></td><td>函数名即宏名</td><td><code>(TokenStream) -&gt; TokenStream</code></td></tr>
<tr><td>属性式</td><td><code>#[proc_macro_attribute]</code></td><td>函数名即宏名</td><td><code>(TokenStream, TokenStream) -&gt; TokenStream</code></td></tr>
<tr><td><code>derive</code>式</td><td><code>#[proc_macro_derive(Name)]</code>或者<code>#[proc_macro_derive(Name, attributes(attr))]</code></td><td>任意,因为宏名是<code>Name</code></td><td><code>(TokenStream) -&gt; TokenStream</code></td></tr>
</tbody></table>
</div>
<h3 id="proc-macro-crate"><a class="header" href="#proc-macro-crate">proc-macro crate</a></h3>
<p>定义一个过程宏<code>crate</code>的方式是将在<a href="https://doc.rust-lang.org/nightly/reference/linkage.html"><code>crate type</code></a>设为<code>proc-macro</code>.</p>
<p>当使用<code>Cargo</code>时, 过程宏<code>crate</code>是将<code>Cargo.toml</code>中的<code>lib.proc-macro</code>设为<code>true</code>值.</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>它只能导出过程宏, 正常的函数、类型、模块、<code>macro_rules!</code> 等内容都不能导出, 但可以仅在其内部定义和使用.</p>
<h3 id="函数式过程宏"><a class="header" href="#函数式过程宏">函数式过程宏</a></h3>
<p>类型函数的过程宏, 像声明宏那样被调用, 即<code>makro!(...)</code>. 它是唯一一个在单独看调用形式时, 无法与声明宏区分开的宏.</p>
<p>函数式过程宏的简单编写框架如下所示:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;

#[proc_macro]
pub fn fn_name_macro(input: TokenStream) -&gt; TokenStream {
    input
}

<span class="boring">}</span></code></pre></pre>
<p>可以看到, 这实际上只是从一个<code>TokenStream</code>到另一个<code>TokenStream</code>的映射, 其中 input 是调用分隔符内的标记.</p>
<h3 id="属性式过程宏"><a class="header" href="#属性式过程宏">属性式过程宏</a></h3>
<p>属性式过程宏定义了可添加到条目的的新外部属性.这种宏通过 <code>#[attr]</code> 或 <code>#[attr(…)]</code> 方式调用, 其中 <code>…</code> 是任意标记树.</p>
<p>属性式过程宏的简单框架如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn attribute_name_macro(input: TokenStream, annotated_item: TokenStream) -&gt; TokenStream {
    annotated_item
}
<span class="boring">}</span></code></pre></pre>
<p>需要注意的是, 与其它两个过程宏不同, 这种宏有两个输入参数.</p>
<ul>
<li>第一个参数是属性名称后面的带分隔符的标记树, 不包括它周围的分隔符.如果只有属性名称(其后不带标记树, 比如 <code>#[attr]</code>), 则这个参数的值为空.</li>
<li>第二个参数是添加了该过程宏属性的条目, 但不包括该过程宏所定义的属性.因为这是一个<a href="https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes"><code>active</code></a>属性, 在传递给过程宏之前, 该属性将从条目中剥离出来.</li>
</ul>
<h3 id="derive式过程宏"><a class="header" href="#derive式过程宏"><code>derive</code>式过程宏</a></h3>
<p><code>derive</code>式过程宏为<code>derive</code>属性定义了新的输入.这种宏通过将其<strong>名称</strong>提供给<code>derive</code>属性的输入来调用, 例如 <code>#[derive(derive_name)]</code>.</p>
<p><code>derive</code>式过程宏的简单框架如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;

#[proc_macro_derive(derive_name)]
pub fn derive_name_macro(input: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
<span class="boring">}</span></code></pre></pre>
<p><code>proc_macro_derive</code>稍微特殊一些, 因为它需要一个额外的标识符, 此标识符将成为 <code>derive</code> 宏的实际名称.
输入标记流是添加了 <code>derive</code> 属性的条目, 也就是说, 它将始终是 <code>enum</code>、<code>struct</code> 或者 <code>union</code> 类型, 因为这些是 <code>derive</code> 属性仅可以添加上去的条目.</p>
<p>输出的标记流将被<strong>追加</strong>到带注释的条目所处的块或模块, 所以要求标记流由一组有效条目组成.</p>
<blockquote>
<p>属性宏与 <code>derive</code> 宏的显著区别在于, 属性宏生成的标记是<strong>完全替换</strong>性质, 而 <code>derive</code> 宏生成的标记是<strong>追加</strong>性质.</p>
</blockquote>
<h4 id="derive式过程宏的辅助属性"><a class="header" href="#derive式过程宏的辅助属性"><code>derive</code>式过程宏的辅助属性</a></h4>
<p><code>derive</code> 宏又有一点特殊, 因为它可以添加仅在条目定义范围内可见的附加属性.
这些属性被称为派生宏辅助属性(derive macro helper attributes), 并且是惰性的(<a href="https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes"><code>inert</code></a>).
辅助属性的目的是在每个结构体字段或枚举体成员的基础上为 <code>derive</code> 宏提供额外的可定制性.</p>
<p>辅助属性的定义方式是向 <code>proc_macro_derive</code> 属性增加 <code>attributes(helper0, helper1, ..)</code> 参数, 该参数可包含用逗号分隔的标识符列表(即辅助属性的名称).</p>
<p>编写带辅助属性的`derive``宏的简单框架如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;

#[proc_macro_derive(derive_name, attributes(helper0, helper1, ...))]
pub fn derive_name_macro(input: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
<span class="boring">}</span></code></pre></pre>
<p>这就是辅助属性的全部内容.在过程宏中使用(或者说消耗)辅助属性, 得检查字段和成员的属性, 来判断它们是否具有相应的辅助属性
如果条目使用了所有 derive 宏都未定义的辅助属性, 那么会出现错误, 因为编译器会尝试将这个辅助属性解析为普通属性(而且这个属性并不存在).</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<ul>
<li><a href="https://zjp-cn.github.io/tlborm/introduction.html">宏小册</a></li>
<li><a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a></li>
<li><a href="https://doc.rust-lang.org/nightly/reference/macros.html">The Rust Reference - Macros</a></li>
<li><a href="https://github.com/dtolnay/proc-macro-workshop">Proc-Macro-Workshop</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust交叉编译"><a class="header" href="#rust交叉编译">rust交叉编译</a></h1>
<p><code>toolchain</code>和<code>target</code>分别是, <code>toolchain</code>是交叉编译所需的“编译工具”, 而<code>target</code>则是编译到目标平台所需的"库文件"</p>
<h2 id="什么是-toolchain"><a class="header" href="#什么是-toolchain">什么是 <code>Toolchain</code></a></h2>
<p><code>toolchain</code> 指一组<code>Rust</code>工具, 包括编译器(<code>rustc</code>), 构建工具(<code>cargo</code>), 文档生成工具(<code>rustdoc</code>)以及其他与 <code>Rust</code> 相关的实用程序. <code>Toolchain</code>用于管理和构建 Rust 代码, 并且可以包括一个特定版本的 <code>Rust</code> 编译器和标准库, 还包含一个默认是编译到本机平台的<code>target</code>. 工具链的版本可以是 "stable"(稳定版), "beta"(测试版)或 "nightly"(每日构建版), 每个版本都对应着不同的 <code>Rust</code> 编译器和特性. 工具链中的工具命令了, 它们通常存储在<code>~/.cargo/bin</code>这个目录下.</p>
<h2 id="什么是-rustc-target"><a class="header" href="#什么是-rustc-target">什么是 <code>Rustc target</code></a></h2>
<p><code>Rust</code> 中的<code>target</code>概念主要是为了支持跨平台开发和交叉编译, 以确保 <code>Rust</code> 代码可以在不同的操作系统和架构上正确运行. <code>Rustc target</code>指的是编译和构建目标平台<code>Rust</code>代码时需要的组件. 不要混淆为<code>Rust</code>项目编译后产生的<code>target</code>文件夹. 它的格式表示为: <code>&lt;arch&gt;-&lt;vendor&gt;-&lt;os&gt;-&lt;abi&gt;</code>. 其中:</p>
<ul>
<li><code>&lt;arch&gt;</code> 表示<strong>架构</strong>(例如, x86_64 表示64位的x86架构).</li>
<li><code>&lt;vendor&gt;</code> 表示<strong>供应商</strong>(一般为空).</li>
<li><code>&lt;os&gt;</code> 表示<strong>操作系统</strong>(例如, linux, windows, macos 等).</li>
<li><code>&lt;abi&gt;</code> 表示<strong>二进制接口</strong>(例如, 默认的是 "gnu", 也可以是 "musl", "msvc" 等)</li>
</ul>
<p>例如:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code>: 64位 x86 架构, Linux 操作系统, 使用 gnu.</li>
<li><code>x86_64-unknown-linux-musl</code> 64位 x86 架构, Linux 操作系统, 使用 musl.</li>
<li><code>i686-pc-windows-msvc</code>: 32位 x86 架构, Windows 操作系统, 使用 MSVC 编译器.</li>
</ul>
<p>一般来说只需要<code>rustup target add &lt;target&gt;</code>命令安装某个目标平台组件即可, 但对于一些特殊平台, 可能需要手动安装相关的交叉编译工具链, 例如<em>windows msvc</em>或者<em>android NDK</em>.</p>
<p>常用命令:</p>
<pre><code class="language-shell"># 列出可用的target
rustup target list
# 安装一个新的rustup target add &lt;target&gt;
rustup target add x86_64-unknown-linux-gnu
# 把代码编译到指定平台
cargo build --target x86_64-unknown-linux-gnu
</code></pre>
<h2 id="rust编译流程"><a class="header" href="#rust编译流程">Rust编译流程</a></h2>
<pre><code class="language-shell">Source code -&gt; MIR -&gt; LLVM IR -&gt; 机器码 -&gt; Target链接 -&gt; 可执行文件或库
</code></pre>
<p>以<code>Linux</code>平台为例, <code>Rust</code>编译器就是<code>rustc</code></p>
<ul>
<li>首先会把源码编译为<code>MIR</code></li>
<li>然后交给<code>LLVM</code>处理, <code>LLVM</code>继续把<code>MIR</code>先编译成<code>LLVM IR</code>.</li>
<li>进而编译为目标平台的<em>机器码</em>(此时还不是执行文件, 只是一堆机器码)</li>
<li>往后就是<code>target</code>发挥作用了, <code>target</code>调用<code>msvc</code>或<code>gnu</code>来完成链接步骤, 主要是链接目标平台库文件并生成可执行文件.</li>
</ul>
<p>这里整个编译过程几乎都是由<code>rustc</code>完成的, 因为它包含了<code>llvm</code>和调用<code>target</code>的代码, 跟目标平台相关的工作则是由<code>msvc</code>或<code>gnu</code>来完成. <code>msvc</code>和<code>gnu</code>是<code>c/c++</code>的编译工具链, 编译后的最终产物就是可执行文件或库, <code>rustc</code>在编译后期用到了它们提供的功能.</p>
<h2 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h2>
<p><code>Ubuntu</code>默认的<code>target</code>是<code>gnu</code>的, 依赖<code>glibc</code>, 但是其他<code>Linux</code>系统未必是<code>glibc</code>是基础库, 但是可以用同一套<code>toolchain</code>(编译器之类的), 因此只需要添加<code>target</code>即可.</p>
<p>而交叉编译到<code>Windows</code>, 则<code>Linux</code>的编译器是没有这个能力的, 因此需要添加<code>Windows</code>平台的<code>toolchain</code>(有部分<code>toolchain</code>官方没有实现还得添加第三方的<code>toolchain</code>), 然后再添加<code>target</code>.
<em><strong>注意</strong></em>, 如果<code>Windows</code>选择的是<code>msvc</code>而非<code>gnu</code>, 那么哪怕是最简单的<code>hello world</code>也必须要安装<code>visual studio</code>(主要是需要它携带的<code>toolchain</code>[<code>linker</code>等])</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/iXDgb0oph1AaedgV_Aw4Zw">从Rustup出发看看Rust语言的编译生态</a></li>
<li><a href="https://mp.weixin.qq.com/s/mOCpBNa7W-_cCb4Y6-6hgw">Rust交叉编译最全总结</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang"><a class="header" href="#golang">Golang</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang-ast"><a class="header" href="#golang-ast">Golang AST</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-token"><a class="header" href="#1-token">1. Token</a></h1>
<p>Token是编程语言中最小的具有独立含义的词法单元.<br />
Token不仅仅包含关键字,还包含用户自定义的<strong>标识符</strong>、<strong>运算符</strong>、<strong>分隔符</strong>和<strong>注释</strong>等.<br />
每个Token对应的词法单元有三个属性是比较重要的：</p>
<ul>
<li>Token本身的值表示词法单元的类型</li>
<li>Token在源代码中源代码文本形式</li>
<li>Token出现的位置</li>
<li>在所有的Token中,注释和分号是两种比较特殊的Token：
<ul>
<li>普通的注释一般不影响程序的语义,因此很多时候可以忽略注释；</li>
<li>Go语言中经常在行尾自动添加分号Token,而<strong>分号</strong>是<strong>分隔语句</strong>的词法单元,因此自动添加分号导致了Go语言左花括弧不能单独一行等细微的语法差异.</li>
</ul>
</li>
</ul>
<h2 id="11-token语法"><a class="header" href="#11-token语法">1.1 Token语法</a></h2>
<p>Go语言中主要有<strong>标识符</strong>、<strong>关键字</strong>、<strong>运算符</strong>和<strong>分隔符</strong>等类型等Token组成.</p>
<ul>
<li><strong>标识符</strong>由字母和数字组成,开头第一个字符必须是字母,<strong>标识符</strong>的语法定义如下：</li>
</ul>
<pre><code class="language-shell">identifier = letter { letter | unicode_digit } .
letter     = unicode_letter | "_" .
</code></pre>
<ul>
<li><strong>关键字</strong>用于引导特殊的语法结构,不能将关键字作为独立的标识符.下面是Go语言定义的25个关键字：</li>
</ul>
<pre><code class="language-go">break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
</code></pre>
<ul>
<li><strong>运算符</strong>和<strong>分隔符</strong>,下面是Go语言定义的47个符号：</li>
</ul>
<pre><code class="language-go">+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )
-    |     -=    |=     ||    &lt;     &lt;=    [    ]
*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }
/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;
%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :
     &amp;^          &amp;^=
</code></pre>
<p>用户自定义的标识符、25个关键字、47个运算和分隔符号,程序中还有一些面值、注释和空白符组成</p>
<h2 id="12-token定义"><a class="header" href="#12-token定义">1.2 Token定义</a></h2>
<p>在<code>go/token</code>包中,Token被定义为一种枚举值,不同值的Token表示不同类型的词法记号：</p>
<pre><code class="language-go">// Token is the set of lexical tokens of the Go programming language.
type Token int

// The list of tokens.
const (
	// Special tokens
	ILLEGAL Token = iota
	EOF
	COMMENT
    
    literal_beg
	// Identifiers and basic type literals
	// (these tokens stand for classes of literals)
	IDENT  // main
	INT    // 12345
	FLOAT  // 123.45
	IMAG   // 123.45i
	CHAR   // 'a'
	STRING // "abc"
	literal_end
    
    operator_beg
	// Operators and delimiters
	ADD // +
	SUB // -
	MUL // *
	QUO // /
	REM // %

	AND     // &amp;
	OR      // |
	XOR     // ^
	SHL     // &lt;&lt;
	SHR     // &gt;&gt;
	AND_NOT // &amp;^

	ADD_ASSIGN // +=
	SUB_ASSIGN // -=
	MUL_ASSIGN // *=
	QUO_ASSIGN // /=
	REM_ASSIGN // %=

	AND_ASSIGN     // &amp;=
	OR_ASSIGN      // |=
	XOR_ASSIGN     // ^=
	SHL_ASSIGN     // &lt;&lt;=
	SHR_ASSIGN     // &gt;&gt;=
	AND_NOT_ASSIGN // &amp;^=

	LAND  // &amp;&amp;
	LOR   // ||
	ARROW // &lt;-
	INC   // ++
	DEC   // --

	EQL    // ==
	LSS    // &lt;
	GTR    // &gt;
	ASSIGN // =
	NOT    // !

	NEQ      // !=
	LEQ      // &lt;=
	GEQ      // &gt;=
	DEFINE   // :=
	ELLIPSIS // ...

	LPAREN // (
	LBRACK // [
	LBRACE // {
	COMMA  // ,
	PERIOD // .

	RPAREN    // )
	RBRACK    // ]
	RBRACE    // }
	SEMICOLON // ;
	COLON     // :
	operator_end
    
    	keyword_beg
	// Keywords
	BREAK
	CASE
	CHAN
	CONST
	CONTINUE

	DEFAULT
	DEFER
	ELSE
	FALLTHROUGH
	FOR

	FUNC
	GO
	GOTO
	IF
	IMPORT

	INTERFACE
	MAP
	PACKAGE
	RANGE
	RETURN

	SELECT
	STRUCT
	SWITCH
	TYPE
	VAR
	keyword_end
)
</code></pre>
<p>所有的Token被分为四类：<strong>特殊类型</strong>、<strong>基础面值</strong>、<strong>运算符(分隔符)<strong>和</strong>关键字</strong>.</p>
<p><img src="golang/ast/../assets/202302060947889.png" alt="image-20230206094723835" /></p>
<ul>
<li><strong>特殊类型</strong>的Token.</li>
</ul>
<blockquote>
<p>有错误、文件结束和注释三种,遇到不能识别的Token统一返回ILLEGAL,这样可以简化词法分析时的错误处理.</p>
</blockquote>
<ul>
<li><strong>基础面值</strong>对应的Token</li>
</ul>
<blockquote>
<p>Go语言规范定义的基础面值主要有整数、浮点数和复数面值类型,此外还有字符和字符串面值类型.<br />
需要注意的是,在Go语言规范中布尔类型的true和false并不在基础面值之类.但是为了方便词法解析,<code>go/token</code>包将true和false等对应的标识符也作为面值Token一类.</p>
<p>其中literal_beg和literal_end是私有的类型,主要用于表示面值类型Token的值域范围</p>
</blockquote>
<ul>
<li>**运算符(分隔符)**Token</li>
</ul>
<blockquote>
<p>运算符主要有普通的加减乘除等算术运算符号,此外还有逻辑运算、位运算符和比较运算等二元运算（其中二元运算还和赋值运算再次组合）.<br />
除了二元运算之外,还有少量的一元运算符号：比如正负号、取地址符号、管道的读取等.而分隔符主要是小括弧、中括弧、大括弧,以及逗号、点号、分号和冒号组成.</p>
</blockquote>
<ul>
<li><strong>关键字</strong>Token</li>
</ul>
<blockquote>
<p>从词法分析角度看,关键字和普通的标识符并无差别.但是25个关键字一般都是不同语法结构的开头Token,通过将这些特殊的Token定义为关键字可以简化语法解析的工作</p>
</blockquote>
<h2 id="13-fileset和file"><a class="header" href="#13-fileset和file">1.3 FileSet和File</a></h2>
<p><code>go/token</code>包还定义了<code>FileSet</code>和<code>File</code>对象,用于描述文件集和文件.
<code>FileSet</code>和<code>File</code>对象的对应关系如图所示：</p>
<p><img src="golang/ast//home/thinkgo/.config/Typora/typora-user-images/image-20230206094625539.png" alt="image-20230206094625539" /></p>
<blockquote>
<p>每个<code>FileSet</code>表示一个文件集合,底层抽象为一个一维数组,而Pos类型表示数组的下标位置.
<code>FileSet</code>中的每个<code>File</code>元素对应底层数组的一个区间,不同的File之间没有交集,相邻的File之间可能存在填充空间.</p>
</blockquote>
<blockquote>
<p>每个File主要由文件名、base和size三个信息组成.
其中base对应File在FileSet中的Pos索引位置,因此base和base+size定义了File在FileSet数组中的开始和结束位置.
在每个File内部可以通过offset定位下标索引,通过offset+File.base可以将File内部的offset转换为Pos位置.因为Pos是FileSet的全局偏移量,反之也可以通过Pos查询对应的File,以及对应File内部的offset.</p>
</blockquote>
<blockquote>
<p>词法分析的每个Token位置信息就是由Pos定义,通过Pos和对应的FileSet可以轻松查询到对应的File.然后在通过File对应的源文件和offset计算出对应的行号和列号（实现中File只是保存了每行的开始位置,并没有包含原始的源代码数据）.
Pos底层是int类型,它和指针的语义类似,因此0也类似空指针被定义为NoPos,表示无效的Pos.</p>
</blockquote>
<h2 id="14-解析token"><a class="header" href="#14-解析token">1.4 解析Token</a></h2>
<p>Go语言标准库<code>go/scanner</code>包提供了Scanner实现Token扫描,它是在FileSet和File抽象文件集合基础上进行词法分析.</p>
<p><code>scanner.Scanner</code>的公开接口定义如下</p>
<pre><code class="language-go">type Scanner struct {
	// public state - ok to modify
	ErrorCount int // number of errors encountered
	// Has unexported fields.
}

func (s *Scanner) Init(file *token.File, src []byte,err ErrorHandler, mode Mode)
func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string)
</code></pre>
<blockquote>
<p><code>Init</code>方法用于初始化扫描器:
<code>file</code>参数表示当前的文件（不包含代码数据）
<code>src</code>参数表示要分析的代码
<code>err</code>是用户自定义的错误处理函数
<code>mode</code>可以控制是否扫描注释部分</p>
</blockquote>
<blockquote>
<p>Scan方法扫描一个Token,三个返回值分别表示:
<code>pos</code>表示Token的位置
<code>tok</code>表示Token值
<code>lit</code>表示Token的源代码文本表示</p>
</blockquote>
<pre><code class="language-go">package main

import (
	"fmt"
	"go/scanner"
	"go/token"
)
// 要构造一个最简单的词法扫描器测试程序,首先要构造Init方法第一参数需要的File对象.但是File对象没有公开的构造函数,只能通过FileSet的AddFile方法间接构造File对象.
func main() {
	var src = []byte(`println("你好,世界")`)

	var fset = token.NewFileSet()
	var file = fset.AddFile("hello.go", fset.Base(), len(src))

	var s scanner.Scanner
	s.Init(file, src, nil, scanner.ScanComments)

	for {
		pos, tok, lit := s.Scan()
		if tok == token.EOF {
			break
		}
		fmt.Printf("%s\t%s\t%q\n", fset.Position(pos), tok, lit)
	}
}
// output: 
// hello.go:1:1	IDENT	"println"
// hello.go:1:8	(	""
// hello.go:1:9	STRING	"\"你好，世界\""
// hello.go:1:26	)	""
// hello.go:1:27	;	"\n"
</code></pre>
<h2 id="15-position位置信息"><a class="header" href="#15-position位置信息">1.5 Position位置信息</a></h2>
<p><code>go/token</code>包的Position表示更详细的位置信息,被定义为一个结构体：</p>
<pre><code class="language-go">type Position struct {
	Filename string // filename, if any
	Offset   int    // offset, starting at 0
	Line     int    // line number, starting at 1
	Column   int    // column number, starting at 1 (byte count)
}
</code></pre>
<blockquote>
<p><code>Filename</code>表示文件名
<code>Offset</code>对应文件内的字节偏移量（从0开始）
<code>Line</code>和<code>Column</code>对应行列号（从1开始）.</p>
<p>比较特殊的是Offset成员,它用于从文件数据定位代码,但是输出时会将偏移量转换为行列号输出.</p>
</blockquote>
<p>打印位置信息时,根据文件名、行号和列号有6种组合:</p>
<pre><code class="language-go">func main() {
	a := token.Position{Filename: "hello.go", Line: 1, Column: 2}
	b := token.Position{Filename: "hello.go", Line: 1}
	c := token.Position{Filename: "hello.go"}

	d := token.Position{Line: 1, Column: 2}
	e := token.Position{Line: 1}
	f := token.Position{Column: 2}

	fmt.Println(a.String())
	fmt.Println(b.String())
	fmt.Println(c.String())
	fmt.Println(d.String())
	fmt.Println(e.String())
	fmt.Println(f.String())
}
// output: 
// hello.go:1:2
// hello.go:1
// hello.go
// 1:2
// 1
// -
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-基础面值"><a class="header" href="#2-基础面值">2. 基础面值</a></h1>
<p><strong>面值</strong>是在程序代码中直接表示的值,其它的非零初始值只能由面值常量或常量表达式生成.
比如表达式<code>x+2*y</code>的<code>2</code>就是面值,而<code>x</code>和<code>y</code>则不是面值而是标识符.</p>
<h2 id="21-基础面值定义"><a class="header" href="#21-基础面值定义">2.1 基础面值定义</a></h2>
<p>Go语言规范明确定义了<em><strong>基础面值</strong></em>只有<strong>整数</strong>、<strong>浮点数</strong>、<strong>复数</strong>、<strong>符文</strong>和<strong>字符串</strong>几种类型.
需要特别注意的是<strong>布尔类型</strong>的<code>true</code>和<code>false</code>并不是普通的面值,而是<em><strong>内置的布尔类型标识符</strong></em>（可能被重新定义为其它变量）.</p>
<p>在<code>go/token</code>包中,基础面值也被定义为独立的Token：</p>
<pre><code class="language-go">    literal_beg
	// Identifiers and basic type literals
	// (these tokens stand for classes of literals)
	IDENT  // main
	INT    // 12345
	FLOAT  // 123.45
	IMAG   // 123.45i
	CHAR   // 'a'
	STRING // "abc"
	literal_end
</code></pre>
<p>在<code>go/ast</code>分别用两个结构体进行表示<em><strong>基础面值</strong></em>和<em><strong>标识符</strong></em>:</p>
<pre><code class="language-go">// 基础面值
type BasicLit struct {
	ValuePos token.Pos   // literal position
	Kind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING
	Value    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
}
// 标识符
type Ident struct {
	NamePos token.Pos // identifier position
	Name    string    // identifier name
	Obj     *Object   // denoted object; or nil
}
</code></pre>
<p><strong>整数型面值</strong>定义如下：</p>
<blockquote>
<p>// 整数型面值分为十进制面值、二进制面值、八进制面值和十六进制面值四种形式.
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .
decimal_lit    = "0" | ( "1" … "9" ) [ [ "<em>" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "</em>" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "<em>" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "</em>" ] hex_digits .</p>
<p>需要注意的是整数型面值并不支持科学计数法形式,同时数字中间可以添加下划线分隔数字.</p>
</blockquote>
<p><strong>浮点数面值</strong>定义如下:</p>
<blockquote>
<p>// 浮点数面值又分为十进制浮点数和十六进制浮点数.
float_lit         = decimal_float_lit | hex_float_lit .</p>
<p>// 十进制浮点数
decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
decimal_digits decimal_exponent |
"." decimal_digits [ decimal_exponent ] .
decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .</p>
<p>// 十六进制浮点数
hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
hex_mantissa      = [ "<em>" ] hex_digits "." [ hex_digits ] |
[ "</em>" ] hex_digits |
"." hex_digits .
hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .</p>
</blockquote>
<p><strong>复数面值</strong>定义如下:</p>
<blockquote>
<p>imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .</p>
</blockquote>
<p><strong>符文面值</strong>和<strong>字符串面值</strong>定义如下:</p>
<blockquote>
<p>// 符文面值是一个只有一个字符的字符串,由一对单引号包含.
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .</p>
<p>// 字符串由一对双引号或反引号表示,其中可以包含多个字符,但是不能跨行.
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "<code>" { unicode_char | newline } "</code>" .
interpreted_string_lit = <code>"</code> { unicode_value | byte_value } <code>"</code></p>
<ul>
<li>普通的符文和字符串都可以通过转义字符包含特殊的符号,它们是通过一个特殊的<code>\</code>斜杠开始.</li>
<li>反引号表示的字符串表示原生字符串,原生字符串可以跨域多行但是不支持转义字符,因此其内部是无法表示反引号这个字符的.</li>
</ul>
</blockquote>
<h2 id="22-基础面值语法树"><a class="header" href="#22-基础面值语法树">2.2 基础面值语法树</a></h2>
<p><code>go/ast</code>包定义了<strong>基础面值</strong>结构体:</p>
<pre><code class="language-go">type BasicLit struct {
	ValuePos token.Pos   // literal position
	Kind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING
	Value    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
}
</code></pre>
<blockquote>
<p><code>ValuePos</code>成员表示该词法元素开始的字节偏移量（并不包含文件名、行号和列号等信息）
<code>Kind</code>表示面值的类型（只有数值类型、字符和字符串三类）
<code>Value</code>是表示面值的原始代码</p>
</blockquote>
<h4 id="221构造基础面值"><a class="header" href="#221构造基础面值">2.2.1构造基础面值</a></h4>
<pre><code class="language-go">package main

import (
	"go/ast"
	"go/token"
)

func main() {
	var lit9527 = &amp;ast.BasicLit{
		Kind:  token.INT,
		Value: "9527",
	}
	ast.Print(nil, lit9527)
}
// output:
// 0 *ast.BasicLit {
// 1 	ValuePos: 1
// 2  	Kind: INT
// 3    Value: "9527"
// 4 }
</code></pre>
<blockquote>
<p><code>token.INT</code>表示基础面值的类型是整数,值是整数的十进制字符串表示.
如果把<code>token.INT</code>改为<code>token.FLOAT</code>则变成浮点数的9527,
如果改成<code>token.STRING</code>则会变成“9527”字符串面值.</p>
</blockquote>
<h4 id="222-解析基础面值"><a class="header" href="#222-解析基础面值">2.2.2 解析基础面值</a></h4>
<pre><code class="language-go">func main() {
	expr, _ := parser.ParseExpr(`9527`)
	ast.Print(nil, expr)
}
// output:
// 0 *ast.BasicLit {
// 1 	ValuePos: 1
// 2  	Kind: INT
// 3    Value: "9527"
// 4 }
</code></pre>
<blockquote>
<p><strong>基础面值</strong>在<strong>语法树</strong>中是属于<strong>叶子结点</strong>的存在,在递归遍历语法树时遇到基础面值结点递归就会返回.
同时,通过基础面值、指针、结构体、数组和map等其它语法结构的相互嵌套和组合就可以构造出无穷无尽的复杂类型来.</p>
</blockquote>
<h2 id="23-标识符面值"><a class="header" href="#23-标识符面值">2.3 标识符面值</a></h2>
<p><code>go/ast</code>包定义了<strong>标识面值</strong>结构体:</p>
<pre><code class="language-go">type Ident struct {
	NamePos token.Pos // identifier position
	Name    string    // identifier name
	Obj     *Object   // denoted object; or nil
}
</code></pre>
<blockquote>
<p><code>NamePos</code>表示标识符的位置
<code>Name</code>是标识符的名字
<code>Obj</code>则表示标识符的类型获取其它的扩展信息.作为内置的标识符面值来说,我们主要关注标识符的名字即可.</p>
</blockquote>
<h4 id="231构造标识符面值"><a class="header" href="#231构造标识符面值">2.3.1构造标识符面值</a></h4>
<pre><code class="language-go">package main

import (
	"go/ast"
)

func main() {
	ast.Print(nil, ast.NewIdent(`x`))
}
// output:
// 0 *ast.Ident {
// 1      NamePos: 0
// 2      Name: "x"
// 3 }
</code></pre>
<h4 id="222-解析基础面值-1"><a class="header" href="#222-解析基础面值-1">2.2.2 解析基础面值</a></h4>
<pre><code class="language-go">func main() {
	expr, _ := parser.ParseExpr(`x`)
	ast.Print(nil, expr)
}
// 从表达式解析标识符,则会通过Obj成员描述标识符额外的信息.
// output:
//     0  *ast.Ident {
//     1  .  NamePos: 1
//     2  .  Name: "x"
//     3  .  Obj: *ast.Object {
//     4  .  .  Kind: bad
//     5  .  .  Name: ""
//     6  .  }
//     7  }
</code></pre>
<p><code>ast.Object</code>是一个相对复杂的结构,其中Kind用于描述标识符的类型：</p>
<pre><code class="language-go">const (
    Bad ObjKind = iota // for error handling
    Pkg                // package
    Con                // constant
    Typ                // type
    Var                // variable
    Fun                // function or method
    Lbl                // label
)
</code></pre>
<blockquote>
<p>Bad表示未知的类型,其它的分别对应Go语言中<strong>包</strong>、<strong>常量</strong>、<strong>类型</strong>、<strong>变量</strong>、<strong>函数</strong>和<strong>标号</strong>等语法结构.
而对于标识符中更具体的类型（比如是整数还是布尔类型）则是由<code>ast.Object</code>的其它成员描述.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3基础表达式"><a class="header" href="#3基础表达式">3.基础表达式</a></h1>
<p><strong>基础表达式</strong>是指完全由<strong>数值型面值</strong>和<strong>标识符</strong>组成的表达式.</p>
<h2 id="31-基础表达式语法"><a class="header" href="#31-基础表达式语法">3.1 基础表达式语法</a></h2>
<p><strong>基础表达式</strong>主要是指由<strong>一元</strong>和<strong>二元</strong>运算符组成的表达式，运算的主体是各种面值或标识符.</p>
<pre><code class="language-shell">// Expression表示基础表达式的递归定义,可以是UnaryExpr类型的一元表达式，或者是binary_op生成的二元表达式.
// 基础表达式运算符两边的对象由Operand定义,主要是面值或表达式，也可以是由小括弧包含的表达式。
Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = Operand | unary_op UnaryExpr .
Operand    = Literal | identifier | "(" Expression ")" .

binary_op  = "||" | "&amp;&amp;" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .
</code></pre>
<h2 id="32-解析表达式"><a class="header" href="#32-解析表达式">3.2 解析表达式</a></h2>
<p><code>parser.ParseExpr</code>函数是解析的单个表达式（可以包含注释），因此返回的<code>ast.Expr</code>是一个表达式抽象接口：</p>
<pre><code class="language-go">type Expr interface {
    Node
    // contains filtered or unexported methods
}
</code></pre>
<p><code>st.Node</code>接口更简单，只有两个方法表示了这个语法树结点的开始位置和结束位置：</p>
<pre><code class="language-go">type Node interface {
    Pos() token.Pos // position of first character belonging to the node
    End() token.Pos // position of first character immediately after the node
}
</code></pre>
<p>通过分析<code>go/ast</code>包的文档可以发现很多类型以<code>Expr</code>为后缀名：</p>
<pre><code class="language-bash">$ go doc go/ast | grep Expr
type BadExpr struct{ ... }
type BinaryExpr struct{ ... }
type CallExpr struct{ ... }
type Expr interface{ ... }
type ExprStmt struct{ ... }
type IndexExpr struct{ ... }
type KeyValueExpr struct{ ... }
type ParenExpr struct{ ... }
type SelectorExpr struct{ ... }
type SliceExpr struct{ ... }![](../assets/202302060946639.png)
type StarExpr struct{ ... }
type TypeAssertExpr struct{ ... }
type UnaryExpr struct{ ... }
</code></pre>
<p><code>ast.BinaryExpr</code>表达的二元算术表达式开始，因为加减乘除四则运算是我们最熟悉的表达式结构：</p>
<pre><code class="language-go">func main() {
	expr, _ := parser.ParseExpr(`1+2*3`)
	ast.Print(nil, expr)
}
// output:
// 	0  *ast.BinaryExpr {
// 	1  .  X: *ast.BasicLit {
// 	2  .  .  ValuePos: 1
// 	3  .  .  Kind: INT
// 	4  .  .  Value: "1"
// 	5  .  }
// 	6  .  OpPos: 2
// 	7  .  Op: +
// 	8  .  Y: *ast.BinaryExpr {
// 	9  .  .  X: *ast.BasicLit {
//    10  .  .  .  ValuePos: 3
//    11  .  .  .  Kind: INT
//    12  .  .  .  Value: "2"
//    13  .  .  }
//    14  .  .  OpPos: 4
//    15  .  .  Op: *
//    16  .  .  Y: *ast.BasicLit {
//    17  .  .  .  ValuePos: 5
//    18  .  .  .  Kind: INT
//    19  .  .  .  Value: "3"
//    20  .  .  }
//    21  .  }
//    22  }
</code></pre>
<p>下图是<code>parser.ParseExpr("1+2*3")</code>返回的树结构：</p>
<p><img src="golang/ast/../assets/202302060947079.png" alt="image-20230206094702039" /></p>
<p>其中<code>ast.BasicLit</code>是基础面值类型，在前面章节已经讲过。而<code>ast.BinaryExpr</code>是表示二元表达式的结点，其定义如下：</p>
<pre><code class="language-go">type BinaryExpr struct {
    X     Expr        // left operand
    OpPos token.Pos   // position of Op
    Op    token.Token // operator
    Y     Expr        // right operand
}
</code></pre>
<h2 id="33-求值表达式"><a class="header" href="#33-求值表达式">3.3 求值表达式</a></h2>
<p>在了解了<code>ast.BinaryExpr</code>语法树的结构之后，其实我们就可以手工对表达式求值了：</p>
<pre><code class="language-go">func main() {
	expr, _ := parser.ParseExpr(`1+2*3`)
	fmt.Println(Eval(expr))
}

func Eval(exp ast.Expr) float64 {
	switch exp := exp.(type) {
	case *ast.BinaryExpr:
		return EvalBinaryExpr(exp)
	case *ast.BasicLit:
		f, _ := strconv.ParseFloat(exp.Value, 64)
		return f
	}
	return 0
}

func EvalBinaryExpr(exp *ast.BinaryExpr) float64 {
	switch exp.Op {
	case token.ADD:
		return Eval(exp.X) + Eval(exp.Y)
	case token.MUL:
		return Eval(exp.X) * Eval(exp.Y)
	}
	return 0
}
</code></pre>
<h2 id="34-标识符-为表达式中引入变量"><a class="header" href="#34-标识符-为表达式中引入变量">3.4 标识符: 为表达式中引入变量</a></h2>
<pre><code class="language-go">func main() {
	expr, _ := parser.ParseExpr(`1+2*3+x`)
	fmt.Println(Eval(expr, map[string]float64{
		"x": 100,
	}))
}

func Eval(exp ast.Expr, vars map[string]float64) float64 {
	switch exp := exp.(type) {
	case *ast.BinaryExpr:
		return EvalBinaryExpr(exp, vars)
	case *ast.BasicLit:
		f, _ := strconv.ParseFloat(exp.Value, 64)
		return f
	case *ast.Ident:
		return vars[exp.Name]
	}
	return 0
}

func EvalBinaryExpr(exp *ast.BinaryExpr, vars map[string]float64) float64 {
	switch exp.Op {
	case token.ADD:
		return Eval(exp.X, vars) + Eval(exp.Y, vars)
	case token.MUL:
		return Eval(exp.X, vars) * Eval(exp.Y, vars)
	}
	return 0
}
</code></pre>
<p>在Eval函数递归解析时，如果当前解析的表达式语法树结点是<code>*ast.Ident</code>类型，则直接从<code>vars</code>表格查询结果。</p>
<p>不过在Go语言的表达式要复杂很多，不仅仅有普通的局部变量，还有数组索引求值、管道取值、其它结构的成员求值等类型。但是标识符是引入变量最基础的方法，我们可以在此基础方法之上慢慢完善更复杂的求值函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-代码结构"><a class="header" href="#4-代码结构">4. 代码结构</a></h1>
<p>Go语言的代码结构主要分为三个层面：<strong>目录结构</strong>、<strong>目录内部的包结构</strong>、<strong>文件内部的代码结构</strong>。
标准库的<code>go/parser</code>包只提供了目录和文件解析的函数</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资料-1"><a class="header" href="#资料-1">资料</a></h1>
<h2 id="0-book-1"><a class="header" href="#0-book-1">0. book</a></h2>
<ul>
<li><a href="https://github.com/geektutu/high-performance-go">high-performance-go</a> high performance coding with golang（Go 语言高性能编程，Go 语言陷阱，Gotchas，Traps)</li>
<li><a href="https://draveness.me/golang">Go 语言设计与实现</a> 深入理解语言设计以及实现原理</li>
<li><a href="https://github.com/aceld/golang">golang修养之路</a> 本书针对Golang专题性热门技术深入理解，修养在Golang领域深入话题，脱胎换骨</li>
<li><a href="https://github.com/pibigstar/go-demo">Go语言实例教程从入门到进阶</a>  Go语言实例教程从入门到进阶，包括基础库使用、设计模式、面试易错点、工具类、对接第三方等</li>
<li><a href="https://github.com/qcrao/Go-Questions">go-question</a>, <a href="https://qcrao91.gitbook.io/go/">book</a> 从问题切入，串连 Go 语言相关的所有知识，融会贯通.</li>
</ul>
<p><img src="golang/../assets/go-roadmap.png" alt="go-roadmap" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quiz-basic"><a class="header" href="#quiz-basic">quiz basic</a></h1>
<h2 id="1-defer-和-panic"><a class="header" href="#1-defer-和-panic">1. <code>defer</code> 和 <code>panic</code></a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

import "fmt"

// `defer` 和 `panic`
func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println("打印前") }()
    defer func() { fmt.Println("打印中") }()
    defer func() { fmt.Println("打印后") }()

    panic("触发异常")
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">打印后
打印中
打印前
panic: 触发异常
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p><code>defer</code> 的执行顺序是<strong>先进后出,后进先出</strong>的顺序执行.
出现panic语句的时候,会先按照<code>defer</code> 的后进先出顺序执行,最后才会执行<code>panic</code>.</p>
</blockquote>
<h2 id="2-array和slice"><a class="header" href="#2-array和slice">2. <code>array</code>和<code>slice</code></a></h2>
<p><strong>问题: 以下代码只注释掉 ② 输出什么？如果只注释 ① 又输出什么?</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    a := [2]int{5, 6}
    b := [2]int{5, 6}

    // ①
    if a == b {
        fmt.Println("equal")
    } else {
        fmt.Println("not equal")
    }

    // ②
    // if a[:] == b[:] {
    //     fmt.Println("equal")
    // } else {
    //     fmt.Println("not equal")
    // }
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">  array是可以比较的,slice是不可以比较的.
  所以:
    ①为equal
    ②为编译不通过
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p><code>array</code>是可以比较的,必须要求一样数组大小才可以比较,且len和cap是一样的.
<code>slice</code>不可直接比较,只可以与nil比较.</p>
</blockquote>
<h2 id="3-nil的chan"><a class="header" href="#3-nil的chan">3. <code>nil</code>的<code>chan</code></a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

func main() {
    var ch chan int
    select {
    case v, ok := &lt;-ch:
        println(v, ok)
    default:
        println("default")
    }
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">输出: 
    default
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>一个nil的chan是永远不会被select到,<br />
一个nil的chan发送和接收会永远的阻塞<br />
关闭的chan永远能select到</p>
</blockquote>
<h2 id="4-传值共享slice"><a class="header" href="#4-传值共享slice">4. 传值共享slice</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

import "fmt"

type T struct {
    ls []int
}

func foo(t T) {
    t.ls[0] = 100
}

func main() {
    var t = T{
        ls: []int{1, 2, 3},
    }

    foo(t)
    fmt.Println(t.ls[0])
}

</code></pre>
<ul>
<li>A. 1</li>
<li>B. 100</li>
<li>C. compilation error</li>
</ul>
<p><strong>解答</strong>: 输出B</p>
<p><strong>解析</strong>:</p>
<blockquote>
<p>调用<code>foo()</code>函数时虽然是传值，但<code>foo()</code>函数中，字段<code>ls</code>依旧可以看成是指向底层数组的指针。</p>
</blockquote>
<h2 id="5-不可寻址的临时变量"><a class="header" href="#5-不可寻址的临时变量">5. 不可寻址的临时变量</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

type X struct{}

func (x *X) test() {
    println(x)
}

func main() {
    var a *X
    a.test()

    // X{}.test()
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">    但是nil是可以调用方法的
    X{} 是不可寻址的，不能直接调用方法
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>在方法中，指针类型的接收者必须是合法指针（包括 nil）,或能获取实例地址。</p>
</blockquote>
<h2 id="6-切片截取问题"><a class="header" href="#6-切片截取问题">6. 切片截取问题</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    s := make([]int, 3, 9)
    fmt.Println(len(s))
    s2 := s[4:8]
    fmt.Println(len(s2))
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">    3
    4
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>从一个基础切片派生出的子切片的长度可能大于基础切片的长度。<br />
假设基础切片是 baseSlice，使用操作符 [low,high]，有如下规则：0 &lt;= low &lt;= high &lt;= cap(baseSlice)，<br />
只要上述满足这个关系，下标 low 和 high 都可以大于 len(baseSlice)。</p>
</blockquote>
<h2 id="7-方法值传递"><a class="header" href="#7-方法值传递">7. 方法值传递</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

import "fmt"

type N int

func (n N) test() {
    fmt.Println(n)
}

func main() {
    var n N = 10
    p := &amp;n

    n++
    f1 := n.test

    n++
    f2 := p.test

    n++
    fmt.Println(n)

    f1()
    f2()
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">13
11
12
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>知识点：方法值。<br />
当指针值赋值给变量或者作为函数参数传递时，会立即计算并复制该方法执行所需的接收者对象，与其绑定，以便在稍后执行时，能隐式第传入接收者参数。</p>
</blockquote>
<h2 id="8-方法指针传递"><a class="header" href="#8-方法指针传递">8. 方法指针传递</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

import "fmt"

type N int

func (n *N) test() {
    fmt.Println(*n)
}

func main() {
    var n N = 10

    n++
    f1 := n.test

    n++
    f2 := n.test

    n++
    fmt.Println(n)

    f1()
    f2()
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">13
13
13
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>传入的为指针,所以值为最后的结果值</p>
</blockquote>
<h2 id="9-切片截取问题"><a class="header" href="#9-切片截取问题">9. 切片截取问题</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

func main() {
    x := make([]int, 2, 10)
    _ = x[6:10]
    _ = x[2:]
    _ = x[6:]
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">    _ = x[6:] 将panic
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>_ = x[6:] 在截取符号 [i:j]，如果 j 省略，默认是原切片或者数组的长度,即len(x)，x 的长度是 2，小于起始下标 6 ，所以 panic。</p>
</blockquote>
<h2 id="10-空struct内存对齐"><a class="header" href="#10-空struct内存对齐">10. 空struct内存对齐</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<pre><code class="language-go">package main

import (
    "fmt"
    "unsafe"
)

type demo0 struct {
    b int32
    c int32
    a struct{}
}

type demo1 struct {
    a struct{}
    b int32
    c int32
}

type demo2 struct {
    b int32
    a struct{}
    c int32
}

func main() {
    fmt.Println(unsafe.Sizeof(demo0{}), unsafe.Sizeof(demo1{}), unsafe.Sizeof(demo2{}))
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text"> 12 8 8 
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>空 <code>struct{}</code> 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。<br />
但是有一种情况除外：即当 <code>struct{}</code> 作为结构体最后一个字段时，需要内存对齐。
因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。</p>
</blockquote>
<h2 id="11-len内置函数"><a class="header" href="#11-len内置函数">11. len内置函数</a></h2>
<p><strong>问题: 代码输出什么?</strong></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651442060&amp;idx=2&amp;sn=29a3f39ec2d95d6b5177e53277c5f94c&amp;chksm=80bb157eb7cc9c68f9b2574cb259678580b194cf20d83d84840818bae9712fe3e0246e249a97&amp;mpshare=1&amp;scene=24&amp;srcid=1130fgz3Kg9VvJpRLR3OLUVS&amp;sharer_sharetime=1606715319571&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AZIxDLHvvkwjXPkmuEeWCtI%3D&amp;pass_ticket=xSGb7TkoIuLZz7AFBdlYeR4qEQC4h9uTHgeYZjnzNlVCg1RDSSP3MJjeOxdI2wvs&amp;wx_header=0#rd">原文</a></p>
<pre><code class="language-go">package main

const s = "Go101.org"

// len(s) == 9
// 1 &lt;&lt; 9 == 512
// 512 / 128 == 4

var a byte = 1 &lt;&lt; len(s) / 128
var b byte = 1 &lt;&lt; len(s[:]) / 128

func main() {
    println(a, b)
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">4 0
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p><strong>a. 常量与求值</strong><br />
当参数是字符串字面量和简单 array 表达式，len 函数返回值是常量.</p>
<blockquote>
<p>内置函数 len 和 cap 获取各种类型的实参并返回一个 int 类型结果。实现会保证结果总是一个 int 值。</p>
<ul>
<li>如果 s 是一个字符串常量，那么 len(s) 是一个常量 。</li>
<li>如果 s 类型是一个数组或到数组的指针且表达式 s 不包含 信道接收 或（非常量的） 函数调用的话， 那么表达式 len(s) 和 cap(s) 是常量；这种情况下， s 是不求值的。</li>
<li>否则的话， len 和 cap 的调用结果不是常量且 s 会被求值
所以<code>len(s)</code>与<code>len(s[:])</code>前者返回是常量,后者是求值的值</li>
</ul>
</blockquote>
<p><strong>b. 位移</strong></p>
<blockquote>
<p>在位移表达式的右侧的操作数必须为整数类型，或者可以被 uint 类型的值所表示的无类型的常量。</p>
<ul>
<li>
<p>如果<strong>一个<code>非常量位移表达式的左侧</code>的操作数是一个无类型常量</strong>，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。</p>
</li>
<li>
<p>如果**<code>常量位移表达式 的左侧</code>的操作数是一个无类型常量**，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量</p>
</li>
</ul>
</blockquote>
<p>因此对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code>是<em><strong>一个常量位移表达式</strong></em>，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</p>
<p>而对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 1281</code>，因为 <code>1 &lt;&lt; len(s[:])</code>是一个<em><strong>非常量位移表达式</strong></em>，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类号常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型.
即1为byte型,右移溢出,所以为0</p>
</blockquote>
<h2 id="12-补码"><a class="header" href="#12-补码">12. 补码</a></h2>
<p><strong>问题: 代码输出什么?</strong><br />
<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651442141&amp;idx=2&amp;sn=1e565dd411fb82584a7093f40a750be2&amp;chksm=80bb152fb7cc9c390add4b13d217984bd3334ea9bbb1b45357c6d979b9d37499fb8cf9e26004&amp;mpshare=1&amp;scene=24&amp;srcid=1130xlWjBiMct2BMLtmpjm5S&amp;sharer_sharetime=1606715340255&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=Aa%2Fz3pSgi%2B5meJijFHg1ppE%3D&amp;pass_ticket=xSGb7TkoIuLZz7AFBdlYeR4qEQC4h9uTHgeYZjnzNlVCg1RDSSP3MJjeOxdI2wvs&amp;wx_header=0#rd">原文</a></p>
<pre><code class="language-go">package main

func main() {
    // // 题1
    var a int8 = -1
    var b int8 = -128 / a
    println(b)

    // 题2
    // const c int8 = -1
    // var d int8 = -128 / c
    // println(d)
}
</code></pre>
<p><strong>解答</strong>:</p>
<pre><code class="language-text">    题1: -128
    题2: 编译错误
</code></pre>
<p><strong>解析</strong>:</p>
<blockquote>
<p>const隐式转换不允许溢出,所以编译错误</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能优化pprof"><a class="header" href="#性能优化pprof">性能优化pprof</a></h1>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651438010&amp;idx=5&amp;sn=9641a1dcc64b4d7b6b228c54b3da9834&amp;chksm=80bb6548b7ccec5ef4760cfe32599568c133d97a311c0eab113f14ceecaeaa3f53a07dc0f488&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1593169627588&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AR4ME0Tlj8P7jxFrwP7KfPs%3D&amp;pass_ticket=DDvVwMc9uE8gubEQ4Udh%2F7K9IzRY%2FCbcirMDYkaFdBlrl2%2B2VHn%2BmCXuaTNKOfGb#rd">值得收藏深度解密系列: Go语言之 pprof</a></li>
<li><a href="https://segmentfault.com/a/1190000019222661">实战Go内存泄露</a></li>
<li><a href="https://blog.wolfogre.com/posts/go-ppof-practice/">wolfogre 非常精彩的实战文章</a></li>
<li><a href="https://github.com/brendangregg/FlameGraph">FlameGraph: Stack trace visualizer</a></li>
<li><a href="https://github.com/google/pprof">google pprof</a></li>
<li><a href="https://git.io/JfYMW">如何读懂pprof grap</a></li>
<li><a href="https://mmcloughlin.com/posts/your-pprof-is-showing">pprof暴露的风险</a></li>
</ul>
<h2 id="1-shell内置time指令"><a class="header" href="#1-shell内置time指令">1. shell内置time指令</a></h2>
<p>使用<code>time ./test</code>对执行程序做了性能分析, 得到3个指标.</p>
<ul>
<li><code>real</code>: 从程序开始到结束, 实际度过的时间；</li>
<li><code>user</code>: 程序在<strong>用户态</strong>度过的时间；</li>
<li><code>sys</code>: 程序在<strong>内核态</strong>度过的时间.</li>
</ul>
<p>一般情况下 <code>real</code> <strong>&gt;=</strong> <code>user</code> + <code>sys</code>, 因为系统还有其它进程(切换其他进程中间对于本进程会有空白期).</p>
<h2 id="2-usrbintime指令"><a class="header" href="#2-usrbintime指令">2 /usr/bin/time指令</a></h2>
<blockquote>
<p>这个指令比内置的time更加详细一些, 使用的时候需要用绝对路径, 而且要加上参数<code>-v</code></p>
<ul>
<li>CPU占用率；</li>
<li>内存使用情况；</li>
<li>Page Fault 情况；</li>
<li>进程切换情况；</li>
<li>文件系统IO；</li>
<li>Socket 使用情况</li>
<li>...</li>
</ul>
</blockquote>
<pre><code class="language-shell">$ /usr/bin/time -v ./test

    Command being timed: "./test"
    User time (seconds): 0.12
    System time (seconds): 0.06
    Percent of CPU this job got: 115%
    Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.16
    Average shared text size (kbytes): 0
    Average unshared data size (kbytes): 0
    Average stack size (kbytes): 0
    Average total size (kbytes): 0
    Maximum resident set size (kbytes): 41172
    Average resident set size (kbytes): 0
    Major (requiring I/O) page faults: 1
    Minor (reclaiming a frame) page faults: 15880
    Voluntary context switches: 897
    Involuntary context switches: 183
    Swaps: 0
    File system inputs: 256
    File system outputs: 2664
    Socket messages sent: 0
    Socket messages received: 0
    Signals delivered: 0
    Page size (bytes): 4096
    Exit status: 0
</code></pre>
<h2 id="3-pprof"><a class="header" href="#3-pprof">3. pprof</a></h2>
<p>pprof 支持四种类型的分析:</p>
<ul>
<li><code>CPU</code>: <code>CPU</code>分析, 采样消耗cpu的调用, 这个一般用来定位排查程序里耗费计算资源的地方；</li>
<li><code>Memory</code>: 内存分析, 在应用程序进行堆分配时记录堆栈跟踪, 用于监视当前和历史内存使用情况, 以及检查内存泄漏;</li>
<li><code>Block</code>: 阻塞分析, 记录 goroutine 阻塞等待同步 (包括定时器通道) 的位置</li>
<li><code>Mutex</code>: 互斥锁分析, 采样互斥锁的竞争情况；</li>
</ul>
<p>明确几个重要的点:</p>
<ul>
<li>golang 内存<code>pprof</code>是采样的, 每512KB采样一次；</li>
<li>golang 的内存采样的是堆栈路径, 而不是类型信息；</li>
<li>golang 的内存采样入口一定是通过<code>mProf_Malloc</code>, <code>mProf_Free</code> 这两个函数.所以, 如果是 cgo 分配的内存, 那么是没有机会调用到这两个函数的, 所以如果是 cgo 导致的内存问题, <code>go tool pprof</code>是分析不出来的；</li>
</ul>
<h2 id="31-pprof的作用"><a class="header" href="#31-pprof的作用">3.1. pprof的作用</a></h2>
<p><code>pprof</code> 是 Go 语言中可视化和分析程序运行性能的工具.
pprof 以 <a href="https://github.com/google/pprof/blob/master/proto/profile.proto">profile.proto</a> 读取分析样本的集合, 并生成报告以可视化并帮助分析数据 (支持文本和图形报告).
<code>profile.proto</code> 是一个 <code>Protocol Buffer v3</code> 的描述文件, 它描述了一组 <code>callstack</code> 和 <code>symbolization</code> 信息,  作用是表示统计分析的一组采样的调用栈, 是很常见的 <code>stacktrace</code> 配置文件格式.</p>
<p>它能提供各种性能数据:</p>
<p><img src="golang/../assets/go-pprof-data.webp" alt="img" /></p>
<blockquote>
<p><code>allocs</code> 和 <code>heap</code> 采样的信息一致, 不过前者是所有对象的内存分配, 而 <code>heap</code> 则是活跃对象的内存分配.
关于 goroutine 的信息有两个链接,</p>
<ul>
<li><code>goroutine</code> : 一个汇总的消息, 可以查看 goroutines 的总体情况</li>
<li><code>full goroutine stackdump</code>可以看到每一个 goroutine 的状态.</li>
</ul>
<ol>
<li>CPU Profiling: 当 CPU 性能分析启用后, Go runtime 会每 10ms 就暂停一下, 记录当前运行的 goroutine 的调用堆栈及相关数据.当性能分析数据保存到硬盘后, 我们就可以分析代码中的热点了.</li>
<li>Memory Profiling: 内存性能分析则是在堆 (Heap) 分配的时候, 记录一下调用堆栈.默认情况下, 是每 1000 次分配, 取样一次, 这个数值可以改变.栈(Stack)分配, 由于会随时释放, 因此不会被内存分析所记录. 由于内存分析是取样方式, 并且也因为其记录的是分配内存, 而不是使用内存. 因此使用内存性能分析工具来准确判断程序具体的内存使用是比较困难的.</li>
<li>Block Profiling: 阻塞分析是一个很独特的分析, 它有点儿类似于 CPU 性能分析, 但是它所记录的是 goroutine 等待资源所花的时间.阻塞分析对分析程序并发瓶颈非常有帮助, 阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了.阻塞性能分析是特殊的分析工具, 在排除 CPU 和内存瓶颈前, 不应该用它来分析.</li>
<li>Mutex Profiling: 互斥锁分析, 报告互斥锁的竞争情况</li>
</ol>
</blockquote>
<h3 id="311-如何使用"><a class="header" href="#311-如何使用">3.1.1 如何使用</a></h3>
<ul>
<li>
<p><code>runtime/pprof</code>: 采集程序(非Server)的运行数据进行分析, 主要针对只跑一次的程序, 具体查看<code>runtime/pprof</code>相关api</p>
</li>
<li>
<p><code>net/http/pprof</code>: 采集程序(Server)的运行时数据进行分析, 可提供一个HTTP接口</p>
<blockquote>
<p><code>http://localhost:8080/debug/pprof/</code>进入浏览器页面,查看相关的汇总信息</p>
</blockquote>
</li>
</ul>
<h3 id="312-分析"><a class="header" href="#312-分析">3.1.2 分析</a></h3>
<p>example:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "math/rand"
    "net/http"
    "os"
    "strconv"
    "time"

    _ "net/http/pprof"
)

func main() {
    fmt.Println(os.Getpid())
    fmt.Println("http://localhost:8080/debug/pprof")
    go func() {
        http.ListenAndServe(":8080", nil)
    }()
    // busy working....
    // Force the GC to work to make the plots "move".
    m := map[string][]byte{}

    for {
        b := make([]byte, 512+rand.Intn(16*1024))
        m[strconv.Itoa(len(m)%(10*100))] = b

        if len(m)%(10*100) == 0 {
            m = make(map[string][]byte)
        }

        time.Sleep(10 * time.Millisecond)
    }
}
</code></pre>
<h4 id="通过命令交互分析"><a class="header" href="#通过命令交互分析">通过命令交互分析</a></h4>
<ul>
<li>通过得到profile文件直接进入分析</li>
</ul>
<pre><code class="language-shell">go tool pprof ./profile
</code></pre>
<ul>
<li>通过url地址直接进入分析</li>
</ul>
<pre><code class="language-shell"># 下载 cpu profile, 默认从当前开始收集 30s 的 cpu 使用情况, 需要等待 30s
go tool pprof http://localhost:8080/debug/pprof/profile
# wait 120s
go tool pprof http://localhost:8080/debug/pprof/profile?seconds=120     
# 下载 heap profile
go tool pprof http://localhost:8080/debug/pprof/heap
# 切换内存分析的类型
go tool pprof -sample_index=alloc_space http://localhost:8080/debug/pprof/heap
# 下载 goroutine profile
go tool pprof http://localhost:8080/debug/pprof/goroutine
# 下载 block profile
go tool pprof http://localhost:8080/debug/pprof/block
# 下载 mutex profile
go tool pprof http://localhost:8080/debug/pprof/mutex
</code></pre>
<p>命令行支持命令:</p>
<ul>
<li><code>callgrind</code>: <code>callgrind</code>格式主要用于<code>KCachegrind</code>工具, 可视化分析函数调用和执行情况.</li>
<li><code>comments</code>: 输出所有的profile注释信息, 帮助开发者了解和记录性能分析的元数据.</li>
<li><code>disasm</code>: 输出带有采样注释的汇编代码列表.此功能对于需要深入了解程序在汇编级别的性能表现非常有用.</li>
<li><code>dot</code>: 生成DOT格式的图表. DOT格式是一种图形描述语言, 可以用于<code>Graphviz</code>工具, 进行复杂的图形可视化.</li>
<li><code>eog</code>: 通过eog工具可视化图表.此命令将生成的图表直接在eog中打开.</li>
<li><code>evince</code>: 通过evince工具可视化图表, 与eog类似, 但使用的是Evince文档查看器.</li>
<li><code>gif</code>: 生成GIF格式的图像, 便于在网页和报告中嵌入性能分析图表.</li>
<li><code>gv</code>: 通过gv工具可视化图表. gv是一个基于X11的PostScript和PDF查看器.</li>
<li><code>kcachegrind</code>: 在<code>KCachegrind</code>工具中可视化报告. <code>KCachegrind</code>是一个强大的性能分析工具, 特别适用于处理<code>callgrind</code>格式的文件.</li>
<li><code>list</code>: 输出与正则表达式匹配的函数的注释源代码, 帮助开发者直接在源代码级别查看性能瓶颈.</li>
<li><code>pdf</code>: 生成PDF格式的图表, 便于打印和分享</li>
<li><code>peek</code>: 输出与正则表达式匹配的函数的调用者和被调用者信息</li>
<li><code>png</code>: 生成PNG格式的图像, 与GIF类似, 但适用于需要高质量静态图像的场景.</li>
<li><code>proto</code>: 以压缩protobuf格式输出profile数据.这种格式适用于数据交换和存储.</li>
<li><code>ps</code>: 生成PostScript格式的图表, 便于高质量打印.</li>
<li><code>raw</code>: 输出原始profile数据的文本表示, 用于深入分析或自定义处理.</li>
<li><code>svg</code>: 生成SVG格式的图像, 适用于需要矢量图形的场景, 如网页嵌入和缩放显示</li>
<li><code>tags</code>: 输出profile中的所有标签信息, 帮助开发者了解和筛选性能数据</li>
<li><code>text</code>: 以文本形式输出主要的性能数据条目, 便于快速查看和分析.</li>
<li><code>top</code>: 以文本形式输出性能数据的主要条目, 类似于Linux中的top命令, 帮助开发者快速定位性能热点.</li>
<li><code>topproto</code>: 以压缩protobuf格式输出主要的性能数据条目, 结合了top和proto命令的功能.</li>
<li><code>traces</code>: 以文本形式输出所有的profile样本数据, 适用于详细的逐样本分析.</li>
<li><code>tree</code>: 以文本形式输出调用图, 帮助开发者以树形结构查看函数调用关系.</li>
<li><code>web</code>: 通过默认的网页浏览器可视化图表, 使得性能分析结果更易于共享和展示.</li>
<li><code>weblist</code>: 在网页浏览器中显示带注释的源代码, 与list命令类似, 但提供了更友好的界面.</li>
</ul>
<h4 id="通过可视化界面需要graphviz支持"><a class="header" href="#通过可视化界面需要graphviz支持">通过可视化界面(需要<code>graphviz</code>支持)</a></h4>
<pre><code class="language-shell">go tool pprof -http=:8080 cpu.prof
</code></pre>
<p>或者</p>
<pre><code class="language-shell">go tool pprof cpu.prof
(pprof) web
</code></pre>
<p>相关参数</p>
<ul>
<li>profile
<ul>
<li><code>flat</code>: 本函数的执行耗时</li>
<li><code>flat%</code>: flat占CPU总时间的比例</li>
<li><code>sum%</code>: 本函数累积使用CPU总比例</li>
<li><code>cum</code>: 本函数加上调用的函数总耗时</li>
<li><code>cum%</code>: cum占CPU总时间的比例</li>
</ul>
</li>
<li>heap的flat, sum, cum与上面类似, 只不过计算的是内存大小
<ul>
<li><code>-inuse_space</code>: 分析应用程序的常驻内存占用情况</li>
<li><code>-alloc_objects</code>: 分析应用程序的内存临时分配情况</li>
</ul>
</li>
</ul>
<p>在 <code>cpu profile</code> 中, 一个是方法运行的时间占比, 一个是它在采样的堆栈中出现的时间占比 (前者是 <code>flat</code> 时间, 后者则是 <code>cum</code> 时间占比); 框越大, 代表耗时越多或是内存分配越多.</p>
<h4 id="解读调用图"><a class="header" href="#解读调用图">解读调用图</a></h4>
<ul>
<li>节点颜色:
<ul>
<li>大的正<code>cum</code>为红色.</li>
<li>大的负<code>cum</code>为绿色, 负值最有可能出现在剖面比较中</li>
<li><code>cum</code>接近零为灰色</li>
</ul>
</li>
<li>节点字体大小:
<ul>
<li>字体大小越大, 表示<code>flat</code>绝对值越大.</li>
<li>字体大小越小, 表示<code>flat</code>绝对值越小.</li>
</ul>
</li>
<li>边权重:
<ul>
<li>边越厚, 表示在该路径上使用的资源越多.</li>
<li>边越细, 表示在该路径上使用的资源越少.</li>
</ul>
</li>
<li>边颜色:
<ul>
<li>大的正值为红色</li>
<li>大的负值为绿色</li>
<li>接近于零为灰色</li>
</ul>
</li>
<li>虚线边: 删除了两个相连位置之间的一些位置.</li>
<li>实线边, 两个相连位置是直接相关.</li>
<li><code>(inline)</code>边标记: 调用已内联到调用程序中.</li>
</ul>
<h2 id="32-火焰图"><a class="header" href="#32-火焰图">3.2 火焰图</a></h2>
<p>可视化界面已经支持火焰图(Flame Graph),位于VIEW/Flame Graph下.更老版本pprof不支持<code>-http</code>参数的,可以下载其它库来支持火焰图<code>github.com/google/pprof</code>或者<code>github.com/uber/go-torch</code></p>
<p>如何读懂火焰图可看: 阮一峰的<a href="http://www.ruanyifeng.com/blog/2017/09/flame-graph.html">如何读懂火焰图</a></p>
<h2 id="4-性能分析注意事项"><a class="header" href="#4-性能分析注意事项">4. 性能分析注意事项</a></h2>
<h3 id="41-性能分析必须在一个可重复的稳定的环境中来进行"><a class="header" href="#41-性能分析必须在一个可重复的稳定的环境中来进行">4.1 性能分析必须在一个<strong>可重复的</strong>、<strong>稳定的</strong>环境中来进行</a></h3>
<ul>
<li>
<p>不要在共享硬件上进行性能分析;</p>
</li>
<li>
<p>不要在性能分析期间, 在同一个机器上去浏览网页</p>
</li>
<li>
<p>机器必须闲置</p>
</li>
<li>
<p>注意省电模式和过热保护, 如果突然进入这些模式, 会导致分析数据严重不准确</p>
</li>
<li>
<p><strong>不要使用虚拟机、共享的云主机</strong>, 太多干扰因素, 分析数据会很不一致；</p>
</li>
<li>
<p>关闭电源管理、过热管理;</p>
</li>
<li>
<p>绝不要升级, 以保证测试的一致性, 以及具有可比性</p>
</li>
</ul>
<blockquote>
<p>如果承受得起, 购买专用的性能测试分析的硬件设备, 上架</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang跟踪剖析trace"><a class="header" href="#golang跟踪剖析trace">golang跟踪剖析trace</a></h1>
<ul>
<li><a href="https://docs.google.com/document/u/0/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub?pli=1">Go Execution Tracer</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDQxMDMyNg==&amp;mid=2247484297&amp;idx=1&amp;sn=7a01fa4f454189fc3ccdb32a6e0d6897&amp;scene=21#wechat_redirect">深入浅出Go语言执行跟踪</a></li>
</ul>
<p>该工具是Go 1.5版本加入的, 通过度量go语言特定事件的运行时, 例如：</p>
<ul>
<li>创建, 启动和终止goroutines</li>
<li>阻塞/非阻塞goroutines(syscalls, channels, locks)</li>
<li>网络 I/O</li>
<li>Syscalls</li>
<li>垃圾回收</li>
</ul>
<h2 id="1-trace概览"><a class="header" href="#1-trace概览">1. Trace概览</a></h2>
<pre><code class="language-go">package main

import (
    "os"
    "runtime/trace"
)

func main() {
    trace.Start(os.Stderr)
    defer trace.Stop()
    // create new channel of type int
    ch := make(chan int)

    // start new anonymous goroutine
    go func() {
        // send 42 to channel
        ch &lt;- 42
    }()
    // read from channel
    &lt;-ch
}
</code></pre>
<p>执行<code>go run main.go 2&gt; trace.out</code> 运行这段代码会发送trace数据到trace.out, 之后可以用<code>go tool trace trace.out</code>读取trace.启动一个web,默认是127.0.0.1地址的一个随机端口, 可以修改host进行指定.</p>
<h2 id="2-选项"><a class="header" href="#2-选项">2. 选项</a></h2>
<ul>
<li>
<p><strong>View trace</strong>: 最复杂、最强大和交互式的可视化显示了整个程序执行的时间轴.这个视图显示了在每个虚拟处理器上运行着什么, 以及什么是被阻塞等待运行的.稍后我们将在这篇文章中深入探讨这个视图.注意它只能在chrome上显示.</p>
</li>
<li>
<p><strong>Goroutine analysis</strong>: 显示了在整个执行过程中, 每种类型的goroutines是如何创建的.在选择一种类型之后就可以看到关于这种类型的goroutine的信息.例如, 在试图从mutex获取锁、从网络读取、运行等等每个goroutine被阻塞的时间.</p>
</li>
<li>
<p><strong>Network/Sync/Syscall blocking profile</strong>: 这些图表显示了goroutines在这些资源上所花费的时间.它们非常接近pprof上的内存/cpu分析.这是分析锁竞争的最佳选择.</p>
</li>
<li>
<p><strong>Scheduler latency profiler</strong>: 为调度器级别的信息提供计时功能, 显示调度在哪里最耗费时间.</p>
</li>
</ul>
<h3 id="21-view-trace"><a class="header" href="#21-view-trace">2.1 View trace</a></h3>
<p><img src="golang/../assets/go-trace1.png" alt="go-trace" /></p>
<ol>
<li>Timeline: 显示执行的时间, 根据跟踪定位的不同, 时间单位可能会发生变化.你可以通过使用键盘快捷键(WASD键)来导航时间轴.</li>
<li>Goroutines: 在每个时间点显示有多少goroutines在运行, 有多少是可运行的(等待被调度的).大量可运行的goroutines可能显示调度竞争, 例如, 当程序创建过多的goroutines, 会导致调度程序繁忙.</li>
<li>Heap: 在执行期间显示内存分配, 这对于发现内存泄漏非常有用, 并检查垃圾回收在每次运行时能够释放多少内存.</li>
<li>OS Threads: 显示有多少OS线程正在被使用, 有多少个被syscalls阻塞.</li>
<li>Virtual Processors<br />
每个虚拟处理器显示一行.虚拟处理器的数量由<code>GOMAXPROCS</code>环境变量控制(默认为内核数).</li>
<li>Goroutines and events<br />
显示在每个虚拟处理器上有什么goroutine在运行.连接goroutines的连线代表事件.在示例图片中, 我们可以看到goroutine "G1.runtime.main"衍生出了两个不同的goroutines:G10和G7(前者是负责收集trace数据的goroutine, 后者是我们使用"go"关键字启动的那个).每个处理器的第二行可能显示额外的事件, 比如syscalls和运行时事件.这还包括goroutine代表运行时所做的一些工作(例如辅助垃圾回收).下图显示了当选择一个goroutine时得到的信息.</li>
</ol>
<p><img src="golang/../assets/go-trace-goroutine.png" alt="go trace goroutine" /></p>
<p>该信息包含：</p>
<ul>
<li>它的"名称"(Title)</li>
<li>何时开始(Start)</li>
<li>持续时间(Wall Duration)</li>
<li>开始时的栈trace</li>
<li>结束时的栈trace</li>
<li>该goroutine产生的事件</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql读书笔记"><a class="header" href="#mysql读书笔记">mysql读书笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一-mysql基本操作"><a class="header" href="#一-mysql基本操作">一. mysql基本操作</a></h1>
<ul>
<li><code>mysql -h $ip -P $port -u $user -p</code> # 登录</li>
<li><code>show processlist;</code>  # 查看连接状态</li>
<li><code>show variables like 'transaction_isolation';</code> # 查看所有变量</li>
<li><code>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60;</code> 查找持续时间超过 60s 的事务</li>
<li><code>explain select * from t where between 10000 and 20000 limit 1000;</code>#  解释这条语句执行行为.</li>
<li><code>show index from t;</code># 显示表t索引</li>
<li><code>alter table t add index idx_name(email);</code># 增加表t索引</li>
<li><code>analyze table t;</code> # 当索引的统计信息不正确时, 可重建统计索引信息.</li>
<li><code>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</code> # 设置innodb_io_capacity 这个参数了, 告诉 InnoDB 你的磁盘能力</li>
<li><code>set log_query_time=0</code> 将慢查询日志的阈值设置为 0, 表示这个线程接下来的语句都会被记录入慢查询日志中；</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二-mysql是如何执行的"><a class="header" href="#二-mysql是如何执行的">二. mysql是如何执行的</a></h1>
<h2 id="1-mysql-的逻辑架构图"><a class="header" href="#1-mysql-的逻辑架构图">1. MySQL 的逻辑架构图</a></h2>
<p><img src="mysql/../assets/202110281013644.png" alt="img" /></p>
<ul>
<li>Server层: 包括<strong>连接器</strong>、<strong>查询缓存</strong>、<strong>分析器</strong>、<strong>优化器</strong>、<strong>执行器</strong>等, 涵盖 MySQL 的大多数核心服务功能, 以及所有的内置函数(如日期、时间、数学和加密函数等), 所有跨存储引擎的功能都在这一层实现, 比如存储过程、触发器、视图等</li>
<li>存储引擎层: <strong>负责数据的存储和提取</strong>。其架构模式是插件式的, 支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 <em>InnoDB</em>, 它从 MySQL 5.5.5 版本开始成为了默认存储引擎.</li>
</ul>
<p><strong>大多数情况下我会建议你不要使用查询缓存, 因为查询缓存往往弊大于利</strong> (注意: <em>mysql8.0</em>版本已没有查询缓存功能.)</p>
<h2 id="2-日志模块"><a class="header" href="#2-日志模块">2. 日志模块</a></h2>
<ul>
<li><strong>InnoDB引擎</strong>的<code>redo log</code>: 物理日志,固定大小文件(一组<code>4</code>个文件,每个文件的大小是<code>1GB</code>),循环写的,可配置,当发生日志满时,将发生写盘事件. 保证服务器发生异常重启,还能保证记录不丢失,<strong>crash-safe</strong>能力</li>
<li><strong>Server层</strong>日志<code>binlog</code>(归档日志): 逻辑日记,追加写入的.</li>
</ul>
<blockquote>
<ul>
<li><code>redo log</code>是 InnoDB 引擎特有的；<code>binlog</code> 是 MySQL 的 Server 层实现的, 所有引擎都可以使用。</li>
<li><code>redo log</code> 是物理日志, 记录的是“在某个数据页上做了什么修改”；<code>binlog</code> 是逻辑日志, 记录的是这个语句的原始逻辑, 比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li><code>redo log</code> 是循环写的, 空间固定会用完；<code>binlog</code>是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个, 并不会覆盖以前的日志。</li>
</ul>
</blockquote>
<p>日志的配置:</p>
<ul>
<li>
<p><code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候, 表示每次事务的 redo log 都直接持久化到磁盘</p>
</li>
<li>
<p><code>sync_binlog</code> 这个参数设置成 1 的时候, 表示每次事务的 binlog 都持久化到磁盘</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三-深入索引全局锁表锁行锁"><a class="header" href="#三-深入索引全局锁表锁行锁">三. 深入索引全局锁表锁行锁</a></h1>
<ul>
<li><code>DML</code>: <strong>Data Manipulation Language</strong>(数据操纵语言) 增删改数据</li>
<li><code>DDL</code>: <strong>Data Definition Language</strong>(数据定义语言) 加字段等 修改表结构的操作</li>
</ul>
<h2 id="1-索引"><a class="header" href="#1-索引">1. 索引</a></h2>
<ul>
<li>
<p>数据库的底层存储的核心是基于数据模型,从理论上分析这个数据库的适用场景,这个数据库.<strong>用<code>N叉树</code>的原因是减少访问磁盘数据块,树中的“N”取决于数据块的大小。</strong></p>
</li>
<li>
<p>每一个索引在 <code>InnoDB</code> 里面对应一棵 <code>B+树</code>。</p>
<ul>
<li>
<p>主键索引的叶子节点存的是<em><strong>整行数据</strong></em>。在 <code>InnoDB</code> 里, <strong>主键索引</strong>也被称为<strong>聚簇索引（clustered index）</strong>。</p>
</li>
<li>
<p>非主键索引的叶子节点内容是<em><strong>主键的值</strong></em>。在 <code>InnoDB</code> 里, <strong>非主键索引</strong>也被称为<strong>二级索引（secondary index）</strong>。</p>
<blockquote>
<p>基于主键索引和普通索引的查询有什么区别？</p>
<ul>
<li>如果语句是 select * from T where ID=500, 即主键查询方式, 则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 select * from T where k=5, 即普通索引查询方式, 则需要先搜索 k 索引树, 得到 ID 的值为 500, 再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>覆盖索引</strong>: 索引 k 已经“覆盖了”我们的查询需求, 由于覆盖索引可以减少树的搜索次数, 显著提升查询性能, 所以使用<strong>覆盖索引</strong>是一个常用的性能优化手段</p>
</li>
<li>
<p><strong>最左前缀原则</strong>,不只是索引的全部定义,只要满足最左前缀.</p>
<ul>
<li>第一原则是, 如果通过调整顺序, 可以少维护一个索引, 那么这个顺序往往就是需要优先考虑采用的.(当已经有了 (a,b) 这个联合索引后, 一般就不需要单独在 a 上建立索引了)</li>
<li>考虑的原则就是空间.</li>
</ul>
</li>
<li>
<p><strong>索引下推优化</strong>: 可以在索引遍历过程中, 对索引中包含的字段先做判断, 直接过滤掉不满足条件的记录, 减少回表次数。</p>
</li>
</ul>
<blockquote>
<p><strong>页分裂</strong>: 主要是插入一条新记录时, 所在的页数据已经满了, 需要新申请新的数据页,然后挪动部份数据过去. 不仅影响性能,还影响页的利用率.</p>
<p><strong>页分裂逆过程</strong>: 当相邻两个页由于删除了数据, 利用率很低后, 会将数据页做合并.</p>
<p><em><strong>NOTE</strong></em>: 主键顺序递增能有效的防止页分裂.</p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="四-数据库的锁"><a class="header" href="#四-数据库的锁">四. 数据库的锁</a></h1>
<h2 id="1-全局锁表锁行锁"><a class="header" href="#1-全局锁表锁行锁">1. 全局锁,表锁,行锁</a></h2>
<h3 id="11-全局锁"><a class="header" href="#11-全局锁">1.1. 全局锁</a></h3>
<p><strong>全局锁</strong>就是<strong>对整个数据库实例加锁</strong>,MySQL 提供了一个加全局读锁的方法, 命令是 <code>Flush tables with read lock (FTWRL)</code>,整个库处于只读状态.</p>
<p><strong>全局锁的典型使用场景</strong>是, 做全库逻辑备份。也就是把整库每个表都 select 出来存成文本.</p>
<blockquote>
<p>官方自带的逻辑备份工具是 <code>mysqldump</code>。当 <code>mysqldump</code> 使用参数<code>–single-transaction</code> 的时候, 导数据之前就会启动一个事务, 来确保拿到一致性视图.</p>
<p>**一致性读是好, 但前提是引擎要支持这个隔离级别。**对于 MyISAM 这种不支持事务的引擎, 如果备份过程中有更新, 总是只能取到最新的数据, 那么就破坏了备份的一致性。这时, 我们就需要使用 FTWRL 命令了</p>
<p><strong>--single-transaction 方法只适用于所有的表使用事务引擎的库。</strong></p>
</blockquote>
<p>​既然要全库只读, 为什么不使用 <code>set global readonly=true</code> 的方式呢?</p>
<ul>
<li>
<p>在有些系统中, <code>readonly</code> 的值会被用来做其他逻辑, 比如用来判断一个库是主库还是备库。因此, 修改 global 变量的方式影响面更大, 我不建议你使用.</p>
</li>
<li>
<p>在异常处理机制上有差异。</p>
<blockquote>
<p>如果执行 FTWRL 命令之后由于客户端发生异常断开, 那么 MySQL 会自动释放这个全局锁, 整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后, 如果客户端发生异常, 则数据库就会一直保持 readonly 状态, 这样会导致整个库长时间处于不可写状态, 风险较高。</p>
</blockquote>
</li>
</ul>
<h3 id="12-表级锁"><a class="header" href="#12-表级锁">1.2. 表级锁</a></h3>
<ul>
<li>
<p><strong>表锁</strong>: 表锁的语法是 <code>lock tables t read/write</code>。需要注意, <code>lock tables</code>语法除了会限制别的线程的读写外, 也限定了本线程接下来的操作对象.</p>
<blockquote>
<p>在还没有出现更细粒度的锁的时候, 表锁是最常用的处理并发的方式。</p>
<p>而对于 InnoDB 这种支持行锁的引擎, 一般不使用 lock tables 命令来控制并发, 毕竟锁住整个表的影响面还是太大
如何安全地给小表加字段？</p>
<ul>
<li><code>MariaDB</code>已支持</li>
<li><code>mysql</code>未知</li>
</ul>
<pre><code class="language-sql">ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
</code></pre>
</blockquote>
</li>
<li>
<p><strong>元数据锁(meta data lock, MDL)</strong>:</p>
<ul>
<li><code>MDL</code>是server层的锁, 表级锁, 主要用于隔离<code>DML</code>和<code>DDL</code>操作之间的干扰</li>
<li><code>MDL</code> 的作用是,保证读写的正确性,一个表做增删改查操作的时候,加 <code>MDL</code> 读锁；当要对表做结构变更操作的时候,加 <code>MDL</code> 写锁。</li>
<li>读锁之间不互斥, 因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的, 用来保证变更表结构操作的安全性.</li>
<li><code>MDL</code> 会直到事务提交才释放, 在做表结构变更的时候, 你一定要小心不要导致锁住线上查询和更新。</li>
</ul>
</li>
</ul>
<blockquote>
<p>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有 <code>lock tables</code> 这样的语句, 你需要追查一下, 比较可能的情况是：</p>
<ul>
<li>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎, 那要安排升级换引擎；</li>
<li>要么是你的引擎升级了, 但是代码还没升级。我见过这样的情况, 最后业务开发就是把<code>lock tables</code> 和 <code>unlock tables</code> 改成 <code>begin</code> 和 <code>commit</code>, 问题就解决了</li>
</ul>
</blockquote>
<h3 id="13-行锁"><a class="header" href="#13-行锁">1.3. 行锁</a></h3>
<p>MySQL 的行锁是在<strong>引擎层由各个引擎自己实现的</strong>。但并不是所有的引擎都支持行锁.比如 MyISAM 引擎就不支持行锁。</p>
<ul>
<li>在 InnoDB 事务中, 行锁是在需要的时候才加上的, 但并不是不需要了就立刻释放, 而是要等到事务结束时才释放。这个就是<strong>两阶段锁协议</strong></li>
<li>如果你的事务中需要锁多个行, 要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放.</li>
</ul>
<h2 id="2-死锁和死锁检测"><a class="header" href="#2-死锁和死锁检测">2. 死锁和死锁检测</a></h2>
<p>两种策略：</p>
<ul>
<li>一种策略是, 直接进入等待, 直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>(默认50s) 来设置。</li>
<li>另一种策略是, <strong>主动死锁检测</strong>, 发现死锁后, 主动回滚死锁链条中的某一个事务, 让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code>(默认<code>on</code>) 设置为 <code>on</code>, 表示开启这个逻辑。
<ul>
<li>业务避免死锁</li>
<li>控制并发度,中间件或修改mysql源码来进行控制并发. 基本思路就是, 对于相同行的更新, 在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="五-事务到底是隔离的还是不隔离的"><a class="header" href="#五-事务到底是隔离的还是不隔离的">`五. 事务到底是隔离的还是不隔离的</a></h1>
<p>在 MySQL 中, 事务支持是在<strong>引擎层</strong>实现的.</p>
<h2 id="1-事务隔离"><a class="header" href="#1-事务隔离">1. 事务隔离</a></h2>
<ul>
<li><code>Atomicity</code> 原子性</li>
<li><code>Consistency</code> 一致性</li>
<li><code>Isolation</code> 隔离性</li>
<li><code>Durability</code> 持久性</li>
</ul>
<h3 id="11-隔离性与隔离级别acid"><a class="header" href="#11-隔离性与隔离级别acid">1.1. 隔离性与隔离级别(ACID)</a></h3>
<p>问题: 当数据库上有多个事务同时执行的时候, 就可能出现<em><strong>脏读(dirty read)</strong></em>、<em><strong>不可重复读(non-repeatable read)</strong></em>、<em><strong>幻读(phantom read</strong></em>的问题, 为了解决这些问题, 就有了“<strong>隔离级别</strong>”的概念.</p>
<p>SQL 标准的事务隔离级别包括：<code>读未提交(read uncommitted)</code> 、<code>读提交(read committed)</code>、<code>可重复读(repeatable read)</code>和<code>串行化(serializable)</code></p>
<ul>
<li><code>读未提交</code>: <strong>一个事务还没提交时, 它做的变更就能被别的事务看到.</strong></li>
<li><code>读提交</code> : <strong>一个事务提交之后, 它做的变更才会被其他事务看到.</strong></li>
<li><code>可重复读(mysql默认级别</code>):  <strong>一个事务执行过程中看到的数据, 总是跟这个事务在启动时看到的数据是一致的. 当然在可重复读隔离级别下, 未提交变更对其他事务也是不可见的.</strong>
<ul>
<li>在“可重复读”隔离级别下, 这个视图是在<strong>事务启动时创建的</strong>, 整个事务存在期间都用这个视图,</li>
<li>在“读提交”隔离级别下, 这个视图是在<strong>每个 SQL 语句开始执行的时候创建的</strong></li>
</ul>
</li>
<li><code>串行化</code> :  <strong>顾名思义是对于同一行记录, “写”会加“写锁”, “读”会加“读锁”. 当出现读写锁冲突的时候, 后访问的事务必须等前一个事务执行完成, 才能继续执行.</strong></li>
</ul>
<p><img src="mysql/../assets/202110281013297.png" alt=" " /></p>
<ul>
<li>若隔离级别是“读未提交”:  则 V1 的值就是 2. 这时候事务 B 虽然还没有提交, 但是结果已经被 A 看到了. 因此, V2、V3 也都是 2.</li>
<li>若隔离级别是“读提交”: 则 V1 是 1, V2 的值是 2. 事务 B 的更新在提交后才能被 A 看到. 所以,  V3 的值也是 2.</li>
<li>若隔离级别是“可重复读”: 则 V1、V2 是 1, V3 是 2. 之所以 V2 还是 1, 遵循的就是这个要求：<em><strong>事务在执行期间看到的数据前后必须是一致的. (即视图)</strong></em></li>
<li>若隔离级别是“串行化”: 则在事务 B 执行“将 1 改成 2”的时候, 会被锁住. 直到事务 A 提交后, 事务 B 才可以继续执行. 所以从 A 的角度看,  V1、V2 值是 1, V3 的值是 2.</li>
</ul>
<blockquote>
<p>数据库里面会创建一个视图, 访问的时候以视图的逻辑结果为准.</p>
<ul>
<li>“读未提交”隔离级别下, 直接返回记录上的最新值, 没有视图概念；</li>
<li>在“读提交”隔离级别下, 这个视图是在<strong>每个 SQL 语句开始执行的时候创建的</strong>.</li>
<li>在“可重复读”隔离级别下, 这个视图是在<strong>事务启动时创建</strong>的, 整个事务存在期间都用这个视图.</li>
<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问.</li>
</ul>
</blockquote>
<pre><code class="language-sql"># 查看事务的级别
show variables like 'transaction_isolation'
# 查看持续时间超过60s的事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60
</code></pre>
<h3 id="12-事务的启动方式"><a class="header" href="#12-事务的启动方式">1.2. 事务的启动方式</a></h3>
<blockquote>
<ol>
<li>显式启动事务语句,  <code>begin</code> 或 <code>start transaction</code>. 配套的提交语句是 <code>commit</code>, 回滚语句是 <code>rollback</code>.</li>
<li><code>set autocommit=0</code>, 这个命令会将这个线程的自动提交关掉. 意味着如果你只执行一个 select 语句, 这个事务就启动了, 而且并不会自动提交. 这个事务持续存在直到你主动执行 <code>commit</code> 或 <code>rollback</code> 语句, 或者断开连接.</li>
</ol>
</blockquote>
<h3 id="13-事务启动的时机"><a class="header" href="#13-事务启动的时机">1.3 事务启动的时机</a></h3>
<p><code>begin</code>/<code>start transaction</code> 命令并不是一个事务的起点, 在执行到它们之后的<strong>第一个操作 InnoDB 表的语句</strong>, 事务才真正启动。如果你想要马上启动一个事务, 可以使用 <code>start transaction with consistent snapshot</code>  这个命令。</p>
<p>在 MySQL 里, 有两个“视图”的概念：</p>
<ul>
<li>一个是 view。它是一个用查询语句定义的虚拟表, 在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … , 而它的查询方法与表一样。</li>
<li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图, 即 consistent read view, 用于支持 RC（Read Committed, 读提交）和 RR（Repeatable Read, 可重复读）隔离级别的实现。</li>
</ul>
<h2 id="2-如何避免长事务对业务的影响"><a class="header" href="#2-如何避免长事务对业务的影响">2. 如何避免长事务对业务的影响？</a></h2>
<h3 id="21从应用开发端来看"><a class="header" href="#21从应用开发端来看">2.1从应用开发端来看</a></h3>
<ul>
<li>
<p>确认是否使用了 <code>set autocommit=0</code>. 这个确认工作可以在测试环境中开展, 把 MySQL 的 general_log 开起来, 然后随便跑一个业务逻辑, 通过 general_log 的日志来确认. 一般框架如果会设置这个值, 也就会提供参数来控制行为, 你的目标就是把它改成 1.</p>
</li>
<li>
<p>确认是否有不必要的只读事务. 有些框架会习惯不管什么语句先用 begin/commit 框起来. 我见过有些是业务并没有这个需要, 但是也把好几个 select 语句放到了事务中. 这种只读事务可以去掉.</p>
</li>
<li>
<p>业务连接数据库的时候, 根据业务本身的预估, 通过 <code>SET MAX_EXECUTION_TIME</code> 命令, 来控制每个语句执行的最长时间, 避免单个语句意外执行太长时间. （为什么会意外？在后续的文章中会提到这类案例）</p>
</li>
</ul>
<h3 id="22-从数据库端来看"><a class="header" href="#22-从数据库端来看">2.2 从数据库端来看</a></h3>
<ul>
<li>监控 <code>information_schema.Innodb_trx</code> 表, 设置长事务阈值, 超过就报警 / 或者 kill；</li>
<li><code>Percona</code> 的 <a href="https://github.com/percona/percona-toolkit">pt-kill</a> 这个工具不错, 推荐使用；</li>
<li>在业务功能测试阶段要求输出所有的 general_log, 分析日志行为提前发现问题；</li>
<li>如果使用的是 MySQL 5.6 或者更新版本, 把 <code>innodb_undo_tablespaces</code> 设置成 2（或更大的值）. 如果真的出现大事务导致回滚段过大, 这样设置后清理起来更方便.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="五-优化参数"><a class="header" href="#五-优化参数">五. 优化参数</a></h1>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td><code>innodb_file_per_table</code></td><td><strong>OFF</strong>: 表的数据放在系统共享表空间, 也就是跟数据字典放在一起；<br /><strong>ON</strong>: 表示的是, 每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中. <br />         mysql 5.6.6后,该值默认为<strong>ON</strong>.<br /><strong>ON</strong>: (建议设置)一个表单独存储为一个文件更容易管理, 而且在你不需要这个表的时候, 通过 drop table 命令, 系统就会直接删除这个文件.而如果是放在共享表空间中, 即使表删掉了, 空间也是不会回收的. <br />解决方法: 重建表 <code>alter table A engine=InnoDB</code> <br />推荐github开源项目<a href="https://github.com/github/gh-ost">gh-ost</a>来做<code>online DDL</code>.</td></tr>
<tr><td><code>wait_timeout</code></td><td>客户端连接超时时间.</td></tr>
<tr><td><code>innodb_flush_log_at_trx_commit</code></td><td>0: 表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;<br />1: 表示每次事务的 redo log 都直接持久化到磁盘.(推荐 )<br />2: 表示每次事务提交时都只是把 redo log 写到 page cache.</td></tr>
<tr><td><code>sync_binlog</code></td><td>0: 每次提交事务都只 write, 不 fsync；<br />1: 表示每次事务的 binlog 都持久化到磁盘(推荐)<br />N: 表示每次提交事务都 write, 但累积 N 个事务后才 fsync. 建议100~1000</td></tr>
<tr><td><code>transaction-isolation</code></td><td>隔离级别</td></tr>
<tr><td><code>autocommit</code></td><td>ON 显示的启动事务,提交和回滚,</td></tr>
<tr><td><code>innodb_change_buffer_max_size</code></td><td>这个参数设置为 50 的时候, 表示 change buffer 的大小最多只能占用 buffer pool 的 50%.</td></tr>
<tr><td><code>long_query_time</code></td><td>慢查询阀值</td></tr>
<tr><td><code>innodb_stats_persistent</code></td><td>存储索引统计的方式:<br />设置为 on 的时候, 表示统计信息会持久化存储. 这时, 默认的 N 是 20, M 是 10. <br />设置为 off 的时候, 表示统计信息只存储在内存中. 这时, 默认的 N 是 8, M 是 16.</td></tr>
<tr><td><code>innodb_io_capacity</code></td><td>告诉 InnoDB 你的磁盘能力,建议你设置成磁盘的 IOPS.<br />可用此命令查询: <code>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</code></td></tr>
<tr><td><code>innodb_max_dirty_pages_pct</code></td><td>脏页比例上限, 默认值是 75%,通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total得到.</td></tr>
<tr><td><code>innodb_flush_neighbors</code></td><td>1: 表示有上述的“连坐”机制, <br />0: 表示不找邻居, 自己刷自己的.</td></tr>
<tr><td><code>sort_buffer_size</code></td><td>MySQL 为排序开辟的内存（sort_buffer）的大小</td></tr>
<tr><td><code>sql_log_bin</code></td><td>off: 不写binlog<br />on: 不写binlog</td></tr>
<tr><td><code>binlog_group_commit_sync_delay</code></td><td>表示延迟多少微秒后才调用 fsync;</td></tr>
<tr><td><code>binlog_group_commit_sync_no_delay_count</code></td><td>表示累积多少次以后才调用 fsync.</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>在 InnoDB 中, 每个<strong>数据页的大小默认是16KB</strong>.</p>
</li>
<li>
<p>如果内存够, 就要多利用内存, 尽量减少磁盘访问.</p>
</li>
<li>
<p><strong>唯一索引的更新就不能使用 <code>change buffer</code></strong>, 实际上也<strong>只有普通索引</strong>可以使用</p>
<ul>
<li>
<p><code>change buffer</code> 用的是 <code>buffer pool</code> 里的内存, 因此不能无限增大.</p>
</li>
<li>
<p><code>change buffer</code> 的大小, 可以通过参数 <code>innodb_change_buffer_max_size</code> 来动态设置. (这个参数设置为 50 的时候, 表示<code>change buffer</code> 的大小最多只能占用 <code>buffer pool</code>的 <code>50%</code>. )</p>
</li>
</ul>
</li>
<li>
<p>优化器逻辑</p>
<ul>
<li>扫描行数是影响执行代价的因素之一. 扫描的行数越少, 意味着访问磁盘数据的次数越少, 消耗的 CPU 资源越少.</li>
<li>扫描行数并不是唯一的判断标准, 优化器还会结合是否使用临时表、是否排序等因素进行综合判断.</li>
</ul>
<blockquote>
<p>MySQL 在真正开始执行语句之前, 并不能精确地知道满足这个条件的记录有多少条, 而只能根据统计信息来估算记录数.</p>
<p>这个统计信息就是索引的“区分度”. 显然, 一个索引上不同的值越多, 这个索引的区分度就越好. 而一个索引上不同的值的个数, 我们称之为**“基数”（cardinality）**. 也就是说, 这个基数越大, 索引的区分度越好.</p>
<p>在 MySQL 中, 有两种存储索引统计的方式, 可以通过设置参数 <code>innodb_stats_persistent</code>的值来选择：</p>
<ul>
<li>设置为 <code>on</code>的时候, 表示统计信息会持久化存储. 这时, 默认的 N 是 20, M 是 10.</li>
<li>设置为 <code>off</code>的时候, 表示统计信息只存储在内存中. 这时, 默认的 N 是 8, M 是 16.</li>
</ul>
</blockquote>
</li>
<li>
<p>给字符串加索引</p>
<ul>
<li>
<p><strong>完整索引</strong>: 这样可能比较占用空间；</p>
<blockquote>
<p><code>alter table SUser add index index1(email);</code></p>
</blockquote>
</li>
<li>
<p><strong>前缀索引</strong>: 节省空间, 但会增加查询扫描次数, 并且不能使用覆盖索引, 因为必须回表查询确认一次；</p>
<blockquote>
<p>前缀索引, 定义好长度, 就可以做到既节省空间, 又不用额外增加太多的查询成本.</p>
<p><code>alter table SUser add index index2(email(6));</code></p>
<pre><code class="language-sql">select   count(distinct left(email,4)）as L4,  
            count(distinct left(email,5)）as L5,  
            count(distinct left(email,6)）as L6,  
            count(distinct left(email,7)）as L7,
from SUser;
</code></pre>
</blockquote>
</li>
<li>
<p><strong>倒序存储</strong>: 再创建前缀索引, 用于绕过字符串本身前缀的区分度不够的问题；但是不支持范围查询.</p>
</li>
<li>
<p><strong>hash字段</strong>: 查询性能稳定, 有额外的存储和计算消耗, 跟第三种方式一样, 都不支持范围扫描.</p>
<blockquote>
<p>可以在表上再创建一个整数字段, 来保存身份证的校验码, 同时在这个字段上创建索引.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>刷脏页逻辑, mysql抖动原因.</p>
<blockquote>
<ul>
<li><code>innodb_io_capacity</code>这个参数了, 它会告诉 InnoDB 你的磁盘能力. 这个值我建议你设置成磁盘的 <code>IOPS</code>. 通过<code>fio</code>工具获取磁盘<code>IOPS</code>能力<code>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</code></li>
<li><code>innodb_max_dirty_pages_pct</code> 是脏页比例上限, 默认值是 75%. InnoDB 会根据当前的脏页比例（假设为 M）, 算出一个范围在 0 到 100 之间的数字. 脏页比例获取通过<code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code>具体使用<code>select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b;</code></li>
<li><code>innodb_flush_neighbors</code> 用来控制刷脏页时是否刷邻居脏页.</li>
</ul>
</blockquote>
</li>
<li>
<p>如何删除数据并缩小表文件.</p>
<ul>
<li>
<p>可以使用以下命令要重建表</p>
<pre><code class="language-sql">alter table A engine=InnoDB -- 与下一句相同
alter table t engine=innodb,ALGORITHM=inplace;
alter table t engine=innodb,ALGORITHM=copy;
</code></pre>
</li>
<li>
<p>建议使用 <a href="https://github.com/github/gh-ost">gh-ost</a> 来做.</p>
</li>
</ul>
<p><code>optimize table</code>、<code>analyze table</code> 和 <code>alter table</code> 这三种方式重建表的区别.</p>
<ul>
<li>从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）；</li>
<li><code>analyze table t</code> 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</li>
<li><code>optimize table t</code> 等于 recreate+analyze.</li>
</ul>
</li>
<li>
<p>对索引字段做函数操作, 可能会破坏索引值的有序性, 因此优化器就决定放弃走树搜索功能. 比如隐式转换(字符转数字),字符集不一致(utf-8与uft8mb4)等都有可能产生函数操作,引起优化器放弃树搜索.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="七-性能提升"><a class="header" href="#七-性能提升">七. 性能提升</a></h1>
<h2 id="临时性能提升"><a class="header" href="#临时性能提升">临时性能提升</a></h2>
<ul>
<li>第一种方法：先处理掉那些占着连接但是不工作的线程。有损处理,会Kill掉正在处理事务的连接,或导致客户端lost connection 错误.</li>
</ul>
<p>避免大量使用短连接.</p>
<pre><code class="language-sql"># 查看事务具体状态
select * from information_schema.innodb_trx\G
# 从服务器断开连接使用 kill connection + id 的命令
kill connection 5
</code></pre>
<ul>
<li>第二种方法：减少连接过程的消耗。</li>
</ul>
<p>如果你启用–skip-grant-tables 参数, MySQL 会默认把 --skip-networking 参数打开, 表示这时候数据库只能被本地的客户端连接。</p>
<ul>
<li>慢查询性能问题
<ul>
<li>索引没有设计好；Online DDL</li>
<li>SQL 语句没写好；使用query_rewrite 功能.</li>
<li>MySQL 选错了索引。</li>
</ul>
</li>
<li>QPS突增问题, 新业务bug? 某个语句QPS暴涨?</li>
</ul>
<h2 id="io性能瓶颈"><a class="header" href="#io性能瓶颈">IO性能瓶颈</a></h2>
<ul>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数, 减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的, 因此可能会增加语句的响应时间, 但没有丢失数据的风险。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是, 主机掉电时会丢 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是, 主机掉电的时候会丢数据。</li>
</ul>
<h2 id="主备数据一致性"><a class="header" href="#主备数据一致性">主备数据一致性</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql数据储存"><a class="header" href="#mysql数据储存">mysql数据储存</a></h1>
<h2 id="binlog-的写入机制"><a class="header" href="#binlog-的写入机制">binlog 的写入机制</a></h2>
<p><code>binlog</code> 的写入逻辑比较简单：事务执行过程中, 先把日志写到 <code>binlog cache</code>, 事务提交的时候, 再把 <code>binlog cache</code> 写到 <code>binlog</code> 文件中</p>
<p>系统给 <code>binlog cache</code> 分配了一片内存, 每个线程一个, 参数 <code>binlog_cache_size</code> 用于控制单个线程内 <code>binlog cache</code> 所占内存的大小。如果超过了这个参数规定的大小, 就要暂存到磁盘。</p>
<blockquote>
<p>每个线程有自己 <code>binlog cache</code>, 但是共用同一份 binlog 文件。</p>
<ul>
<li>图中的 <code>write</code>, 指的就是指把日志写入到文件系统的 page cache, 并没有把数据持久化到磁盘, 所以速度比较快。</li>
<li>图中的 <code>fsync</code>, 才是将数据持久化到磁盘的操作。一般情况下, 我们认为 <code>fsync</code> 才占磁盘的 IOPS。</li>
</ul>
<p><code>write</code> 和 <code>fsync</code> 的时机, 是由参数 sync_binlog 控制的：</p>
<ul>
<li><code>sync_binlog=0</code> 的时候, 表示每次提交事务都只 <code>write</code>, 不 <code>fsync</code>；</li>
<li><code>sync_binlog=1</code> 的时候, 表示每次提交事务都会执行 <code>fsync</code>；</li>
<li><code>sync_binlog=N(N&gt;1)</code> 的时候, 表示每次提交事务都 <code>write</code>, 但累积 N 个事务后才 <code>fsync</code>。</li>
</ul>
<p>NOTE: 将 <code>sync_binlog</code> 设置为 N, 对应的风险是：如果主机发生异常重启, 会丢失最近 N 个事务的 <code>binlog</code> 日志。</p>
</blockquote>
<h2 id="二-redo-log-的写入机制"><a class="header" href="#二-redo-log-的写入机制">二. redo log 的写入机制</a></h2>
<p>为了控制 <code>redo log</code> 的写入策略, InnoDB 提供了<code>innodb_flush_log_at_trx_commit</code>参数, 它有三种可能取值：</p>
<ul>
<li>设置为 0 的时候, 表示每次事务提交时都只是把 <code>redo log</code> 留在 <code>redo log buffer</code>中 ;</li>
<li>设置为 1 的时候, 表示每次事务提交时都将 <code>redo log</code> 直接持久化到磁盘；</li>
<li>设置为 2 的时候, 表示每次事务提交时都只是把 <code>redo log</code> 写到 page cache。</li>
</ul>
<p>InnoDB 有一个后台线程, 每隔 1 秒, 就会把 <code>redo log buffer</code> 中的日志, 调用 write 写到文件系统的<code>page cache</code>, 然后调用 <code>fsync</code> 持久化到磁盘。</p>
<p>除了后台线程每秒一次的轮询操作外, 还有两种场景会让一个没有提交的事务的 <code>redo log</code> 写入到磁盘中.</p>
<ul>
<li><code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候, 后台线程会主动写盘</li>
<li>并行的事务提交的时候, 顺带将这个事务的 <code>redo log buffer</code> 持久化到磁盘</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定位性能瓶颈"><a class="header" href="#定位性能瓶颈">定位性能瓶颈</a></h1>
<ul>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88">定位性能瓶颈</a>
<ul>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#1-performance-schema">1. Performance Schema</a>
<ul>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#11-performance-schema%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">1.1 Performance Schema表的分类</a>
<ul>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#111-%E8%AF%AD%E5%8F%A5%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95%E8%A1%A8">1.1.1 语句事件记录表</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#112-%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95%E8%A1%A8">1.1.2 等待事件记录表</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#113-%E9%98%B6%E6%AE%B5%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95%E8%A1%A8">1.1.3 阶段事件记录表</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#114-%E4%BA%8B%E5%8A%A1%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95%E8%A1%A8">1.1.4 事务事件记录表</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#115-%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E8%B0%83%E7%94%A8%E7%9A%84%E8%A1%A8">1.1.5 监视文件系统层调用的表</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#116-%E7%9B%91%E8%A7%86%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A1%A8">1.1.6 监视内存使用的表</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#117-%E5%8A%A8%E6%80%81%E5%AF%B9-performance_schema-%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A1%A8">1.1.7 动态对 performance_schema 进行配置的配置表</a></li>
</ul>
</li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#12-%E5%90%AF%E7%94%A8-performance-schema">1.2 启用 Performance Schema</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#13-%E4%BD%BF%E7%94%A8-performance-schema">1.3 使用 Performance Schema</a></li>
</ul>
</li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#2-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">2. 慢查询日志</a>
<ul>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#21-%E5%90%AF%E7%94%A8%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">2.1 启用慢查询日志</a></li>
<li><a href="mysql/08-%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88.html#22-%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">2.2 分析慢查询日志</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-performance-schema"><a class="header" href="#1-performance-schema">1. Performance Schema</a></h2>
<p>MySQL的<code>Performance Schema</code>是一套内存表, 用于跟踪MySQL的性能指标。它实际上使用<code>PERFORMANCE_SCHEMA</code>存储引擎, 用户操作<code>performance_schema</code>数据库中的表, <code>Performance Schema</code>仅对本地服务器有效, 所有的更改不会复制到其它的服务器.</p>
<p><code>Performance Schema</code>的表大致可以分为6个组, 配置、当前事件、历史、实例、摘要, 及其它.
用户可以通过修改<code>setup_%</code>表的内容配置<code>Performance Schema</code>:</p>
<ul>
<li><strong>setup_actors</strong>: 检测有哪些前台线程</li>
<li><strong>setup_instruments</strong>: 收集哪些服务器度量指标, 生产者</li>
<li><strong>setup_consumers</strong>: 监控的事件存储在哪里, 消费者</li>
<li><strong>setup_objects</strong>: 检测有哪些对象</li>
<li><strong>setup_threads</strong>: 检测有哪些线程分类</li>
</ul>
<p>Performance Schema中存在大量的检测项目, 检测项目对应MySQL服务器的源代码检测点, 检测项目名称由一系列部件组成采用“/”分割, 从左到右, 从通用到具体:</p>
<blockquote>
<p>wait/io/file/myisam/log
stage/sql/closing tables</p>
</blockquote>
<ul>
<li><strong>idle</strong>: 检测的空闲事件</li>
<li><strong>error</strong>: 检测的错误事件</li>
<li><strong>memory</strong>: 检测的内存事件</li>
<li><strong>stage</strong>: 检测的阶段事件</li>
<li><strong>statement</strong>: 检测的语句事件</li>
<li><strong>transaction</strong>: 检测的事务事件</li>
<li><strong>wait</strong>: 检测的等待事件</li>
</ul>
<h3 id="11-performance-schema表的分类"><a class="header" href="#11-performance-schema表的分类">1.1 Performance Schema表的分类</a></h3>
<h4 id="111-语句事件记录表"><a class="header" href="#111-语句事件记录表">1.1.1 语句事件记录表</a></h4>
<p>记录语句事件信息的表，包括:</p>
<ul>
<li><code>events_statements_current</code>(当前语句事件表)</li>
<li><code>events_statements_history</code>(历史语句事件表)</li>
<li><code>events_statements_history_long</code>(长语句历史事件表)</li>
<li><code>summary</code> 表(聚合后的摘要表)<code>。其中，summary</code>表还可以根据账号(<code>account</code>)、主机(<code>host</code>)、程序(<code>program</code>)、线程(<code>thread</code>)、用户(<code>user</code>)和全局(glo`bal) 再进行细分。</li>
</ul>
<pre><code class="language-sql">show tables like 'events_statement%';
</code></pre>
<h4 id="112-等待事件记录表"><a class="header" href="#112-等待事件记录表">1.1.2 等待事件记录表</a></h4>
<p>与语句事件记录表类似。</p>
<pre><code class="language-sql">show tables like 'events_wait%';
</code></pre>
<h4 id="113-阶段事件记录表"><a class="header" href="#113-阶段事件记录表">1.1.3 阶段事件记录表</a></h4>
<p>记录语句执行阶段事件的表，与语句事件记录表类似。</p>
<pre><code class="language-sql">show tables like 'events_stage%';
</code></pre>
<h4 id="114-事务事件记录表"><a class="header" href="#114-事务事件记录表">1.1.4 事务事件记录表</a></h4>
<p>记录与事务相关的事件的表，与语句事件记录表类似。</p>
<pre><code class="language-sql">show tables like 'events_transaction%';
</code></pre>
<h4 id="115-监视文件系统层调用的表"><a class="header" href="#115-监视文件系统层调用的表">1.1.5 监视文件系统层调用的表</a></h4>
<pre><code class="language-sql">show tables like '%file%';
</code></pre>
<h4 id="116-监视内存使用的表"><a class="header" href="#116-监视内存使用的表">1.1.6 监视内存使用的表</a></h4>
<pre><code class="language-sql">show tables like '%memory%';
</code></pre>
<h4 id="117-动态对-performance_schema-进行配置的配置表"><a class="header" href="#117-动态对-performance_schema-进行配置的配置表">1.1.7 动态对 performance_schema 进行配置的配置表</a></h4>
<pre><code class="language-sql">show tables like '%setup%';
</code></pre>
<h3 id="12-启用-performance-schema"><a class="header" href="#12-启用-performance-schema">1.2 启用 Performance Schema</a></h3>
<p>确保在<code>mysql.cnf</code>配置文件中启用, 并重启mysql:</p>
<pre><code class="language-ini">[mysqld]
performance_schema=ON
</code></pre>
<p>重启后查看是否已经启用:</p>
<pre><code class="language-sql">SHOW VARIABLES LIKE 'performance_schema';
</code></pre>
<h3 id="13-使用-performance-schema"><a class="header" href="#13-使用-performance-schema">1.3 使用 Performance Schema</a></h3>
<pre><code class="language-sql">USE performance_schema;

-- 查询最近10分钟的SQL执行次数
SELECT DIGEST_TEXT, COUNT_STAR, SUM_TIMER_WAIT / 1000000000 AS total_exec_time_sec FROM events_statements_summary_by_digest WHERE LAST_SEEN &gt;= (NOW() - INTERVAL 10 MINUTE) ORDER BY COUNT_STAR DESC LIMIT 20;
-- 哪类的SQL执行最多?
SELECT DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
-- 哪类SQL的平均响应时间最多?
SELECT DIGEST_TEXT,AVG_TIMER_WAIT FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
-- 哪类SQL排序记录数最多?
SELECT DIGEST_TEXT,SUM_SORT_ROWS FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
-- 哪类SQL扫描记录数最多?
SELECT DIGEST_TEXT,SUM_ROWS_EXAMINED FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
-- 哪类SQL使用临时表最多?
SELECT DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
-- 哪类SQL返回结果集最多?
SELECT DIGEST_TEXT,SUM_ROWS_SENT FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
-- 哪个表物理IO最多?
SELECT file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE FROM file_summary_by_instance ORDER BY SUM_NUMBER_OF_BYTES_READ + SUM_NUMBER_OF_BYTES_WRITE DESC
-- 哪个表逻辑IO最多?
SELECT object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT FROM table_io_waits_summary_by_table ORDER BY sum_timer_wait DESC
-- 哪个索引访问最多?
SELECT OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE FROM table_io_waits_summary_by_index_usage ORDER BY SUM_TIMER_WAIT DESC
-- 哪个索引从来没有用过?
SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME FROM table_io_waits_summary_by_index_usage WHERE INDEX_NAME IS NOT NULL AND COUNT_STAR = 0 AND OBJECT_SCHEMA &lt;&gt; 'mysql' ORDER BY OBJECT_SCHEMA,OBJECT_NAME;
-- 哪个等待事件消耗时间最多?
SELECT EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT FROM events_waits_summary_global_by_event_name WHERE event_name != 'idle' ORDER BY SUM_TIMER_WAIT DESC
-- 剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息
SELECT EVENT_ID,sql_text FROM events_statements_history WHERE sql_text LIKE '%count(*)%';
-- 查看每个阶段的时间消耗
SELECT event_id,EVENT_NAME,SOURCE,TIMER_END - TIMER_START FROM events_stages_history_long WHERE NESTING_EVENT_ID = 1553;
-- 查看每个阶段的锁等待情况
SELECT event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id FROM events_waits_history_long WHERE nesting_event_id = 1553;
</code></pre>
<h2 id="2-慢查询日志"><a class="header" href="#2-慢查询日志">2. 慢查询日志</a></h2>
<h3 id="21-启用慢查询日志"><a class="header" href="#21-启用慢查询日志">2.1 启用慢查询日志</a></h3>
<p>确保在<code>mysql.cnf</code>配置文件中启用, 并重启mysql:</p>
<pre><code class="language-ini">[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/mysql-slow.log
long_query_time = 0.5
log_queries_not_using_indexes = 1
</code></pre>
<p>查看是否已经启用慢查询日志功能:</p>
<pre><code class="language-shell">SHOW VARIABLES LIKE 'slow_query_log';
SHOW VARIABLES LIKE 'slow_query_log_file';
SHOW VARIABLES LIKE 'long_query_time';
SHOW VARIABLES LIKE 'log_queries_not_using_indexes';
</code></pre>
<h3 id="22-分析慢查询日志"><a class="header" href="#22-分析慢查询日志">2.2 分析慢查询日志</a></h3>
<p>使用 <code>pt-query-digest</code> 工具 (<a href="https://github.com/percona/percona-toolkit">Percona Toolkit</a> 提供) 来解析慢查询日志并生成统计报告:</p>
<pre><code class="language-shell">pt-query-digest /var/log/mysql/mysql-slow.log &gt; slow-query-report.txt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pickup"><a class="header" href="#pickup">Pickup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logql-log-query-language"><a class="header" href="#logql-log-query-language">LogQL: Log query language</a></h1>
<h2 id="1-overview"><a class="header" href="#1-overview">1. Overview</a></h2>
<p><code>LogQL</code> 是 Grafana Loki 的受 <code>promql</code> 启发的查询语言. 查询的行为就好像它们是聚合日志源的分布式 grep. <code>LogQL</code> 使用标签和运算符进行过滤.</p>
<p>有两种类型的 LogQL 查询:</p>
<ul>
<li>[Log queries](#二. Log queries  ) 返回日志行的内容.</li>
<li>[Metric queries](#三. Metric queries) 基于扩展日志查询结果来计算值</li>
</ul>
<h3 id="二元操作符"><a class="header" href="#二元操作符">二元操作符</a></h3>
<h4 id="算术操作符"><a class="header" href="#算术操作符">算术操作符</a></h4>
<ul>
<li><code>+</code> (addition)</li>
<li><code>-</code> (subtraction)</li>
<li><code>*</code> (multiplication)</li>
<li><code>/</code> (division)</li>
<li><code>%</code> (modulo)</li>
<li><code>^</code> (power/exponentiation)</li>
</ul>
<h4 id="逻辑和集合运算符"><a class="header" href="#逻辑和集合运算符">逻辑和集合运算符</a></h4>
<ul>
<li><code>and</code> (intersection)</li>
<li><code>or</code> (union)</li>
<li><code>unless</code> (complement)</li>
</ul>
<h4 id="比较运算符"><a class="header" href="#比较运算符">比较运算符</a></h4>
<ul>
<li><code>==</code> (equality)</li>
<li><code>!=</code> (inequality)</li>
<li><code>&gt;</code> (greater than)</li>
<li><code>&gt;=</code> (greater than or equal to)</li>
<li><code>&lt;</code> (less than)</li>
<li><code>&lt;=</code> (less than or equal to)</li>
</ul>
<h4 id="关键字-on-和-ignoring"><a class="header" href="#关键字-on-和-ignoring">关键字 on 和 ignoring</a></h4>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<p>使用 <code>#</code> 注释</p>
<h2 id="二-log-queries"><a class="header" href="#二-log-queries">二. Log queries</a></h2>
<pre><code class="language-text">                _ optional log pipeline _
               /                          \
                filter operator 
                 |=    \
                 !=     |  line filter expression
                 |~     |  
                 !~    /
 
 { stream selector }
                =       \
                !=       |
                =~        \  label filter
                !~        /  expression
                &gt;   &gt;=    |
                &lt;   &lt;=   /
            
            parser expression
            line format expressin 
            label format expression
</code></pre>
<h3 id="日志流选择器log-stream-selector"><a class="header" href="#日志流选择器log-stream-selector">日志流选择器(Log stream selector)</a></h3>
<p>流选择器确定要在查询结果中包含哪些日志流. 日志流是日志内容的唯一来源, 例如文件.</p>
<p>日志流选择器由一个或多个<strong>逗号</strong>分隔的键值对指定, 大括号(<code>{</code> and <code>}</code>)分隔流选择器.</p>
<p>支持以下标签匹配运算符:</p>
<ul>
<li><code>=</code>: exactly equal</li>
<li><code>!=</code>: not equal</li>
<li><code>=~</code>: regex matches</li>
<li><code>!~</code>: regex does not match</li>
</ul>
<h3 id="日志管道log-pipeline"><a class="header" href="#日志管道log-pipeline">日志管道(Log pipeline)</a></h3>
<p>日志管道可以附加到日志流选择器以进一步处理和过滤日志流. 它是由一组表达式组成的. 对于每个日志行, 每个表达式按从左到右的顺序执行. 如果表达式过滤掉一条日志行, 则管道将停止处理当前日志行, 并开始处理下一条日志行.</p>
<p>日志管道表达式可分为三类:</p>
<ul>
<li>过滤表达式: [行过滤](#行过滤(Line filter expression))和[标签过滤](#标签过滤(Label filter expressions))</li>
<li>解析表达式</li>
<li>格式化表达式: <a href="pickup/01-logql.html##">line format expressions</a> and <a href="pickup/01-logql.html##">label format expressions</a></li>
</ul>
<h4 id="行过滤line-filter-expression"><a class="header" href="#行过滤line-filter-expression">行过滤(Line filter expression)</a></h4>
<p>行过滤表达式支持以下匹配运算符:</p>
<ul>
<li><code>|=</code>: Log line contains string</li>
<li><code>!=</code>: Log line does not contain string</li>
<li><code>|~</code>: Log line contains a match to the regular expression</li>
<li><code>!~</code>: Log line does not contain a match to the regular expression</li>
</ul>
<h4 id="标签过滤label-filter-expressions"><a class="header" href="#标签过滤label-filter-expressions">标签过滤(Label filter expressions)</a></h4>
<p>标签过滤器表达式允许使用原始和提取的标签过滤日志行,它可以包含多个谓词.</p>
<p>谓词包含一个标签标识符、一个操作和一个要进行比较的标签值.</p>
<p>我们支持从查询输入自动推断的多个值类型</p>
<ul>
<li><strong>String</strong>是用双引号或反引号</li>
<li><strong><a href="https://golang.org/pkg/time/#ParseDuration">Duration</a></strong> 有效的时间单位: “ns”, “us” (or “µs”), “ms”, “s”, “m”, “h”.</li>
<li><strong>Number</strong></li>
<li><strong>Bytes</strong>有效的字节单位: “b”, “kib”, “kb”, “mib”, “mb”, “gib”, “gb”, “tib”, “tb”, “pib”, “pb”, “eib”, “eb”.</li>
</ul>
<p><strong>String</strong>类型与Prometheus的标签选择器一致, 可以使用相同的操作(<code>=</code>,<code>!=</code>,<code>=~</code>,<code>!~</code>)</p>
<blockquote>
<p>The string type is the only one that can filter out a log line with a label <code>__error__</code>.</p>
</blockquote>
<p>使用 <strong>Duration</strong>, <strong>Number</strong> 和 <strong>Bytes</strong> 将在比较之前转换标签值, 并支持以下比较器:</p>
<ul>
<li><code>==</code> or <code>=</code> for equality.</li>
<li><code>!=</code> for inequality.</li>
<li><code>&gt;</code> and <code>&gt;=</code> for greater than and greater than or equal.</li>
<li><code>&lt;</code> and <code>&lt;=</code> for lesser than and lesser than or equal.</li>
</ul>
<h4 id="解析器"><a class="header" href="#解析器">解析器</a></h4>
<p>解析器表达式可以从日志内容中解析和提取标签. 然后可以使用提取的标签来使用标签筛选器表达式进, 或者用于度量聚合.</p>
<p>Loki 支持 <a href="https://grafana.com/docs/loki/latest/logql/log_queries/#json">JSON</a>, <a href="https://grafana.com/docs/loki/latest/logql/log_queries/#logfmt">logfmt</a>, <a href="https://grafana.com/docs/loki/latest/logql/log_queries/#pattern">pattern</a>, <a href="https://grafana.com/docs/loki/latest/logql/log_queries/#regular-expression">regexp</a> and <a href="https://grafana.com/docs/loki/latest/logql/log_queries/#unpack">unpack</a> parsers.</p>
<h5 id="json"><a class="header" href="#json">JSON</a></h5>
<p>JSON解析器支持两种模式</p>
<ul>
<li>无参数</li>
</ul>
<p>如果日志行是有效的 json 文档, 那么向管道添加<code>| json</code>将提取所有 json 属性作为标签, NOTE: 数组将被忽略</p>
<ul>
<li>有参数</li>
</ul>
<p>如果日志行是有效的 json 文档, 那么向管道添加<code>| json label="expression1", another="expression2"</code>将提取指 json 属性作为标签.</p>
<h5 id="logfmt"><a class="header" href="#logfmt">logfmt</a></h5>
<p>可以使用<code>| logfmt</code> 添加 logfmt 解析器, 并从 logfmt 格式化的日志行中提取所有键和值.</p>
<h5 id="pattern"><a class="header" href="#pattern">Pattern</a></h5>
<p>模式分析器通过定义模式表达式(<code>| pattern”&lt; pattern-expression &gt;”</code>) , 允许从日志行显式提取字段. 表达式匹配日志行的结构.</p>
<blockquote>
<p>考虑该NGINX的日志行</p>
<pre><code class="language-log">0.191.12.2 - - [10/Jun/2021:09:14:29 +0000] "GET /api/plugins/versioncheck HTTP/1.1" 200 2 "-" "Go-http-client/2.0" "13.76.247.102, 34.120.177.193" "TLSv1.2" "US" ""
</code></pre>
<p><code>&lt;ip&gt; - - &lt;_&gt; "&lt;method&gt; &lt;uri&gt; &lt;_&gt;" &lt;status&gt; &lt;size&gt; &lt;_&gt; "&lt;agent&gt;" &lt;_&gt;</code></p>
<p>上面模式表达式将提取这些字段：</p>
<pre><code class="language-kv">"ip" =&gt; "0.191.12.2"
"method" =&gt; "GET"
"uri" =&gt; "/api/plugins/versioncheck"
"status" =&gt; "200"
"size" =&gt; "2"
"agent" =&gt; "Go-http-client/2.0"
</code></pre>
</blockquote>
<p>模式表达式由捕获和文本组成.</p>
<p>捕获是由 <code>&lt;</code> 和 <code>&gt;</code> 字符分隔的字段名. 一位匿名的捕获显示为<code>&lt;_&gt;</code>.</p>
<h5 id="regular-expression"><a class="header" href="#regular-expression">Regular expression</a></h5>
<p>与 logfmt 和 json (隐式地提取所有值并且不带参数)不同, regexp 解析器采用单个参数 <code>| regexp“ &lt; re &gt;”</code></p>
<h5 id="unpack"><a class="header" href="#unpack">unpack</a></h5>
<p>解析器解析 JSON 日志行, 解压打包阶段中的所有嵌入标签. 还将使用一个特殊属性 **<code>_entry</code>**来替换原始日志行.</p>
<h4 id="行格式表达式line-format-expression"><a class="header" href="#行格式表达式line-format-expression">行格式表达式(Line format expression)</a></h4>
<p>行格式表达式可以使用 <a href="https://golang.org/pkg/text/template/">text/template</a>格式重写日志行内容, 它只接受一个字符串参数<code>| line_format "{{.label_name}}"</code>,所有标签都是注入到模板中的变量, 可以使用{{ . label _ name }}符号.</p>
<h4 id="标签格式表达式labels-format-expression"><a class="header" href="#标签格式表达式labels-format-expression">标签格式表达式(Labels format expression)</a></h4>
<p><code>| label _ format</code> 表达式可以重命名、修改或添加标签. 它接受一个逗号分隔的等式操作列表作为参数, 以便一次执行多个操作.</p>
<p>当两端都是标签标识符(例如 dst = src)时, 操作将把 src 标签重命名为 dst.</p>
<p>左边也可以是模板字符串(双引号或反勾号) , 例如 <code>dst = “{{.status}} {{.query}}”</code>, 在这种情况下, dst 标签值被文本/模板计算的结果替换. 这是与<code>| line _ format</code>表达式相同的模板引擎, 这意味着标签可以作为变量使用, 您可以使用相同的函数列表.</p>
<p>在这两种情况下, 如果目标标签不存在, 则创建一个新的目标标签.</p>
<p>重命名表单 dst = src 将在重新映射到 dst 标签后删除 src 标签. 但是, 模板将保留引用的标签, 例如 <code>dst="{{.src}}"</code>,结果在 dst 和 src 具有相同的值</p>
<h2 id="三-metric-queries"><a class="header" href="#三-metric-queries">三. Metric queries</a></h2>
<h2 id="四-template-function"><a class="header" href="#四-template-function">四. Template function</a></h2>
<h2 id="五-matching-ip-addresses"><a class="header" href="#五-matching-ip-addresses">五. Matching IP addresses</a></h2>
<h2 id="六-query-example"><a class="header" href="#六-query-example">六. Query Example</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="promql-prometheus-query-language"><a class="header" href="#promql-prometheus-query-language">PromQL: prometheus query language</a></h1>
<ul>
<li><a href="pickup/02-promql.html#promql-prometheus-query-language">PromQL: prometheus query language</a>
<ul>
<li><a href="pickup/02-promql.html#1-concepts">1. Concepts</a>
<ul>
<li><a href="pickup/02-promql.html#11-data-model">1.1 Data model</a>
<ul>
<li><a href="pickup/02-promql.html#111-metric-names-and-labels">1.1.1 Metric names and labels</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#112-samples">1.1.2 Samples</a></li>
<li><a href="pickup/02-promql.html#113-notation">1.1.3 Notation</a></li>
<li><a href="pickup/02-promql.html#12-metric-types">1.2 Metric types</a>
<ul>
<li><a href="pickup/02-promql.html#121-counter">1.2.1 Counter</a></li>
<li><a href="pickup/02-promql.html#122-gauge">1.2.2 Gauge</a></li>
<li><a href="pickup/02-promql.html#123-histogram">1.2.3 Histogram</a></li>
<li><a href="pickup/02-promql.html#124-summary">1.2.4 Summary</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#13-jobs-and-instances">1.3 Jobs and instances</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#2-promql">2. promQL</a>
<ul>
<li><a href="pickup/02-promql.html#21-expression-language-data-types">2.1 Expression language data types</a></li>
<li><a href="pickup/02-promql.html#22-literals">2.2 literals</a>
<ul>
<li><a href="pickup/02-promql.html#221-string-literals">2.2.1 String literals</a></li>
<li><a href="pickup/02-promql.html#222-float-literals">2.2.2 Float literals</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#23-time-series-selectors">2.3 Time series Selectors</a>
<ul>
<li><a href="pickup/02-promql.html#231-instant-vector-selectors">2.3.1 Instant vector selectors</a></li>
<li><a href="pickup/02-promql.html#232-range-vector-selectors">2.3.2 Range Vector Selectors</a>
<ul>
<li><a href="pickup/02-promql.html#time-durations">Time Durations</a></li>
<li><a href="pickup/02-promql.html#offset-modifier">Offset modifier</a></li>
<li><a href="pickup/02-promql.html#-modifier">@ modifier</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#233-subquery">2.3.3 Subquery</a></li>
<li><a href="pickup/02-promql.html#234-operators">2.3.4 Operators</a></li>
<li><a href="pickup/02-promql.html#235-functions">2.3.5 Functions</a></li>
<li><a href="pickup/02-promql.html#236-comments">2.3.6 Comments</a></li>
<li><a href="pickup/02-promql.html#237-gotchas">2.3.7 Gotchas</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#24-operators">2.4 Operators</a>
<ul>
<li><a href="pickup/02-promql.html#241-binary-operators">2.4.1 Binary operators</a>
<ul>
<li><a href="pickup/02-promql.html#arithmetic-binary-operators">Arithmetic binary operators</a></li>
<li><a href="pickup/02-promql.html#comparison-binary-operators">Comparison binary operators</a></li>
<li><a href="pickup/02-promql.html#logicalset-binary-operators">Logical/set binary operators</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#242-vector-matching">2.4.2 Vector matching</a></li>
<li><a href="pickup/02-promql.html#243-aggregation-operators">2.4.3 Aggregation operators</a></li>
<li><a href="pickup/02-promql.html#244-binary-operator-precedence">2.4.4 Binary operator precedence</a></li>
</ul>
</li>
<li><a href="pickup/02-promql.html#25-functions">2.5 Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-concepts"><a class="header" href="#1-concepts">1. Concepts</a></h2>
<h3 id="11-data-model"><a class="header" href="#11-data-model">1.1 Data model</a></h3>
<p><code>Prometheus</code> 存储所有数据作为时间序列.</p>
<h4 id="111-metric-names-and-labels"><a class="header" href="#111-metric-names-and-labels">1.1.1 Metric names and labels</a></h4>
<p>每个时间序列都由其<code>Metric names</code>和可选的键值称为<code>label</code>作为唯一识别。</p>
<ul>
<li><code>Metric names</code> 满足 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>(<strong>NOTE</strong>: <code>:</code>保留用于用户定义的记录规则. )</li>
<li><code>label</code>满足<code>[a-zA-Z0-9_]*</code>, 以<code>__</code>开头的标签名为内部使用</li>
</ul>
<h3 id="112-samples"><a class="header" href="#112-samples">1.1.2 Samples</a></h3>
<p>来自实际时间序列数据的示例。每个样本包括：</p>
<ul>
<li>
<p>一个float64的值</p>
</li>
<li>
<p>一个毫秒的精确时间戳</p>
</li>
</ul>
<h3 id="113-notation"><a class="header" href="#113-notation">1.1.3 Notation</a></h3>
<p>给定<code>Metric names</code>和一组<code>label</code>, 经常使用此识别时间序列：</p>
<pre><code class="language-text">&lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, ...}
</code></pre>
<h3 id="12-metric-types"><a class="header" href="#12-metric-types">1.2 Metric types</a></h3>
<p><code>Prometheus</code>客户端库提供四种核心度量标准类型</p>
<h4 id="121-counter"><a class="header" href="#121-counter">1.2.1 Counter</a></h4>
<p><code>Counter</code>是一个累积度量标准, 代表单个单调增加的计数器, 其值只能增加或在重新启动时重置为零。例如, 您可以使用计数器来表示已服务的请求数量, 完成任务或错误.</p>
<h4 id="122-gauge"><a class="header" href="#122-gauge">1.2.2 Gauge</a></h4>
<p><code>Gauge</code>是代表可以任意上下改变的单个数值值的度量。通常用于测量值, 例如温度或当前内存使用情况, 但也可以“计数”, 例如同时的请求数量。</p>
<h4 id="123-histogram"><a class="header" href="#123-histogram">1.2.3 Histogram</a></h4>
<p><code>Histogram</code>样本观察（通常是请求持续时间或响应大小的内容）, 并在可配置的存储桶中对其进行计数。它还提供了所有观察到的值的总和。</p>
<h4 id="124-summary"><a class="header" href="#124-summary">1.2.4 Summary</a></h4>
<p>类似于<code>Histogram</code>, <code>Summary</code>样本观察（通常是请求持续时间和响应大小的东西）。虽然它还提供了总检测数量和所有观察到的值的总和, 但它通过滑动时间窗口计算可配置的定量</p>
<h3 id="13-jobs-and-instances"><a class="header" href="#13-jobs-and-instances">1.3 Jobs and instances</a></h3>
<p><code>Job</code>:  采集的工作目标</p>
<p><code>instances</code>:  采集的目标实例</p>
<h2 id="2-promql"><a class="header" href="#2-promql">2. promQL</a></h2>
<p><code>Prometheus</code>提供了一个功能性查询语言, 这使用户可以实时选择和聚合时间序列数据。表达式的结果可以显示为图形, 将其视为<code>Prometheus</code>表达式浏览器中的图形数据, 也可以通过<code>HTTP API</code>被外部系统使用。</p>
<h3 id="21-expression-language-data-types"><a class="header" href="#21-expression-language-data-types">2.1 Expression language data types</a></h3>
<p>在<code>Prometheus</code>的表达语言中, 表达式或子表达包括以下四种类型之一:</p>
<ul>
<li>
<p><code>Instant vector</code> - 瞬时向量集合: 一组时间序列, 每个时间序列的单个样本, 它们共享相同的时间戳</p>
</li>
<li>
<p><code>Range vector</code> - 区间值集合: 一组时间序列, 其中每个时间序列都包含一系列数据点</p>
</li>
<li>
<p><code>Scalar</code> - 标量: 一个简单的数字浮点值</p>
</li>
<li>
<p><code>String</code> - 字符串: 简单的字符串值, 当前未使用</p>
</li>
</ul>
<h3 id="22-literals"><a class="header" href="#22-literals">2.2 literals</a></h3>
<h4 id="221-string-literals"><a class="header" href="#221-string-literals">2.2.1 String literals</a></h4>
<p>字符串可以用单引号, 双引号或反引号。遵循和<code>go</code>一样的转义规则</p>
<h4 id="222-float-literals"><a class="header" href="#222-float-literals">2.2.2 Float literals</a></h4>
<p>标量浮点值可以以格式写入文字整数或浮点数（仅包含用于更好可读性的空格）：</p>
<pre><code class="language-text">[-+]?(
      [0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?
    | 0[xX][0-9a-fA-F]+
    | [nN][aA][nN]
    | [iI][nN][fF]
)
</code></pre>
<h3 id="23-time-series-selectors"><a class="header" href="#23-time-series-selectors">2.3 Time series Selectors</a></h3>
<h4 id="231-instant-vector-selectors"><a class="header" href="#231-instant-vector-selectors">2.3.1 Instant vector selectors</a></h4>
<p>瞬时向量选择器(Instant vector selectors)允许使用简单指定<code>Metric names</code>获取在给定时间戳（瞬时）选择一组时间序列样本值. 结果包含一个时间序列的瞬时向量集合.</p>
<p>比如:</p>
<pre><code class="language-text">http_requests_total
</code></pre>
<p>你可以过滤这些集合, 通过<code>labels</code>进行选择,</p>
<pre><code class="language-text">http_requests_total{job="prometheus",group="canary"}
</code></pre>
<p>以下标签匹配操作：</p>
<ul>
<li><code>=</code>: Select labels that are exactly equal to the provided string.</li>
<li><code>!=</code>: Select labels that are not equal to the provided string.</li>
<li><code>=~</code>: Select labels that regex-match the provided string.</li>
<li><code>!~</code>: Select labels that do not regex-match the provided string.</li>
</ul>
<p><em><strong>NOTE</strong></em>: <code>Metric names</code>不能为关键值,如 <code>bool</code>, <code>on</code>, <code>ignoring</code>, <code>group_left</code> and <code>group_right</code></p>
<h4 id="232-range-vector-selectors"><a class="header" href="#232-range-vector-selectors">2.3.2 Range Vector Selectors</a></h4>
<p>区间向量选择器(Range vector)和瞬时向量集合选择器(Instant vector selectors)一样的工作系统,它从范围内选择一系列瞬时间做为集合的元素.</p>
<pre><code class="language-text"># 表示从过云5分钟内所有http_requests_total且label键值对为job,key的值
http_requests_total{job="prometheus"}[5m]
</code></pre>
<h5 id="time-durations"><a class="header" href="#time-durations">Time Durations</a></h5>
<ul>
<li><code>ms</code> - milliseconds</li>
<li><code>s</code> - seconds</li>
<li><code>m</code> - minutes</li>
<li><code>h</code> - hours</li>
<li><code>d</code> - days - assuming a day has always 24h</li>
<li><code>w</code> - weeks - assuming a week has always 7d</li>
<li><code>y</code> - years - assuming a year has always 365d</li>
</ul>
<h5 id="offset-modifier"><a class="header" href="#offset-modifier">Offset modifier</a></h5>
<p><code>offset</code>允许更改查询中各个瞬间和范围向量的时间偏移.</p>
<pre><code class="language-text">http_requests_total offset 5m
sum(http_requests_total{method="GET"} offset 5m)
rate(http_requests_total[5m] offset 1w)
rate(http_requests_total[5m] offset -1w)
</code></pre>
<h5 id="-modifier"><a class="header" href="#-modifier">@ modifier</a></h5>
<p><code>@</code>修改器允许更改查询中各个即时和范围向量的评估时间。提供给<code>@</code>修改器的时间是UNIX时间戳, 并用浮点文字描述。</p>
<pre><code class="language-text">http_requests_total @ 1609746000
</code></pre>
<h4 id="233-subquery"><a class="header" href="#233-subquery">2.3.3 Subquery</a></h4>
<p>子查询允许您为给定范围和分辨率运行即时查询。子查询的结果是区间向量集合。</p>
<p>语法: <code>&lt;instant_query&gt; '[' &lt;range&gt; ':' [&lt;resolution&gt;] ']' [ @ &lt;float_literal&gt; ] [ offset &lt;duration&gt; ]</code></p>
<ul>
<li><code>&lt;resolution&gt;</code> 是可选的, 默认值是全局评估间隔</li>
</ul>
<h4 id="234-operators"><a class="header" href="#234-operators">2.3.4 Operators</a></h4>
<p><code>Prometheus</code>支持许多二元和聚合操作。</p>
<h4 id="235-functions"><a class="header" href="#235-functions">2.3.5 Functions</a></h4>
<p><code>Prometheus</code>支持多个运行数据的功能.see <a href="https://prometheus.io/docs/prometheus/latest/querying/functions/">Functions</a></p>
<h4 id="236-comments"><a class="header" href="#236-comments">2.3.6 Comments</a></h4>
<p>PromQL supports line comments that start with <code>#</code></p>
<pre><code class="language-text"># This is a comment
</code></pre>
<h4 id="237-gotchas"><a class="header" href="#237-gotchas">2.3.7 Gotchas</a></h4>
<ul>
<li>Staleness</li>
<li>Avoiding slow queries and overloads</li>
</ul>
<h3 id="24-operators"><a class="header" href="#24-operators">2.4 Operators</a></h3>
<h4 id="241-binary-operators"><a class="header" href="#241-binary-operators">2.4.1 Binary operators</a></h4>
<h5 id="arithmetic-binary-operators"><a class="header" href="#arithmetic-binary-operators">Arithmetic binary operators</a></h5>
<ul>
<li><code>+</code> (addition)</li>
<li><code>-</code> (subtraction)</li>
<li><code>*</code> (multiplication)</li>
<li><code>/</code> (division)</li>
<li><code>%</code> (modulo)</li>
<li><code>^</code> (power/exponentiation)</li>
</ul>
<h5 id="comparison-binary-operators"><a class="header" href="#comparison-binary-operators">Comparison binary operators</a></h5>
<ul>
<li><code>==</code> (equal)</li>
<li><code>!=</code> (not-equal)</li>
<li><code>&gt;</code> (greater-than)</li>
<li><code>&lt;</code> (less-than)</li>
<li><code>&gt;=</code> (greater-or-equal)</li>
<li><code>&lt;=</code> (less-or-equal)</li>
</ul>
<h5 id="logicalset-binary-operators"><a class="header" href="#logicalset-binary-operators">Logical/set binary operators</a></h5>
<ul>
<li><code>and</code> (intersection)</li>
<li><code>or</code> (union)</li>
<li><code>unless</code> (complement)</li>
</ul>
<h4 id="242-vector-matching"><a class="header" href="#242-vector-matching">2.4.2 Vector matching</a></h4>
<p>集合之间的操作试图在左侧的每个条目中在右侧矢量中找到匹配元素。匹配行为有两种基本类型：一对一, 一对一/一对一。</p>
<h4 id="243-aggregation-operators"><a class="header" href="#243-aggregation-operators">2.4.3 Aggregation operators</a></h4>
<ul>
<li><code>sum</code> (calculate sum over dimensions)</li>
<li><code>min</code> (select minimum over dimensions)</li>
<li><code>max</code> (select maximum over dimensions)</li>
<li><code>avg</code> (calculate the average over dimensions)</li>
<li><code>group</code> (all values in the resulting vector are 1)</li>
<li><code>stddev</code> (calculate population standard deviation over dimensions)</li>
<li><code>stdvar</code> (calculate population standard variance over dimensions)</li>
<li><code>count</code> (count number of elements in the vector)</li>
<li><code>count_values</code> (count number of elements with the same value)</li>
<li><code>bottomk</code> (smallest k elements by sample value)</li>
<li><code>topk</code> (largest k elements by sample value)</li>
<li><code>quantile</code> (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)</li>
</ul>
<h4 id="244-binary-operator-precedence"><a class="header" href="#244-binary-operator-precedence">2.4.4 Binary operator precedence</a></h4>
<ol>
<li><code>^</code></li>
<li><code>*</code>, <code>/</code>, <code>%</code>, <code>atan2</code></li>
<li><code>+</code>, <code>-</code></li>
<li><code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code></li>
<li><code>and</code>, <code>unless</code></li>
<li><code>or</code></li>
</ol>
<h3 id="25-functions"><a class="header" href="#25-functions">2.5 Functions</a></h3>
<p>see <a href="https://prometheus.io/docs/prometheus/latest/querying/functions/">Functions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xpath语法"><a class="header" href="#xpath语法">XPath语法</a></h1>
<p>XPath 是一门在XML文档中查找信息的语言.</p>
<h2 id="一-简介"><a class="header" href="#一-简介">一. 简介</a></h2>
<h3 id="1-xpath-路径表达式"><a class="header" href="#1-xpath-路径表达式">1. XPath 路径表达式</a></h3>
<p>XPath 使用<strong>路径表达式</strong>来选取 XML 文档中的节点或者节点集.</p>
<p>这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似.</p>
<h3 id="2-xpath-标准函数"><a class="header" href="#2-xpath-标准函数">2. XPath 标准函数</a></h3>
<p>XPath 含有超过 100 个内建的函数.这些函数用于字符串值、数值、日期和时间比较、节点和 QName 处理、序列处理、逻辑值等等.</p>
<h2 id="二-xpath节点"><a class="header" href="#二-xpath节点">二. XPath节点</a></h2>
<p>在 XPath 中,有七种类型的节点：<code>元素</code>、<code>属性</code>、<code>文本</code>、<code>命名空间</code>、<code>处理指令</code>、<code>注释</code>以及<code>文档(根)节点</code>.</p>
<ul>
<li>
<p>XML文档是被作为节点树来对待的.</p>
</li>
<li>
<p>树的根被称为文档节点或者根节点.</p>
</li>
</ul>
<h2 id="三-xpath语法"><a class="header" href="#三-xpath语法">三. XPath语法</a></h2>
<h3 id="1-选取节点"><a class="header" href="#1-选取节点">1. 选取节点</a></h3>
<p>XPath 使用<code>路径表达式</code>来选取 XML 文档中的节点或节点集, 节点是通过沿着<code>路径(path)</code>或者<code>步(steps)</code> 来选取的.</p>
<p>下面列出了最有用的路径表达式</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">表达式</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>nodename</code></td><td style="text-align: left">选取此节点的所有子节点。</td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left">从根节点选取。</td></tr>
<tr><td style="text-align: left"><code>//</code></td><td style="text-align: left">从匹配选择的当前节点选择文档中的节点, 而不考虑它们的位置。</td></tr>
<tr><td style="text-align: left"><code>.</code></td><td style="text-align: left">选取当前节点。</td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left">选取当前节点的父节点。</td></tr>
<tr><td style="text-align: left"><code>@</code></td><td style="text-align: left">选取属性。</td></tr>
</tbody></table>
</div>
<blockquote>
<p>实例:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
&lt;bookstore&gt;
     &lt;book&gt;
        &lt;title lang="eng"&gt;Harry Potter&lt;/title&gt;
          &lt;price&gt;29.99&lt;/price&gt;
      &lt;/book&gt;

     &lt;book&gt;
        &lt;title lang="eng"&gt;Learning XML&lt;/title&gt;
          &lt;price&gt;39.95&lt;/price&gt;
      &lt;/book&gt;
&lt;/bookstore&gt;
</code></pre>
<p>实例选取:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">路径表达式</th><th style="text-align: left">结果</th></tr></thead><tbody>
<tr><td style="text-align: left">bookstore</td><td style="text-align: left">选取 bookstore 元素的所有子节点.</td></tr>
<tr><td style="text-align: left">/bookstore</td><td style="text-align: left">选取根元素 bookstore.<br />注释：假如路径起始于正斜杠( / ),则此路径始终代表到某元素的绝对路径！</td></tr>
<tr><td style="text-align: left">bookstore/book</td><td style="text-align: left">选取属于 bookstore 的子元素的所有 book 元素.</td></tr>
<tr><td style="text-align: left">//book</td><td style="text-align: left">选取所有 book 子元素,而不管它们在文档中的位置.</td></tr>
<tr><td style="text-align: left">bookstore//book</td><td style="text-align: left">选择属于 bookstore 元素的后代的所有 book 元素,而不管它们位于 bookstore 之下的什么位置.</td></tr>
<tr><td style="text-align: left">//@lang</td><td style="text-align: left">选取名为 lang 的所有属性.</td></tr>
<tr><td style="text-align: left">//@lang/text()</td><td style="text-align: left">选取名为 lang 的所有属性下的所有文本</td></tr>
</tbody></table>
</div></blockquote>
<h3 id="2-谓语predicates"><a class="header" href="#2-谓语predicates">2. 谓语（Predicates）</a></h3>
<p>谓语用来查找某个特定的节点或者包含某个指定的值的节点, 谓语被嵌在**<code>方括号[]</code>**中.</p>
<blockquote>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">路径表达式</th><th style="text-align: left">结果</th></tr></thead><tbody>
<tr><td style="text-align: left">/bookstore/book[1]</td><td style="text-align: left">选取属于 bookstore 子元素的第一个 book 元素。</td></tr>
<tr><td style="text-align: left">/bookstore/book[last()]</td><td style="text-align: left">选取属于 bookstore 子元素的最后一个 book 元素。</td></tr>
<tr><td style="text-align: left">/bookstore/book[last()-1]</td><td style="text-align: left">选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr>
<tr><td style="text-align: left">/bookstore/book[position()&lt;3]</td><td style="text-align: left">选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr>
<tr><td style="text-align: left">//title[@lang]</td><td style="text-align: left">选取所有拥有名为 lang 的属性的 title 元素。</td></tr>
<tr><td style="text-align: left">//title[@lang='eng']</td><td style="text-align: left">选取所有 title 元素, 且这些元素拥有值为 eng 的 lang 属性。</td></tr>
<tr><td style="text-align: left">/bookstore/book[price&gt;35.00]</td><td style="text-align: left">选取 bookstore 元素的所有 book 元素, 且其中的 price 元素的值须大于 35.00。</td></tr>
<tr><td style="text-align: left">/bookstore/book[price&gt;35.00]//title</td><td style="text-align: left">选取 bookstore 元素中的 book 元素的所有 title 元素, 且其中的 price 元素的值须大于 35.00。</td></tr>
</tbody></table>
</div></blockquote>
<h3 id="3-选取未知节点"><a class="header" href="#3-选取未知节点">3. 选取未知节点</a></h3>
<p>XPath 通配符可用来选取未知的 <strong>XML 元素</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">通配符</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">匹配任何元素节点.</td></tr>
<tr><td style="text-align: left"><code>@*</code></td><td style="text-align: left">匹配任何属性节点.</td></tr>
<tr><td style="text-align: left"><code>node()</code></td><td style="text-align: left">匹配任何类型的节点.</td></tr>
</tbody></table>
</div>
<p>在下面的表格中,我们列出了一些路径表达式,以及这些表达式的结果：</p>
<blockquote>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">路径表达式</th><th style="text-align: left">结果</th></tr></thead><tbody>
<tr><td style="text-align: left">/bookstore/*</td><td style="text-align: left">选取 bookstore 元素的所有子元素.</td></tr>
<tr><td style="text-align: left">//*</td><td style="text-align: left">选取文档中的所有元素.</td></tr>
<tr><td style="text-align: left">//title[@*]</td><td style="text-align: left">选取所有带有属性的 title 元素.</td></tr>
</tbody></table>
</div></blockquote>
<h3 id="4-选取若干路径"><a class="header" href="#4-选取若干路径">4. 选取若干路径</a></h3>
<p>通过在路径表达式中使用<code>"|"</code>运算符选取<strong>多个路径</strong>.</p>
<p>在下面的表格中,我们列出了一些路径表达式,以及这些表达式的结果：</p>
<blockquote>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">路径表达式</th><th style="text-align: left">结果</th></tr></thead><tbody>
<tr><td style="text-align: left">//book/title | //book/price</td><td style="text-align: left">选取 book 元素的所有 title 和 price 元素.</td></tr>
<tr><td style="text-align: left">//title | //price</td><td style="text-align: left">选取文档中的所有 title 和 price 元素.</td></tr>
<tr><td style="text-align: left">/bookstore/book/title | //price</td><td style="text-align: left">选取属于 bookstore 元素的 book 元素的所有 title 元素,以及文档中所有的 price 元素.</td></tr>
</tbody></table>
</div></blockquote>
<h2 id="四-xpath-轴axes"><a class="header" href="#四-xpath-轴axes">四. XPath 轴（Axes）</a></h2>
<p>轴可定义相对于当前节点的节点集.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">轴名称</th><th style="text-align: left">结果</th></tr></thead><tbody>
<tr><td style="text-align: left">ancestor</td><td style="text-align: left">选取当前节点的所有先辈（父、祖父等）。</td></tr>
<tr><td style="text-align: left">ancestor-or-self</td><td style="text-align: left">选取当前节点的所有先辈（父、祖父等）以及当前节点本身。</td></tr>
<tr><td style="text-align: left">attribute</td><td style="text-align: left">选取当前节点的所有属性。</td></tr>
<tr><td style="text-align: left">child</td><td style="text-align: left">选取当前节点的所有子元素。</td></tr>
<tr><td style="text-align: left">descendant</td><td style="text-align: left">选取当前节点的所有后代元素（子、孙等）。</td></tr>
<tr><td style="text-align: left">descendant-or-self</td><td style="text-align: left">选取当前节点的所有后代元素（子、孙等）以及当前节点本身。</td></tr>
<tr><td style="text-align: left">following</td><td style="text-align: left">选取文档中当前节点的结束标签之后的所有节点。</td></tr>
<tr><td style="text-align: left">following-sibling</td><td style="text-align: left">选取当前节点之后的所有兄弟节点</td></tr>
<tr><td style="text-align: left">namespace</td><td style="text-align: left">选取当前节点的所有命名空间节点。</td></tr>
<tr><td style="text-align: left">parent</td><td style="text-align: left">选取当前节点的父节点。</td></tr>
<tr><td style="text-align: left">preceding</td><td style="text-align: left">选取文档中当前节点的开始标签之前的所有节点。</td></tr>
<tr><td style="text-align: left">preceding-sibling</td><td style="text-align: left">选取当前节点之前的所有同级节点。</td></tr>
<tr><td style="text-align: left">self</td><td style="text-align: left">选取当前节点</td></tr>
</tbody></table>
</div>
<h2 id="五-xpath-运算符"><a class="header" href="#五-xpath-运算符">五. XPath 运算符</a></h2>
<p>XPath 表达式可返回节点集、字符串、逻辑值以及数字</p>
<p>下面列出了可用在 XPath 表达式中的运算符：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th><th style="text-align: left">返回值</th></tr></thead><tbody>
<tr><td style="text-align: left">`</td><td style="text-align: left">`</td><td style="text-align: left">计算两个节点集</td><td style="text-align: left">//book | //cd</td></tr>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left">加法</td><td style="text-align: left">6 + 4</td><td style="text-align: left">10</td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left">减法</td><td style="text-align: left">6 - 4</td><td style="text-align: left">2</td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">乘法</td><td style="text-align: left">6 * 4</td><td style="text-align: left">24</td></tr>
<tr><td style="text-align: left"><code>div</code></td><td style="text-align: left">除法</td><td style="text-align: left">8 div 4</td><td style="text-align: left">2</td></tr>
<tr><td style="text-align: left"><code>=</code></td><td style="text-align: left">等于</td><td style="text-align: left">price=9.80</td><td style="text-align: left">如果 price 是 9.80,则返回 true.如果 price 是 9.90,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left">不等于</td><td style="text-align: left">price!=9.80</td><td style="text-align: left">如果 price 是 9.90,则返回 true.如果 price 是 9.80,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left">小于</td><td style="text-align: left">price&lt;9.80</td><td style="text-align: left">如果 price 是 9.00,则返回 true.如果 price 是 9.90,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left">小于或等于</td><td style="text-align: left">price&lt;=9.80</td><td style="text-align: left">如果 price 是 9.00,则返回 true.如果 price 是 9.90,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left">大于</td><td style="text-align: left">price&gt;9.80</td><td style="text-align: left">如果 price 是 9.90,则返回 true.如果 price 是 9.80,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left">大于或等于</td><td style="text-align: left">price&gt;=9.80</td><td style="text-align: left">如果 price 是 9.90,则返回 true.如果 price 是 9.70,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>or</code></td><td style="text-align: left">或</td><td style="text-align: left">price=9.80 or price=9.70</td><td style="text-align: left">如果 price 是 9.80,则返回 true.如果 price 是 9.50,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>and</code></td><td style="text-align: left">与</td><td style="text-align: left">price&gt;9.00 and price&lt;9.90</td><td style="text-align: left">如果 price 是 9.80,则返回 true.如果 price 是 8.50,则返回 false.</td></tr>
<tr><td style="text-align: left"><code>mod</code></td><td style="text-align: left">计算除法的余数</td><td style="text-align: left">5 mod 2</td><td style="text-align: left">1</td></tr>
</tbody></table>
</div>
<h2 id="六-函数"><a class="header" href="#六-函数">六. 函数</a></h2>
<p><a href="https://www.w3school.com.cn/xpath/xpath_functions.asp">函数</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css选择器"><a class="header" href="#css选择器">css选择器</a></h1>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#css%E9%80%89%E6%8B%A9%E5%99%A8">css选择器</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#1-%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8">1. 基本选择器</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#11-%E9%80%9A%E9%85%8D%E9%80%89%E6%8B%A9%E5%99%A8">1.1 通配选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#12-%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8">1.2 元素选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#13-%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8">1.3. 类选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#14-id%E9%80%89%E6%8B%A9%E5%99%A8">1.4. ID选择器</a></li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#2-%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8">2. 复合选择器</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#21-%E4%BA%A4%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8">2.1 交集选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#22-%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8">2.2 并集选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#23-%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8">2.3. 后代选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#24-%E5%AD%90%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8">2.4. 子代选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#25-%E7%9B%B8%E9%82%BB%E5%85%84%E5%BC%9F%E9%80%89%E6%8B%A9%E5%99%A8">2.5. 相邻兄弟选择器</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#26-%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8">2.6. 属性选择器</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#261-%E7%AE%80%E5%8D%95%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9">2.6.1. 简单属性选择</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#262-%E6%A0%B9%E6%8D%AE%E5%85%B7%E4%BD%93%E5%B1%9E%E6%80%A7%E5%80%BC%E9%80%89%E6%8B%A9">2.6.2. 根据具体属性值选择</a></li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#27-%E4%BC%AA%E7%B1%BB">2.7. 伪类</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#271-%E9%94%9A%E4%BC%AA%E7%B1%BB">2.7.1. 锚伪类</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#272-%E7%BB%93%E6%9E%84%E4%BC%AA%E7%B1%BB">2.7.2. 结构伪类</a></li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#28-%E4%BC%AA%E5%85%83%E7%B4%A0">2.8. 伪元素</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#281-first-line%E4%BC%AA%E5%85%83%E7%B4%A0">2.8.1. <code>"first-line"</code>伪元素</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#282-first-letter%E4%BC%AA%E5%85%83%E7%B4%A0">2.8.2. <code>:first-letter</code>伪元素</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#283-before%E4%BC%AA%E5%85%83%E7%B4%A0">2.8.3. <code>:before</code>伪元素</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#284-after%E4%BC%AA%E5%85%83%E7%B4%A0">2.8.4. <code>after</code>伪元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#3-%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D">3. 选择器权重</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#4-css%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">4. CSS三大特性</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#41-%E5%B1%82%E5%8F%A0%E6%80%A7">4.1. 层叠性</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#42-%E7%BB%A7%E6%89%BF%E6%80%A7">4.2 继承性</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#43-%E4%BC%98%E5%85%88%E7%BA%A7">4.3 优先级</a></li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#5-css%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">5. CSS常用属性</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#51-%E9%A2%9C%E8%89%B2">5.1 颜色</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#511-rgbrgba">5.1.1 rgb/rgba</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#512-hexhexa">5.1.2 HEX/HEXA</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#513-hslhsla">5.1.3 HSL/HSLA</a></li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#52-%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7">5.2 字体属性</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#521-%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F">5.2.1 字体大小</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#522-%E5%AD%97%E4%BD%93%E6%97%8F">5.2.2 字体族</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#523-%E5%AD%97%E4%BD%93%E9%A3%8E%E6%A0%BC">5.2.3 字体风格</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#524-%E5%AD%97%E4%BD%93%E7%B2%97%E7%BB%86">5.2.4 字体粗细</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#525-%E5%AD%97%E4%BD%93%E5%A4%8D%E5%90%88%E5%86%99%E6%B3%95">5.2.5 字体复合写法</a></li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#53-%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7">5.3 文本属性</a>
<ul>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#531-%E6%96%87%E6%9C%AC%E9%A2%9C%E8%89%B2">5.3.1 文本颜色</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#532-%E6%96%87%E6%9C%AC%E9%97%B4%E8%B7%9D">5.3.2 文本间距</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#533-%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0">5.3.3 文本修饰</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#534-%E6%96%87%E6%9C%AC%E7%BC%A9%E8%BF%9B">5.3.4 文本缩进</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#535-%E6%96%87%E6%9C%AC%E6%B0%B4%E5%B9%B3%E5%AF%B9%E9%BD%90">5.3.5 文本水平对齐</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#536-%E6%96%87%E6%9C%AC%E5%9E%82%E7%9B%B4%E5%AF%B9%E9%BD%90">5.3.6 文本垂直对齐</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#537-%E8%A1%8C%E9%AB%98">5.3.7 行高</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#537-vertical-align">5.3.7 vertical-align</a></li>
</ul>
</li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#54-%E5%88%97%E8%A1%A8%E5%B1%9E%E6%80%A7">5.4 列表属性</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#55-%E8%BE%B9%E6%A1%86%E5%B1%9E%E6%80%A7">5.5 边框属性</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#56-%E8%A1%A8%E6%A0%BC%E5%B1%9E%E6%80%A7">5.6 表格属性</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#57-%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7">5.7 背景属性</a></li>
<li><a href="pickup/05-css%E9%80%89%E6%8B%A9%E5%99%A8%E6%B1%87%E6%80%BB.html#57%E9%BC%A0%E6%A0%87%E5%B1%9E%E6%80%A7">5.7鼠标属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="pickup/../assets/css_selector.gif" alt="selector" /></p>
<h2 id="1-基本选择器"><a class="header" href="#1-基本选择器">1. 基本选择器</a></h2>
<h3 id="11-通配选择器"><a class="header" href="#11-通配选择器">1.1 通配选择器</a></h3>
<pre><code class="language-css">/* 选中所有元素 */
* {
  color: orange;
  font-size: 40px;
}
</code></pre>
<h3 id="12-元素选择器"><a class="header" href="#12-元素选择器">1.2 元素选择器</a></h3>
<p>文档的元素就是元素选择器,是最基本的选择器</p>
<pre><code class="language-css">html { color:black; }
h1 { color:blue; }
h2 { color:silver; }
</code></pre>
<h3 id="13-类选择器"><a class="header" href="#13-类选择器">1.3. 类选择器</a></h3>
<p>类选择器允许以一种独立于文档元素的方式来指定样式.</p>
<pre><code class="language-html">&lt;h1 class="important"&gt;
This heading is very important.
&lt;/h1&gt;
</code></pre>
<pre><code class="language-css">.important {color:red;}
</code></pre>
<h3 id="14-id选择器"><a class="header" href="#14-id选择器">1.4. ID选择器</a></h3>
<p>ID选择器允许以一种独立于文档元素的方式来指定样式</p>
<pre><code class="language-html">&lt;p id="intro"&gt;This is a paragraph of introduction.&lt;/p&gt;
</code></pre>
<pre><code class="language-css">#intro {font-weight:bold;}
</code></pre>
<h2 id="2-复合选择器"><a class="header" href="#2-复合选择器">2. 复合选择器</a></h2>
<h3 id="21-交集选择器"><a class="header" href="#21-交集选择器">2.1 交集选择器</a></h3>
<p>选中同时符合多个条件的元素</p>
<pre><code class="language-css">/* 选中:类名为beauty的p元素, 为此种写法用的非常多!!!! */
p.beauty {
  color: blue;
}
/* 选中:类名包含rich和beauty的元素 */
.rich.beauty {
  color: green;
}
</code></pre>
<h3 id="22-并集选择器"><a class="header" href="#22-并集选择器">2.2 并集选择器</a></h3>
<p>选中多个选择器对应的元素(<code>以','分隔</code>), 被分组的选择器就可以分享相同的声明, 又称:分组选择器</p>
<pre><code class="language-css">h1,
h2,
h3,
h4,
h5,
h6 {
  color: green;
}
</code></pre>
<h3 id="23-后代选择器"><a class="header" href="#23-后代选择器">2.3. 后代选择器</a></h3>
<p>后代选择器可以选择作为某元素后代的元素(<code>以空格分隔</code>)</p>
<pre><code class="language-css">h1 em {color:red;}
</code></pre>
<h3 id="24-子代选择器"><a class="header" href="#24-子代选择器">2.4. 子代选择器</a></h3>
<p>与后代选择器相比, 子元素选择器只能选择作为某元素子元素的元素(<code>以&gt;分隔</code>).</p>
<pre><code class="language-css">h1 &gt; strong {color:red;}
</code></pre>
<h3 id="25-相邻兄弟选择器"><a class="header" href="#25-相邻兄弟选择器">2.5. 相邻兄弟选择器</a></h3>
<p>相邻兄弟选择器 (Adjacent sibling selector) 可选择<strong>紧接</strong>在另一元素后的元素, 且二者有相同父元素(<code>以+分隔</code>).</p>
<pre><code class="language-css">h1 + p {margin-top:50px;}
</code></pre>
<h3 id="26-属性选择器"><a class="header" href="#26-属性选择器">2.6. 属性选择器</a></h3>
<p>属性选择器可以根据元素的属性及属性值来选择元素.</p>
<h4 id="261-简单属性选择"><a class="header" href="#261-简单属性选择">2.6.1. 简单属性选择</a></h4>
<p>如果您希望把包含标题 (title) 的所有元素变为红色, 可以写作:</p>
<pre><code class="language-css">*[title] {color:red;}  // 把包含标题 (title) 的所有元素变为红色
a[href] {color:red;} // 只对有 href 属性的锚 (a 元素) 应用样式
a[href][title] {color:red;} // 将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色
img[alt] {border: 5px solid red;} // 所有带有 alt 属性的图像应用样式, 从而突出显示这些有效的图像
</code></pre>
<h4 id="262-根据具体属性值选择"><a class="header" href="#262-根据具体属性值选择">2.6.2. 根据具体属性值选择</a></h4>
<pre><code class="language-css">a[href="http://www.w3school.com.cn/"][title="W3School"] {color: red;} // 把多个属性-值选择器链接在一起来选择一个文档
p[class="important warning"] {color: red;} // 根据具体属性值来选择该元素
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">选择器</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute.asp"><em>attribute</em>]</a></td><td style="text-align: left">选取带有<code>attribute</code>属性的元素.</td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute_value.asp"><em>attribute</em>=<em>value</em>]</a></td><td style="text-align: left">选取<code>attribute</code>属性值为<code>value</code>的元素.</td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute_value_contain.asp"><em>attribute</em>~=<em>value</em>]</a></td><td style="text-align: left">选取<code>attribute</code>属性值中包含<code>value</code>的元素.</td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/cssref/selector_attribute_value_start.asp"><em>attribute</em>|=<em>value</em>]</a></td><td style="text-align: left">选取<code>attribute</code>属性值等于<code>value</code>或<code>value</code>开头的元素, 该值必须是整个单词.</td></tr>
<tr><td style="text-align: left">[<a href="https://www.w3school.com.cn/cssref/selector_attr_begin.asp"><em>attribute</em>^=<em>value</em>]</a></td><td style="text-align: left">选取<code>attribute</code>属性值<code>value</code>开头的每个元素.</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/cssref/selector_attr_end.asp">[<em>attribute</em>$=value]</a></td><td style="text-align: left">选取<code>attribute</code>属性值value结尾的每个元素.</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/cssref/selector_attr_contain.asp">[attribute*=value]</a></td><td style="text-align: left">选取<code>attribute</code>属性值包含<code>value</code>的每个元素.</td></tr>
</tbody></table>
</div>
<h3 id="27-伪类"><a class="header" href="#27-伪类">2.7. 伪类</a></h3>
<p>伪类用于向某些选择器添加特殊的效果</p>
<pre><code class="language-css">selector : pseudo-class {property: value}
</code></pre>
<h4 id="271-锚伪类"><a class="header" href="#271-锚伪类">2.7.1. 锚伪类</a></h4>
<pre><code class="language-css">a:link {color: #FF0000}    /* 未访问的元素 */
a:visited {color: #00FF00}  /* 已访问的元素 */
a:hover {color: #FF00FF}  /* 鼠标悬停在元素上 */
a:active {color: #0000FF}  /* 激活的元素 */
a:focus {color: #0000FF}  /* 获取焦点的元素 */
</code></pre>
<h4 id="272-结构伪类"><a class="header" href="#272-结构伪类">2.7.2. 结构伪类</a></h4>
<ul>
<li><code>:first-child</code> 所有兄弟元素中的<strong>第一个</strong>.</li>
<li><code>:last-child</code> 所有兄弟元素中的<strong>最后一个</strong>.</li>
<li><code>:nth-child(n)</code> 所有兄弟元素中的<strong>第 n 个</strong>.</li>
<li><code>:first-of-type</code> 所有同类型兄弟元素中的<strong>第一个</strong>.</li>
<li><code>:last-of-type</code> 所有同类型兄弟元素中的<strong>最后一个</strong>.</li>
<li><code>:nth-of-type(n)</code> 所有同类型兄弟元素中的<strong>第n个</strong>.</li>
<li><code>:nth-last-child(n)</code> 所有兄弟元素中的<strong>倒数第n个</strong>.</li>
<li><code>:nth-last-of-type(n)</code> 所有同类型兄弟元素中的<strong>倒数第n个</strong>.</li>
<li><code>:only-child</code> 选择没有兄弟的元素 (独生子女).</li>
<li><code>:only-of-type</code> 选择没有<strong>同类型</strong>兄弟的元素.</li>
<li><code>:root</code> 根元素.</li>
<li><code>:empty</code> 内容为空元素 (空格也算内容).</li>
<li><code>:not(选择器)</code> 排除满足括号中条件的元素.</li>
<li><code>:checked</code> 被选中的复选框或单选按钮.</li>
<li><code>:enable</code> 可用的表单元素 (没有 <code>disabled</code> 属性).</li>
<li><code>:disabled</code> 不可用的表单元素 (有 <code>disabled</code> 属性)</li>
<li><code>:target</code> 选中锚点指向的元素.</li>
<li><code>:lang()</code> 根据指定的语言选择元素 (本质是看 lang 属性的值).</li>
</ul>
<h3 id="28-伪元素"><a class="header" href="#28-伪元素">2.8. 伪元素</a></h3>
<p>伪元素用于向某些选择器设置特殊效果</p>
<pre><code class="language-css">selector:pseudo-element {property:value;}
</code></pre>
<h4 id="281-first-line伪元素"><a class="header" href="#281-first-line伪元素">2.8.1. <code>"first-line"</code>伪元素</a></h4>
<p><code>"first-line"</code> 伪元素用于向文本的首行设置特殊样式.</p>
<pre><code class="language-css">p:first-line  {
  color:#ff0000;
  font-variant:small-caps;
  }
</code></pre>
<p><strong>注释:</strong>"first-line" 伪元素只能用于块级元素.</p>
<p>**注释:**下面的属性可应用于 "first-line" 伪元素:</p>
<ul>
<li>font</li>
<li>color</li>
<li>background</li>
<li>word-spacing</li>
<li>letter-spacing</li>
<li>text-decoration</li>
<li>vertical-align</li>
<li>text-transform</li>
<li>line-height</li>
<li>clear</li>
</ul>
<h4 id="282-first-letter伪元素"><a class="header" href="#282-first-letter伪元素">2.8.2. <code>:first-letter</code>伪元素</a></h4>
<p><code>first-letter</code> 伪元素用于向文本的首字母设置特殊样式:</p>
<pre><code class="language-css">p:first-letter
  {
  color:#ff0000;
  font-size:xx-large;
  }
</code></pre>
<p><strong>注释:</strong>"first-letter" 伪元素只能用于块级元素.</p>
<p>**注释:**下面的属性可应用于 "first-letter" 伪元素:</p>
<ul>
<li>font</li>
<li>color</li>
<li>background</li>
<li>margin</li>
<li>padding</li>
<li>border</li>
<li>text-decoration</li>
<li>vertical-align (仅当 float 为 none 时)</li>
<li>text-transform</li>
<li>line-height</li>
<li>float</li>
<li>clear</li>
</ul>
<h4 id="283-before伪元素"><a class="header" href="#283-before伪元素">2.8.3. <code>:before</code>伪元素</a></h4>
<p><code>:before</code>伪元素可以在元素的内容前面插入新内容</p>
<pre><code class="language-css">h1:before{
  content:url(logo.gif);
  }
</code></pre>
<h4 id="284-after伪元素"><a class="header" href="#284-after伪元素">2.8.4. <code>after</code>伪元素</a></h4>
<p><code>:after</code> 伪元素可以在元素的内容之后插入新内容.</p>
<pre><code class="language-css">h1:after{
  content:url(logo.gif);
  }
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th><th style="text-align: left">CSS</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/cssref/pr_pseudo_first-letter.asp">:first-letter</a></td><td style="text-align: left">向文本的第一个字母添加特殊样式.</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/cssref/pr_pseudo_first-line.asp">:first-line</a></td><td style="text-align: left">向文本的首行添加特殊样式.</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/cssref/pr_pseudo_before.asp">:before</a></td><td style="text-align: left">在元素之前添加内容.</td><td style="text-align: left">2</td></tr>
<tr><td style="text-align: left"><a href="https://www.w3school.com.cn/cssref/pr_pseudo_after.asp">:after</a></td><td style="text-align: left">在元素之后添加内容.</td><td style="text-align: left">2</td></tr>
</tbody></table>
</div>
<h2 id="3-选择器权重"><a class="header" href="#3-选择器权重">3. 选择器权重</a></h2>
<blockquote>
<p>行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配选择器.</p>
</blockquote>
<h2 id="4-css三大特性"><a class="header" href="#4-css三大特性">4. CSS三大特性</a></h2>
<h3 id="41-层叠性"><a class="header" href="#41-层叠性">4.1. 层叠性</a></h3>
<p>如果发生了样式冲突, 那就会根据一定的规则 (选择器优先级), 进行样式的层叠 (覆
盖).</p>
<h3 id="42-继承性"><a class="header" href="#42-继承性">4.2 继承性</a></h3>
<p>元素会自动拥有其父元素、或其祖先元素上所设置的某些样式. 优先继承离得近的.</p>
<h3 id="43-优先级"><a class="header" href="#43-优先级">4.3 优先级</a></h3>
<blockquote>
<p><code>!important</code> &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; * &gt; 继承的样式</p>
</blockquote>
<h2 id="5-css常用属性"><a class="header" href="#5-css常用属性">5. CSS常用属性</a></h2>
<h3 id="51-颜色"><a class="header" href="#51-颜色">5.1 颜色</a></h3>
<h4 id="511-rgbrgba"><a class="header" href="#511-rgbrgba">5.1.1 rgb/rgba</a></h4>
<pre><code class="language-css">/* 使用 0~255 之间的数字表示一种颜色 */
color: rgb(255, 0, 0);/* 红色 */
color: rgb(0, 255, 0);/* 绿色 */
color: rgb(0, 0, 255);/* 蓝色 */
color: rgb(0, 0, 0);/* 黑色 */
color: rgb(255, 255, 255);/* 白色 */
/* 混合出任意一种颜色 */
color:rgb(138, 43, 226) /* 紫罗兰色 */
color:rgba(255, 0, 0, 0.5);/* 半透明的红色 */
/* 也可以使用百分比表示一种颜色 (用的少)  */
color: rgb(100%, 0%, 0%);/* 红色 */
color: rgba(100%, 0%, 0%,50%);/* 半透明的红色 */
</code></pre>
<h4 id="512-hexhexa"><a class="header" href="#512-hexhexa">5.1.2 HEX/HEXA</a></h4>
<pre><code class="language-css">color: #ff0000;/* 红色 */
color: #00ff00;/* 绿色 */
color: #0000ff;/* 蓝色 */
color: #000000;/* 黑色 */
color: #ffffff;/* 白色 */
/* 如果每种颜色的两位都是相同的, 就可以简写*/
color: #ff9988;/* 可简为:#f98 */
/* 但要注意前三位简写了, 那么透明度就也要简写 */
color: #ff998866;/* 可简为:#f986 */
</code></pre>
<h4 id="513-hslhsla"><a class="header" href="#513-hslhsla">5.1.3 HSL/HSLA</a></h4>
<p>格式: <code>hsl(色相,饱和度,亮度)</code>/<code>hsla(色相,饱和度,亮度,透明度)</code></p>
<h3 id="52-字体属性"><a class="header" href="#52-字体属性">5.2 字体属性</a></h3>
<h4 id="521-字体大小"><a class="header" href="#521-字体大小">5.2.1 字体大小</a></h4>
<p><code>font-size</code>控制字体的大小</p>
<pre><code class="language-css">div {
  font-size: 40px;
}
</code></pre>
<h4 id="522-字体族"><a class="header" href="#522-字体族">5.2.2 字体族</a></h4>
<p><code>font-family</code>控制字体类型</p>
<pre><code class="language-css">div {
  font-family: "STCaiyun","Microsoft YaHei",sans-serif
}
</code></pre>
<h4 id="523-字体风格"><a class="header" href="#523-字体风格">5.2.3 字体风格</a></h4>
<p><code>font-style</code>控制字体是否为斜体</p>
<pre><code class="language-css">div {
  font-style: italic;
}
</code></pre>
<h4 id="524-字体粗细"><a class="header" href="#524-字体粗细">5.2.4 字体粗细</a></h4>
<p><code>font-weight</code>控制字体的粗细</p>
<ul>
<li><code>lighter</code>:细</li>
<li><code>normal</code>: 正常</li>
<li><code>bold</code>:粗</li>
<li><code>bolder</code>:很粗</li>
</ul>
<pre><code class="language-css">div {
  font-weight: bold;
}
div {
  font-weight: 600;
}
</code></pre>
<h4 id="525-字体复合写法"><a class="header" href="#525-字体复合写法">5.2.5 字体复合写法</a></h4>
<p>字体大小、字体族必须都写上, 字体族必须是最后一位、字体大小必须是倒数第二位.各个属性间用空格隔开.</p>
<pre><code class="language-css">div {
  font: 20px "STCaiyun","Microsoft YaHei",sans-serif;
}
</code></pre>
<h3 id="53-文本属性"><a class="header" href="#53-文本属性">5.3 文本属性</a></h3>
<h4 id="531-文本颜色"><a class="header" href="#531-文本颜色">5.3.1 文本颜色</a></h4>
<p><code>color</code>控制文字的颜色</p>
<pre><code class="language-css">p {
  color: rgb(112,45,78);
}
</code></pre>
<h4 id="532-文本间距"><a class="header" href="#532-文本间距">5.3.2 文本间距</a></h4>
<ul>
<li>字母间距: <code>letter-spacing</code></li>
<li>单词间距: <code>word-spacing</code> (通过空格识别词)</li>
<li>属性值为像素 (<code>px</code>) , 正值让间距增大, 负值让间距缩小</li>
</ul>
<h4 id="533-文本修饰"><a class="header" href="#533-文本修饰">5.3.3 文本修饰</a></h4>
<p><code>text-decoration</code>控制文本的各种装饰线, 可选值:</p>
<ul>
<li><code>none</code>: 无装饰线 (常用)</li>
<li><code>underline</code>:下划线 (常用)</li>
<li><code>overline</code>: 上划线</li>
<li><code>line-through</code>: 删除线</li>
</ul>
<h4 id="534-文本缩进"><a class="header" href="#534-文本缩进">5.3.4 文本缩进</a></h4>
<p><code>text-indent</code>控制文本首字母的缩进.</p>
<pre><code class="language-css">div {
  text-indent:40px;
}
</code></pre>
<h4 id="535-文本水平对齐"><a class="header" href="#535-文本水平对齐">5.3.5 文本水平对齐</a></h4>
<p><code>text-align</code>控制文本的水平对齐方式:</p>
<ul>
<li><code>left</code>: 左对齐 (默认值)</li>
<li><code>right</code>: 右对齐</li>
<li><code>center</code>: 居中对齐</li>
</ul>
<pre><code class="language-css">div {
  text-align: center;
}
</code></pre>
<h4 id="536-文本垂直对齐"><a class="header" href="#536-文本垂直对齐">5.3.6 文本垂直对齐</a></h4>
<p>顶部:无需任何属性, 在垂直方向上, 默认就是顶部对齐
居中:对于单行文字, 让 <code>height = line-height</code> 即可</p>
<h4 id="537-行高"><a class="header" href="#537-行高">5.3.7 行高</a></h4>
<p><code>line-height</code>控制一行文字的高度.</p>
<pre><code class="language-css">div {
  line-height: 60px;
  line-height: 1.5; /* 参考自身 font-size 的倍数 */
  line-height: 150%; /* 参考自身 font-size 的百分比 */
}
</code></pre>
<h4 id="537-vertical-align"><a class="header" href="#537-vertical-align">5.3.7 vertical-align</a></h4>
<p><code>vertical-align</code>用于指定同一行元素之间, 或 表格单元格 内文字的 垂直对齐方式, 不能控制块元素.</p>
<ul>
<li><code>baseline</code>  (默认值) :使元素的基线与父元素的基线对齐.</li>
<li><code>top</code>:使元素的顶部与其所在行的顶部对齐.</li>
<li><code>middle</code>:使元素的中部与父元素的基线加上父元素字母 x 的一半对齐.</li>
<li><code>bottom</code>:使元素的底部与其所在行的底部对齐.</li>
</ul>
<h3 id="54-列表属性"><a class="header" href="#54-列表属性">5.4 列表属性</a></h3>
<p>列表相关的属性, 可以作用在 <code>ul</code> 、 <code>ol</code> 、 <code>li</code> 元素上.</p>
<p><code>list-style-type</code>设置列表符号</p>
<ul>
<li><code>none</code>:不显示前面的标识 (很常用!)</li>
<li><code>square</code>:实心方块</li>
<li><code>disc</code>:圆形</li>
<li><code>decimal</code>:数字</li>
<li><code>lower-roman</code>:小写罗马字</li>
<li><code>upper-roman</code>:大写罗马字</li>
<li><code>lower-alpha</code>:小写字母</li>
<li><code>upper-alpha</code>:大写字母</li>
</ul>
<p><code>list-style-position</code>设置列表符号的位置</p>
<ul>
<li><code>inside</code>:在 <code>li</code> 的里面</li>
<li><code>outside</code>:在 <code>li</code> 的外边</li>
</ul>
<p><code>list-style-image</code>自定义列表符号, <code>url(图片地址)</code>
<code>list-style</code>复合属性, 没有数量、顺序的要求</p>
<h3 id="55-边框属性"><a class="header" href="#55-边框属性">5.5 边框属性</a></h3>
<p><code>border-width</code>边框宽度CSS 中可用的长度值
<code>border-color</code>边框颜色CSS 中可用的颜色值
<code>border-style</code>边框风格</p>
<ul>
<li><code>none</code> 默认值</li>
<li><code>solid</code> 实线</li>
<li><code>dashed</code> 虚线</li>
<li><code>dotted</code> 点线</li>
<li><code>double</code> 双实线</li>
</ul>
<p><code>border</code>边框复合属性, 没有数量、顺序的要求</p>
<h3 id="56-表格属性"><a class="header" href="#56-表格属性">5.6 表格属性</a></h3>
<p><img src="pickup/../assets/css-table.png" alt="background" /></p>
<h3 id="57-背景属性"><a class="header" href="#57-背景属性">5.7 背景属性</a></h3>
<p><img src="pickup/../assets/css-background.png" alt="background" /></p>
<h3 id="57鼠标属性"><a class="header" href="#57鼠标属性">5.7鼠标属性</a></h3>
<p><img src="pickup/../assets/css-cursor.png" alt="background" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opentelemetry"><a class="header" href="#opentelemetry">opentelemetry</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grep-sed-awk"><a class="header" href="#grep-sed-awk">grep sed awk</a></h1>
<h2 id="1-grep"><a class="header" href="#1-grep">1. grep</a></h2>
<p>作用: 文本搜索工具, 根据用户指定的"模式"(过滤条件)对目标文本逐行进行匹配检查, 打印匹配到行.</p>
<p>模式: 由正则表达式的<code>元字符</code>及<code>文本字符</code>所编写的<code>过滤条件</code></p>
<pre><code>grep [options] [pattern] file
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>参数选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-v</code></td><td>排除匹配结果</td></tr>
<tr><td><code>-n</code></td><td>显示匹配行与行号</td></tr>
<tr><td><code>-i</code></td><td>不区分大小写</td></tr>
<tr><td><code>-c</code></td><td>只统计匹配的行数</td></tr>
<tr><td><code>-E</code></td><td>只统计匹配的行数</td></tr>
<tr><td><code>--color=auto</code></td><td>为grep过滤结果添加颜色</td></tr>
<tr><td><code>-w</code></td><td>只匹配过滤的单词</td></tr>
<tr><td><code>-o</code></td><td>只输出匹配的内容</td></tr>
</tbody></table>
</div>
<h2 id="2-sed"><a class="header" href="#2-sed">2. sed</a></h2>
<pre><code>sed [options] [sed内置命令字符] [file]
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>参数选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-n</code></td><td>取消默认sed的输出, 常与sed内置命令p一起用</td></tr>
<tr><td><code>-i</code></td><td>直接将修改结果写入文件, 不同-i, sed 修改的是内存数据</td></tr>
<tr><td><code>-e</code></td><td>多次编辑,不需要管道符</td></tr>
<tr><td><code>-r</code></td><td>支持正则扩展</td></tr>
</tbody></table>
</div>
<p><code>sed</code>的<code>内置命令字符</code>用于文件进行不同的操作功能, 如对文件增删改查</p>
<div class="table-wrapper"><table><thead><tr><th><code>sed</code>的<code>内置命令字符</code></th><th>说明</th></tr></thead><tbody>
<tr><td><code>a</code></td><td>append, 对文件追加, 在指定行后面添加一行/多行文件</td></tr>
<tr><td><code>d</code></td><td>delete, 删除匹配行</td></tr>
<tr><td><code>i</code></td><td>insert, 表式插入文本, 在指定行前添加一行/多行文本</td></tr>
<tr><td><code>p</code></td><td>print, 打印匹配行的内容, 通常<code>p</code>与<code>-n</code>一起使用</td></tr>
<tr><td><code>s/正则/替换内容/g</code></td><td>匹配正则内容,然后替换内容(支持正则), 结尾g代表全局匹配</td></tr>
</tbody></table>
</div>
<p><code>sed</code>的<code>匹配范围</code></p>
<div class="table-wrapper"><table><thead><tr><th>范围</th><th>说明</th></tr></thead><tbody>
<tr><td>空地址</td><td>全文处理</td></tr>
<tr><td>单地址</td><td>指定文件某一行</td></tr>
<tr><td><code>/pattern/</code></td><td>被模式匹配到的每一行</td></tr>
<tr><td>范围区间</td><td>10,20(10到20行),  10,+5(第10行向下5行),  /pattern1/, /pattern2/</td></tr>
<tr><td>步长</td><td>1~2, 表示1,3,5,7,9行, 2~2两个步长, 表示2,4,6,8,10 偶数行</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="linux信号"><a class="header" href="#linux信号">linux信号</a></h1>
<div class="table-wrapper"><table><thead><tr><th>信号</th><th>值</th><th>动作</th><th>说明</th></tr></thead><tbody>
<tr><td><code>SIGHUP</code></td><td>1</td><td>Term</td><td>终端控制进程结束(终端连接断开)</td></tr>
<tr><td><code>SIGINT</code></td><td>2</td><td>Term</td><td>用户发送INTR字符(Ctrl+C)触发</td></tr>
<tr><td><code>SIGQUIT</code></td><td>3</td><td>Core</td><td>用户发送QUIT字符(Ctrl+/)触发</td></tr>
<tr><td>SIGILL</td><td>4</td><td>Core</td><td>非法指令(程序错误、试图执行数据段、栈溢出等)</td></tr>
<tr><td>SIGABRT</td><td>6</td><td>Core</td><td>调用abort函数触发</td></tr>
<tr><td>SIGFPE</td><td>8</td><td>Core</td><td>算术运行错误(浮点运算错误、除数为零等)</td></tr>
<tr><td><code>SIGKILL</code></td><td>9</td><td>Term</td><td>无条件结束程序(不能被捕获、阻塞或忽略)</td></tr>
<tr><td>SIGSEGV</td><td>11</td><td>Core</td><td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td></tr>
<tr><td>SIGPIPE</td><td>13</td><td>Term</td><td>消息管道损坏(FIFO/Socket通信时, 管道未打开而进行写操作)</td></tr>
<tr><td>SIGALRM</td><td>14</td><td>Term</td><td>时钟定时信号</td></tr>
<tr><td><code>SIGTERM</code></td><td>15</td><td>Term</td><td>结束程序(可以被捕获、阻塞或忽略)</td></tr>
<tr><td><code>SIGUSR1</code></td><td>30,10,16</td><td>Term</td><td>用户保留</td></tr>
<tr><td><code>SIGUSR2</code></td><td>31,12,17</td><td>Term</td><td>用户保留</td></tr>
<tr><td>SIGCHLD</td><td>20,17,18</td><td>Ign</td><td>子进程结束(由父进程接收)</td></tr>
<tr><td>SIGCONT</td><td>19,18,25</td><td>Cont</td><td>继续执行已经停止的进程(不能被阻塞)</td></tr>
<tr><td>SIGSTOP</td><td>17,19,23</td><td>Stop</td><td>停止进程(不能被捕获、阻塞或忽略)</td></tr>
<tr><td>SIGTSTP</td><td>18,20,24</td><td>Stop</td><td>停止进程(可以被捕获、阻塞或忽略)</td></tr>
<tr><td>SIGTTIN</td><td>21,21,26</td><td>Stop</td><td>后台程序从终端中读取数据时触发</td></tr>
<tr><td>SIGTTOU</td><td>22,22,27</td><td>Stop</td><td>后台程序向终端中写数据时触发</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="linux虚拟网络技术"><a class="header" href="#linux虚拟网络技术">linux虚拟网络技术</a></h1>
<p>在Linux虚拟化技术中, 网络层面, 通常重要的三个技术分别是<code>Network Namespace</code>、<code>veth pair</code>、以及<code>网桥</code>或<code>虚拟交换机</code>技术.</p>
<blockquote>
<p>参考资料:</p>
<ul>
<li>
<p><a href="https://www.cnblogs.com/bakari/p/10450711.html">虚拟网络设备 tap/tun 原理解析</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/bakari/p/10613710.html">Linux 虚拟网络设备 veth-pair 详解</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/bakari/p/10529575.html">Linux 虚拟网络设备详解之 Bridge 网桥</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/bakari/p/10641915.html">网卡也能虚拟化？网卡虚拟化技术 macvlan 详解</a></p>
</li>
</ul>
</blockquote>
<h2 id="一-network-namespace"><a class="header" href="#一-network-namespace">一. Network Namespace</a></h2>
<p><code>Network Namespace</code>, 它是由Linux内核提供, 是实现网络虚拟化的重要功能。</p>
<p>通过创建多个隔离的网络空间, 实现网络资源的隔离。</p>
<p>不同的<code>Network Namespace</code>的资源互相不可见, 彼此之间无法通信。</p>
<p><img src="pickup/../assets/202205071132290.jpeg" alt="network_namespace" /></p>
<p><strong>ip netns命令</strong></p>
<p><code>ip命令</code>管理的功能很多, 和<code>Network Namespace</code>有关的操作都在其子命令<code>ip netns</code>下进行的, 可以通过<code>ip netns help</code>查询命令帮助信息.</p>
<pre><code class="language-shell">$ ip netns help
Usage: ip netns list
       ip netns add NAME
       ip netns set NAME NETNSID
       ip [-all] netns delete [NAME]
       ip netns identify [PID]
       ip netns pids NAME
       ip [-all] netns exec [NAME] cmd ...
       ip netns monitor
       ip netns list-id
       
# ip netns add命令创建一个ns0的网络命名空间
$ ip netns add ns0
# 查看命名空间
$ ip netns list
# 命名空间所在的目录
# 新创建的 Network Namespace 会出现在/var/run/netns/目录下。如果需要管理其他不是 ip netns 创建的 network namespace, 只要在这个目录下创建一个指向对应 network namespace 文件的链接即可。
$ ls /var/run/netns/
</code></pre>
<p>对于每个 <code>Network Namespace</code> 来说, 它会有自己独立的网卡、路由表、ARP 表、iptables 等和网络相关的资源。</p>
<p>ip命令提供了<code>ip netns exec</code>子命令可以在对应的 <code>Network Namespace</code> 中执行命令。</p>
<pre><code class="language-shell"># 查看网络命名空间ns0的网卡信息
$ ip netns exec ns0 ip addr
# 默认loopback网卡是不启用的,下面是启用
$ ip netns exec ns0 ip link set lo up
# 在网络命名空间ns0打开shell
$ ip netns exec ns0 /bin/bash
</code></pre>
<h2 id="二-veth-pair"><a class="header" href="#二-veth-pair">二. veth pair</a></h2>
<p>默认情况下, <code>network namespace</code> 是不能和主机网络或者其他 network namespace 通信的</p>
<p>可以使用 Linux 提供的<code>veth pair</code>来完成通信, veth pair你可以理解为使用网线连接好的两个接口, 把两个端口放到两个namespace中, 那么这两个namespace就能打通。</p>
<p><img src="pickup/../assets/202205071132203.jpeg" alt="ns_com" /></p>
<pre><code class="language-shell"># 创建veth pair
$ ip link add type veth
# 查看veth pair
$ ip link
# 可以创建时指定两个端点的名称
$ ip link add veth001 type veth peer name veth002

# 再创建一个网络命名空间ns1
$ ip netns add ns1

# 将veth pair 分别加入ns0 ns1
$ ip link set veth0 netns ns0
$ ip link set veth1 netns ns01

# 分别为这对veth pair 配置ip地址并启用
$ ip netns exec ns0 ip addr add 192.168.1.98/24 dev veth0
$ ip netns exec ns0 ip link set veth0 up
$ ip netns exec ns1 ip addr add 192.168.1.99/24 dev veth1
$ ip netns exec ns1 ip link set veth1 up
# 查看这对veth pair的状态
$ sudo ip netns exec ns0 ip addr
$ sudo ip netns exec ns1 ip addr
# 验证互通
$ ip netns exec ns0 ping -c 10 192.168.1.99
$ ip netns exec ns1 ping -c 10 192.168.1.98
</code></pre>
<p><strong>删除 Network Namespace</strong></p>
<pre><code class="language-shell">$ ip netns delete ns0
$ ip netns delete ns1
</code></pre>
<h2 id="三-bridge"><a class="header" href="#三-bridge">三. bridge</a></h2>
<p>虽然veth pair可以实现两个 Network Namespace 之间的通信, 但 veth pair 有一个明显的缺陷, 就是只能实现两个网络接口之间的通信。</p>
<p>如果多个network namespace需要进行通信, 则需要借助<code>bridge</code>。</p>
<p><img src="pickup/../assets/202205071134226.jpeg" alt="ns_bridge" /></p>
<pre><code class="language-shell"># 创建网桥
$ ip link add docker0 type bridge
# 配置网桥ip 
$ ip addr add 172.17.0.1/16 dev  docker0 
# 启动网桥
$ ip link set dev docker0 up
# 查看网桥状态
$ ip addr docker0
# or
$ ip link show docker0
# or 
$ ifconfig docker0

# 删除网桥 
$ ip link delete docker0
</code></pre>
<blockquote>
<p>其它操作同上,可以将所有veth pair加入网桥,形成多个Network Namespace互通</p>
</blockquote>
<h2 id="四-taptun"><a class="header" href="#四-taptun">四. tap/tun</a></h2>
<p><code>tap/tun</code>设备文件就像一个管道, 一端连接着用户空间, 一端连接着内核空间。当用户程序向文件 <code>/dev/net/tun</code> 或 <code>/dev/tap0</code> 写数据时, 内核就可以从对应的 <code>tunX</code> 或 <code>tapX</code> 接口读到数据, 反之, 内核可以通过相反的方式向用户程序发送数据。</p>
<ul>
<li>TUN 是一个虚拟网络设备, 它模拟的是一个三层设备, 通过它可以处理来自网络层的数据包, 也就是 IP 数据包。由于它只模拟到了 IP 层, 所以它无法与物理网卡做 bridge, 也没有 MAC 地址, 但是可以通过三层交换的方式来与物理网卡相互通信。</li>
<li>TAP 模拟的是一个二层设备, 它比 TUN 更加深入, 它可以处理数据链路层的数据包, 拥有 MAC 地址, 可以与物理网卡做 bridge, 支持 MAC 层广播, 也可以给它设置 IP 地址。</li>
</ul>
<p><img src="pickup/../assets/202205071134636.jpg" alt="tap-tun" /></p>
<p><img src="pickup/../assets/202205071136355.jpeg" alt="vepa" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iptables"><a class="header" href="#iptables">iptables</a></h1>
<ul>
<li><a href="pickup/22-iptables.html#iptables">iptables</a>
<ul>
<li><a href="pickup/22-iptables.html#1-iptables">1. iptables</a>
<ul>
<li><a href="pickup/22-iptables.html#11-iptables%E5%9F%BA%E7%A1%80">1.1 iptables基础</a></li>
<li><a href="pickup/22-iptables.html#12-%E8%A7%84%E5%88%99%E6%A6%82%E5%BF%B5">1.2 规则概念</a>
<ul>
<li><a href="pickup/22-iptables.html#121-%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6">1.2.1 匹配条件</a></li>
<li><a href="pickup/22-iptables.html#122-%E5%A4%84%E7%90%86%E5%8A%A8%E4%BD%9C">1.2.2 处理动作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="pickup/22-iptables.html#2-iptables%E8%A7%84%E5%88%99">2. iptables规则</a>
<ul>
<li><a href="pickup/22-iptables.html#21-%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86">2.1 规则管理</a>
<ul>
<li><a href="pickup/22-iptables.html#211-%E8%A7%84%E5%88%99%E6%9F%A5%E8%AF%A2">2.1.1 规则查询</a></li>
<li><a href="pickup/22-iptables.html#212-%E8%A7%84%E5%88%99%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9">2.1.2 规则的增删改</a></li>
<li><a href="pickup/22-iptables.html#213-%E4%BF%9D%E5%AD%98%E8%A7%84%E5%88%99">2.1.3 保存规则</a></li>
</ul>
</li>
<li><a href="pickup/22-iptables.html#22-%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6">2.2 规则匹配条件</a>
<ul>
<li><a href="pickup/22-iptables.html#221-%E6%BA%90%E5%9C%B0%E5%9D%80">2.2.1 源地址</a></li>
<li><a href="pickup/22-iptables.html#222-%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80">2.2.2 目标地址</a></li>
<li><a href="pickup/22-iptables.html#223-%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B">2.2.3 协议类型</a></li>
<li><a href="pickup/22-iptables.html#224-%E7%BD%91%E5%8D%A1%E6%8E%A5%E5%8F%A3">2.2.4 网卡接口</a></li>
<li><a href="pickup/22-iptables.html#225-%E6%89%A9%E5%B1%95%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6">2.2.5 扩展匹配条件</a>
<ul>
<li><a href="pickup/22-iptables.html#2251-%E5%8C%B9%E9%85%8D%E7%AB%AF%E5%8F%A3">2.2.5.1 匹配端口</a></li>
<li><a href="pickup/22-iptables.html#2252-%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E7%A6%BB%E6%95%A3%E7%9A%84%E7%AB%AF%E5%8F%A3">2.2.5.2 匹配多个离散的端口</a></li>
<li><a href="pickup/22-iptables.html#2253-iprange%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97">2.2.5.3 <code>iprange</code>扩展模块</a></li>
<li><a href="pickup/22-iptables.html#2254-string%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97">2.2.5.4 string扩展模块</a></li>
<li><a href="pickup/22-iptables.html#2255-time%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97">2.2.5.5 time扩展模块</a></li>
<li><a href="pickup/22-iptables.html#2256-connlimit%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97">2.2.5.6 connlimit扩展模块</a></li>
<li><a href="pickup/22-iptables.html#2257-limit%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97">2.2.5.7 limit扩展模块</a></li>
<li><a href="pickup/22-iptables.html#2258-%E6%89%A9%E5%B1%95%E6%9D%A1%E4%BB%B6%E4%B9%8B-tcp-flags">2.2.5.8 扩展条件之<code>-tcp-flags</code></a></li>
<li><a href="pickup/22-iptables.html#2259-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%E4%B9%8Budp%E6%89%A9%E5%B1%95%E4%B8%8Eicmp%E6%89%A9%E5%B1%95">2.2.5.9 扩展模块之UDP扩展与ICMP扩展</a></li>
<li><a href="pickup/22-iptables.html#22510-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%E4%B9%8Bstate%E6%89%A9%E5%B1%95">2.2.5.10 扩展模块之state扩展</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="pickup/22-iptables.html#23-%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6">2.3 黑白名单机制</a></li>
<li><a href="pickup/22-iptables.html#24-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE">2.4 自定义链</a></li>
<li><a href="pickup/22-iptables.html#25-%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99">2.5 网络防火墙</a></li>
<li><a href="pickup/22-iptables.html#26-%E5%8A%A8%E4%BD%9C">2.6 动作</a>
<ul>
<li><a href="pickup/22-iptables.html#261-%E5%8A%A8%E4%BD%9Creject">2.6.1 动作REJECT</a></li>
<li><a href="pickup/22-iptables.html#262-%E5%8A%A8%E4%BD%9Clog">2.6.2 动作LOG</a></li>
<li><a href="pickup/22-iptables.html#263-%E5%8A%A8%E4%BD%9Csnat">2.6.3 动作SNAT</a></li>
<li><a href="pickup/22-iptables.html#264-%E5%8A%A8%E4%BD%9Cdnat">2.6.4 动作DNAT</a></li>
<li><a href="pickup/22-iptables.html#265-%E5%8A%A8%E4%BD%9Cmasquerade">2.6.5 动作MASQUERADE</a></li>
<li><a href="pickup/22-iptables.html#266-%E5%8A%A8%E4%BD%9Credirect">2.6.6 动作REDIRECT</a></li>
</ul>
</li>
<li><a href="pickup/22-iptables.html#27-%E6%80%BB%E7%BB%93">2.7 总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-iptables"><a class="header" href="#1-iptables">1. iptables</a></h2>
<blockquote>
<p>参考文章 <a href="http://www.zsythink.net/archives/tag/iptables/page/2/">iptables详解</a> <a href="https://blog.csdn.net/weixin_33749242/article/details/91718539">备链</a></p>
</blockquote>
<p><code>iptables</code>其实不是真正的防火墙,我们可以把它理解成一个客户端代理,用户通过<code>iptables</code>这个代理,将用户的安全设定执行到对应的"安全框架"中,这个"安全框架"才是真正的防火墙,这个框架的名字叫<code>netfilter</code>.</p>
<p><code>netfilter</code>才是防火墙真正的安全框架,<code>netfilter</code>位于<strong>内核空间</strong>.</p>
<p><code>iptables</code>其实是一个命令行工具,位于<strong>用户空间</strong>,我们用这个工具操作真正的框架.</p>
<p><code>netfilter</code>是Linux操作系统核心层内部的一个数据包处理模块,它具有如下功能：</p>
<ul>
<li>
<p>网络地址转换(Network Address Translate)</p>
</li>
<li>
<p>数据包内容修改</p>
</li>
<li>
<p>以及数据包过滤的防火墙功能</p>
</li>
</ul>
<h3 id="11-iptables基础"><a class="header" href="#11-iptables基础">1.1 iptables基础</a></h3>
<p><code>iptables</code>是按照规则来办事的,所谓规则一般的定义为:</p>
<blockquote>
<p>"如果数据包头符合这样的条件,就这样处理这个数据包".规则存储在内核空间的信息包过滤表中,这些规则分别指定了 <em><strong>源地址</strong></em> 、<em><strong>目的地址</strong></em> 、<em><strong>传输协议(如TCP、UDP、ICMP)</strong></em> 和 <em><strong>服务类型(如HTTP、FTP和SMTP)</strong></em> 等.</p>
<p>当数据包与规则匹配时,<code>iptables</code>就根据规则所定义的方法来处理这些数据包,如 <strong>放行(accept)</strong> 、<strong>拒绝(reject)</strong> 和 <strong>丢弃(drop)</strong> 等.</p>
<p>配置防火墙的主要工作就是添加、修改和删除这些规则.</p>
</blockquote>
<p><code>iptables</code>配置的通常就是所说的 <strong>四表五链</strong> .</p>
<p>四表: (另外<code>security</code>表不常用,主要用于数据包上应用 <strong>SELinux</strong> )</p>
<ul>
<li><code>raw</code>: 关闭nat表上启用的连接追踪机制; iptable_raw</li>
<li><code>mangle</code>: 拆解报文, 做出修改, 并重新封装 的功能；iptable_mangle</li>
<li><code>nat</code>:  network address translation,网络地址转换功能；；iptable_nat</li>
<li><code>filter</code>:  负责过滤功能,防火墙；内核模块：iptables_filter</li>
</ul>
<blockquote>
<p>这5张表的优先级从高到低是：<code>raw</code> -&gt; <code>mangle</code>  -&gt;  <code>nat</code> -&gt; <code>filter</code>  [-&gt; <code>security</code>]</p>
<blockquote>
<p>需要注意的是, <code>iptables</code><strong>不支持用户自定义表</strong>,但<strong>支持自定义链</strong>.</p>
</blockquote>
</blockquote>
<p><strong>五链</strong> (标记表的执行优先级次序):</p>
<ul>
<li><code>PREROUTING</code>: <code>raw</code> --&gt;<code>mangle</code>--&gt; <code>nat</code></li>
<li><code>INPUT</code>:  <code>mangle</code> --&gt; <code>filter</code>(centos7中还有<code>nat</code>表,centos6中没有).</li>
<li><code>FORWARD</code>: <code>mangle</code>- -&gt; <code>filter</code></li>
<li><code>OUPUT</code>: <code>raw</code>--&gt; <code>mangle</code> --&gt; <code>nat</code> --&gt; <code>filter</code></li>
<li><code>POSTROUTING</code>: <code>mangle</code> --&gt; <code>nat</code></li>
</ul>
<p>以上看出各个链有对应的表,而且表和表上的规则是有优先级的, <strong>在实际操作使用时,往往是通过操作<code>iptables</code>这些表,对规则进行定义的.</strong></p>
<p><img src="pickup/../assets/iptables-chain.png" alt="iptable-1" /></p>
<h3 id="12-规则概念"><a class="header" href="#12-规则概念">1.2 规则概念</a></h3>
<p>根据指定的匹配条件来尝试匹配每个流经此处的报文,一旦匹配成功,则由规则后面指定的处理动作(target)进行处理.如果不匹配将顺延匹配下一条.</p>
<h4 id="121-匹配条件"><a class="header" href="#121-匹配条件">1.2.1 匹配条件</a></h4>
<p>匹配条件分为 <em><strong>基本匹配条件</strong></em> 与 <em><strong>扩展匹配条件</strong></em></p>
<p><strong>基本匹配条件</strong>:</p>
<ul>
<li>源地址: Source IP</li>
<li>目标地址: Destination IP</li>
</ul>
<p><strong>扩展匹配条件：</strong></p>
<p>除了上述的条件可以用于匹配,还有很多其他的条件可以用于匹配,这些条件泛称为 <em><strong>扩展条件</strong></em> ,这些扩展条件其实也是<code>netfilter</code>中的一部分,只是以模块的形式存在,如果想要使用这些条件,则需要依赖对应的扩展模块.</p>
<ul>
<li>
<p>源端口:Source Port</p>
</li>
<li>
<p>目标端口:Destination Port</p>
</li>
</ul>
<h4 id="122-处理动作"><a class="header" href="#122-处理动作">1.2.2 处理动作</a></h4>
<p>处理动作在<code>iptables</code>中被称为target(这样说并不准确,我们暂且这样称呼),</p>
<p>动作也可以分为 <em><strong>基本动作</strong></em> 和 <em><strong>扩展动作</strong></em>.</p>
<p>此处列出一些常用的动作：</p>
<ul>
<li>
<p><strong>ACCEPT</strong>：允许数据包通过.</p>
</li>
<li>
<p><strong>DROP</strong>：直接丢弃数据包,不给任何回应信息,这时候客户端会感觉自己的请求泥牛入海了,过了超时时间才会有反应.</p>
</li>
<li>
<p><strong>REJECT</strong>：拒绝数据包通过,必要时会给数据发送端一个响应的信息,客户端刚请求就会收到拒绝的信息.</p>
</li>
<li>
<p><strong>SNAT</strong>：源地址转换,解决内网用户用同一个公网地址上网的问题.</p>
</li>
<li>
<p><strong>MASQUERADE</strong>：是SNAT的一种特殊形式,适用于动态的、临时会变的ip上.</p>
</li>
<li>
<p><strong>DNAT</strong>：目标地址转换.</p>
</li>
<li>
<p><strong>REDIRECT</strong>：在本机做端口映射.</p>
</li>
<li>
<p><strong>LOG</strong>：在<code>/var/log/messages</code>文件中记录日志信息,然后将数据包传递给下一条规则,也就是说除了记录以外不对数据包做任何其他操作,仍然让下一条规则去匹配.</p>
</li>
</ul>
<h2 id="2-iptables规则"><a class="header" href="#2-iptables规则">2. iptables规则</a></h2>
<h3 id="21-规则管理"><a class="header" href="#21-规则管理">2.1 规则管理</a></h3>
<h4 id="211-规则查询"><a class="header" href="#211-规则查询">2.1.1 规则查询</a></h4>
<pre><code class="language-shell"># 查看filter表的所有规则
# -t 指定表
# -L 列出链的规则,如果不指定链,则显示所有
$ iptables -t filter -L
# 查看filter表中INPUT链的规则
$ iptables -t filter -L INPUT
# -v选项,查看更多的,更详细的信息,
# -x选项表示显示计数器的精确值.
$ iptables -t filter -vxL
# 默认是对IP地址进行名称解析
# -n直接显示IP地址,不进行名称解析
$ iptables -t filter -nvL
# --line-numbers 显示行号,可用--line
$ iptables -t filter -nvL --line-numbers

Chain FORWARD (policy DROP 0 packets, 0 bytes)
num   pkts bytes target                    prot opt in     out      source               destination         
1        4   296 DOCKER-USER               all  --  *      *        0.0.0.0/0            0.0.0.0/0           
2        4   296 DOCKER-ISOLATION-STAGE-1  all  --  *      *        0.0.0.0/0            0.0.0.0/0           
3        0     0 ACCEPT                    all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
</code></pre>
<p>链后面括号中的含义:</p>
<ul>
<li><strong>policy</strong>表示当前链的默认策略,<code>policy ACCEPT</code>表示上图中<code>INPUT</code>的链的默认动作为<code>ACCEPT</code></li>
<li><strong>packets</strong>表示当前链默认策略匹配到的包的数量,<code>0 packets</code>表示默认策略匹配到<code>0</code>个包</li>
<li><strong>bytes</strong>表示当前链默认策略匹配到的所有包的大小总和.</li>
</ul>
<p>规则条目参数:</p>
<ul>
<li><strong>pkts</strong>:   对应规则匹配到的<strong>报文</strong>的个数.</li>
<li><strong>bytes</strong>:  对应匹配到的<strong>报文包的大小</strong>总和.</li>
<li><strong>target</strong>: 规则对应的<strong>target</strong>,往往表示规则对应的"动作",即规则匹配成功后需要采取的措施.</li>
<li><strong>prot</strong>:   规则对应的<strong>协议</strong>,是否只针对某些协议应用此规则.</li>
<li><strong>opt</strong>:    规则对应的<strong>选项</strong>.</li>
<li><strong>in</strong>:     数据包由哪个接口(网卡)流入,我们可以设置通过<strong>哪块网卡流入的报文</strong>需要匹配当前规则.</li>
<li><strong>out</strong>:    数据包由哪个接口(网卡)流出,我们可以设置通过<strong>哪块网卡流出的报文</strong>需要匹配当前规则.</li>
<li><strong>source</strong>:       规则对应的<strong>源头地址</strong>,可以是一个IP,也可以是一个网段.</li>
<li><strong>destination</strong>:  规则对应的<strong>目标地址</strong>.可以是一个IP,也可以是一个网段</li>
</ul>
<h4 id="212-规则的增删改"><a class="header" href="#212-规则的增删改">2.1.2 规则的增删改</a></h4>
<pre><code class="language-shell"># 添加一条规则,表示在filter表的INPUT链追加一条丢弃来自192.168.1.111的规则
#  -A: 追加
#  -I: 插入表头,可指定位置,在链名后面添加相应数字即可.
#  -s: 源地址
#  -j: 动作
$ iptables -t filter -A INPUT -s 192.168.1.111 -j DROP

# 根据规则的编号删除规则.
#  -D: 删除
$ iptables -t filter -D INPUT 2 
# 根据匹配条件去删除规则,NOTE: 有坑,建议选删除再增加.
$ iptables -t filter -D INPUT -s 192.168.1.111 -j DROP
# 清空filter 表的规则
# -F flush 冲刷清除之意.
$ iptables -t filter -F input

# 修改规则
# -R 修改指定条目序号的规则,注意: 必须指定匹配规则,虽然已指定的序号.
$ iptables -t filter -R INPUT 1 -s 192.168.1.111 -j REJECT 
</code></pre>
<h4 id="213-保存规则"><a class="header" href="#213-保存规则">2.1.3 保存规则</a></h4>
<p>在默认的情况下,我们对"防火墙"所做出的修改都是"临时的",换句话说就是,当重启<code>iptables</code>服务或者重启服务器以后,我们平常添加的规则或者对规则所做出的修改都将消失,为了防止这种情况的发生,我们需要将规则"保存"</p>
<pre><code class="language-shell"># 规则默认保存在 /etc/sysconfig/iptables
$ service iptalbes save

# 使用iptables-save并不能保存当前的iptables规则,但是可以将当前的iptables规则以"保存后的格式"输出到屏幕上
# 配合重定向可以自己保存.
$ iptables-save
# 重新载入为当前iptables规则
$ iptables-restore
# 或
$ iptables-restore &lt; /etc/sysconfig/iptables
</code></pre>
<h3 id="22-规则匹配条件"><a class="header" href="#22-规则匹配条件">2.2 规则匹配条件</a></h3>
<blockquote>
<p>注意: 不指定源或目标地址,均默认为<code>0.0.0.0/0</code>
多个匹配条件,为"与"关系</p>
</blockquote>
<h4 id="221-源地址"><a class="header" href="#221-源地址">2.2.1 源地址</a></h4>
<pre><code class="language-shell"># 单个源地址
$ iptables -t filter -I INPUT -s 192.168.1.111 -j DROP
# 多个源地址,采用','分开,且不能包含空格
$ iptables -t filter -I INPUT -s 192.168.1.111,192.168.1.112 -j DROP
# 指定具体IP地址,还能指定网段
$ iptables -t filter -I INPUT -s 192.168.0.0/16 -j DROP
# 还可以对匹配条件取反,加'!'号
$ iptables -t filter -I INPUT ! -s 192.168.1.111 -j DROP
</code></pre>
<h4 id="222-目标地址"><a class="header" href="#222-目标地址">2.2.2 目标地址</a></h4>
<pre><code class="language-shell"># -d 指定目标地址匹配条件
# 丢弃192.168.1.111发往 192.168.1.120的报文
# 同源地址,目标地址操作,也可以指定多个IP地址(用','分隔),也可以取反,也可以指定网段.
$ iptables -t filter -I INPUT -s 192.168.1.111 -d 192.168.1.120 -j DROP
</code></pre>
<h4 id="223-协议类型"><a class="header" href="#223-协议类型">2.2.3 协议类型</a></h4>
<p><code>-p</code>指定协议
默认是所有协议<code>-p all</code>)
支持的协议有: <code>tcp</code>, <code>udp</code>, <code>udplite</code>, <code>icmp</code>, <code>icmpv6</code>, <code>esp</code>, <code>ah</code>, <code>sctp</code>, <code>mh</code>等.</p>
<h4 id="224-网卡接口"><a class="header" href="#224-网卡接口">2.2.4 网卡接口</a></h4>
<p><code>-i</code> 指定匹配报文网卡流入,匹配报文是通过哪块网卡流入本机的,只能作用于<code>PREROUTING</code>、<code>INPUT</code>、<code>FORWARD</code>
<code>-o</code>指定匹配报文网卡流出,匹配报文将从哪个网卡流出,只能用于<code>FORWARD</code>、<code>OUTPUT</code>、<code>POSTROUTING</code>.
默认是所有网卡</p>
<h4 id="225-扩展匹配条件"><a class="header" href="#225-扩展匹配条件">2.2.5 扩展匹配条件</a></h4>
<p>源端口和目标端口属于扩展匹配条件,如果想要使用扩展匹配条件,则需要依赖一些扩展模块.</p>
<h5 id="2251-匹配端口"><a class="header" href="#2251-匹配端口">2.2.5.1 匹配端口</a></h5>
<p>在使用<code>--dport</code>,<code>--sport</code>之前,我们使用<code>-m</code>选项,指定了对应的扩展模块为<code>tcp</code>,也就是说,如果想要使用<code>--dport</code>,<code>--sport</code>这个扩展匹配条件,则必须依靠某个扩展模块完成.
当使用<code>-p</code>选项指定了报文的协议时,如果在没有使用<code>-m</code>指定对应的扩展模块名称的情况下,使用了扩展匹配条件,  <code>iptables</code>默认会调用与<code>-p</code>选项对应的协议名称相同的模块</p>
<ul>
<li>目标端口: 使用选项<code>--dport</code>可以匹配报文的目标端口,<code>--dport</code>意为destination-port,即表示目标端口.</li>
<li>源端口: 使用选项<code>--sport</code>可以匹配报文的源端口,<code>--sport</code>表示source-port,即表示源端口.</li>
</ul>
<p>扩展匹配条件是可以取反的,同样是使用"!"进行取反,比如 <code>! --dport 22</code>,表示目标端口不是22的报文将会被匹配到.
<code>--sport</code>,<code>--dsport</code>,都能够指定一个端口范围,比如,<code>--dport 22:25</code>表示目标端口为22到25之间的所有端口.</p>
<p>同时指定多个离散的端口,需要借助另一个扩展模块,<code>multiport</code>模块</p>
<h5 id="2252-匹配多个离散的端口"><a class="header" href="#2252-匹配多个离散的端口">2.2.5.2 匹配多个离散的端口</a></h5>
<ul>
<li>使用<code>multiport</code>模块的<code>--sports</code>扩展条件同时指定多个离散的源端口.
<code>iptables -t filter -I INPUT -s 192.168.1.111 -p tcp -m multiport --dports 22,36,80 -j DROP</code></li>
<li>使用<code>multiport</code>模块的<code>--dports</code>扩展条件同时指定多个离散的目标端口
<code>iptables -t filter -I INPUT -s 192.168.1.111 -p tcp -m multiport --sports 22,36,80 -j DROP</code></li>
</ul>
<h5 id="2253-iprange扩展模块"><a class="header" href="#2253-iprange扩展模块">2.2.5.3 <code>iprange</code>扩展模块</a></h5>
<p>使用<code>-s</code>选项或者<code>-d</code>选项即可匹配报文的源地址与目标地址,而且在指定IP地址时,可以同时指定多个IP地址,每个IP用"逗号"隔开,但是,<code>-s</code>选项与<code>-d</code>选项并不能一次性的指定一段连续的IP地址范围,
如果我们需要指定一段连续的IP地址范围,可以使用<code>iprange</code>扩展模块,扩展匹配条件可以使用<code>--src-range</code>,<code>--dst-range</code></p>
<pre><code class="language-shell">iptables -t filter -I INPUT -m iprange --src-range 192.168.1.111-192.168.1.120 -j DROP
iptables -t filter -I INPUT -m iprange --dst-range 192.168.1.111-192.168.1.120 -j DROP
</code></pre>
<h5 id="2254-string扩展模块"><a class="header" href="#2254-string扩展模块">2.2.5.4 string扩展模块</a></h5>
<p>使用<code>string</code>扩展模块,可以指定要匹配的字符串,如果报文中包含对应的字符串,则符合匹配条件
<code>--algo</code>：用于指定匹配算法,可选的算法有<code>bm</code>与<code>kmp</code>,此选项为必须选项,我们不用纠结于选择哪个算法,但是我们必须指定一个.
<code>--string</code>：用于指定需要匹配的字符串.</p>
<h5 id="2255-time扩展模块"><a class="header" href="#2255-time扩展模块">2.2.5.5 time扩展模块</a></h5>
<p>我们可以通过time扩展模块,根据时间段区匹配报文,如果报文到达的时间在指定的时间范围以内,则符合匹配条件.
<code>--timestart</code>指定起始时间. 格式 xx.xx.xx
<code>--timestop</code>指定结束时间.
<code>--monthdays</code> 指定月份的哪一号,多个用<code>,</code>隔开
<code>--weekdays</code> 指定星期几,多个用<code>,</code>隔开 Mon, Tue, Wed, Thu, Fri, Sat, Sun
<code>--datestart</code> 指定日期开始时间
<code>--datestop</code>指定日期结束时间
NOTE: <code>--monthdays</code>与<code>--weekdays</code>可以使用<code>"!"</code>取反,其他选项不能取反</p>
<h5 id="2256-connlimit扩展模块"><a class="header" href="#2256-connlimit扩展模块">2.2.5.6 connlimit扩展模块</a></h5>
<p>使用<code>connlimit</code>扩展模块,可以限制每个IP地址同时链接到server端的链接数量
注意：我们不用指定IP,其默认就是针对"每个客户端IP",即对单IP的并发连接数限制.
<code>--connlimit-above 2</code>表示限制每个IP的链接数量上限为2
<code>--connlimit-upto</code>含义与<code>! --commlimit-above</code>的含义相同,即链接数量未达到指定的连接数量之意"--
<code>--connlimit-mask</code>限制"某类网段"的链接数量.<code>connlimit-mask 24</code>表示某个C类网段,没错,mask为掩码之意,所以将24转换成点分十进制就表示255.255.255.0</p>
<h5 id="2257-limit扩展模块"><a class="header" href="#2257-limit扩展模块">2.2.5.7 limit扩展模块</a></h5>
<p><code>limit</code>模块是对"报文到达速率"进行限制的. 限制单位时间内流入的包的数量.
<code>--limit</code>可以以秒为单位进行限制,也可以以分钟、小时、天作为单位进行限制.
可以选择的时间单位<code>/second</code>,<code>/minute</code>,<code>/hour</code>,<code>/day</code>
<code>--limit-burst</code>可以指定"空闲时可放行的包的数量"</p>
<h5 id="2258-扩展条件之-tcp-flags"><a class="header" href="#2258-扩展条件之-tcp-flags">2.2.5.8 扩展条件之<code>-tcp-flags</code></a></h5>
<p>注：需要对tcp协议的基础知识有一定的了解,比如：tcp头的结构、tcp三次握手的过程.
见名知义,"--tcp-flags"指的就是tcp头中的标志位,看来,在使用iptables时,我们可以通过此扩展匹配条件,去匹配tcp报文的头部的标识位,然后根据标识位的实际情况实现访问控制的功能.
如下图,在使用iptables时,使用tcp扩展模块的"--tcp-flags"选项,即可对上图中的标志位进行匹配,判断指定的标志位的值是否为"1".
<code>--tcp-flags</code> tcp头的标志有<code>SYN</code>,<code>ACK</code>,<code>FIN</code>,<code>RST</code>,<code>URG</code>,<code>PSH</code>,默认<code>ALL</code>表示全部.
<code>iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags ALL SYNC -j REJECT</code></p>
<p><img src="pickup/../assets/iptables-tcp-flag.png" alt="tcp-flags" /></p>
<h5 id="2259-扩展模块之udp扩展与icmp扩展"><a class="header" href="#2259-扩展模块之udp扩展与icmp扩展">2.2.5.9 扩展模块之UDP扩展与ICMP扩展</a></h5>
<ul>
<li>
<p>UDP扩展</p>
<blockquote>
<p><code>--sport</code>与<code>--dport</code>,即匹配报文的源端口与目标端口.
<code>iptables -t filter -I INPUT -p udp -m udp --dport 136 0j ACCEPT</code></p>
</blockquote>
</li>
<li>
<p>ICMP扩展</p>
<blockquote>
<p><code>--icmp-type</code>选项表示根据具体的type与code去匹配对应的icmp报文.
<code>--icmp-type 8/0</code>表示icmp报文的type为8,code为0才会被匹配到,也就是只有ping请求类型的报文才能被匹配到.</p>
<pre><code class="language-shell">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT
iptables -t filter -I INPUT -p icmp --icmp-type 8 -j REJECT
iptables -t filter -I OUTPUT -p icmp -m icmp --icmp-type 0/0 -j REJECT
iptables -t filter -I OUTPUT -p icmp --icmp-type 0 -j REJECT
iptables -t filter -I INPUT -p icmp --icmp-type "echo-request" -j REJECT
</code></pre>
<p>see <a href="http://www.zsythink.net/archives/1588">icmp扩展</a></p>
</blockquote>
</li>
</ul>
<h5 id="22510-扩展模块之state扩展"><a class="header" href="#22510-扩展模块之state扩展">2.2.5.10 扩展模块之state扩展</a></h5>
<p><code>state</code>模块可以让<code>iptables</code>实现"连接追踪"机制.那么,既然是"连接追踪",则必然要有"连接".
<code>state</code>模块的连接而言,"连接"其中的报文可以分为5种状态:</p>
<ul>
<li><strong>NEW</strong>：连接中的第一个包,状态就是NEW,我们可以理解为新连接的第一个包的状态为NEW.</li>
<li><strong>ESTABLISHED</strong>：我们可以把NEW状态包后面的包的状态理解为ESTABLISHED,表示连接已建立.</li>
<li><strong>RELATED</strong>：从字面上理解<code>RELATED</code>译为关系,但是这样仍然不容易理解,我们举个例子.
比如FTP服务,FTP服务端会建立两个进程,一个命令进程,一个数据进程.
命令进程负责服务端与客户端之间的命令传输(我们可以把这个传输过程理解成state中所谓的一个"连接",暂称为"命令连接").
数据进程负责服务端与客户端之间的数据传输 ( 我们把这个过程暂称为"数据连接" ).
但是具体传输哪些数据,是由命令去控制的,所以,"数据连接"中的报文与"命令连接"是有"关系"的.
那么,"数据连接"中的报文可能就是RELATED状态,因为这些报文与"命令连接"中的报文有关系.
(注：如果想要对ftp进行连接追踪,需要单独加载对应的内核模块<code>nf_conntrack_ftp</code>,如果想要自动加载,可以配置<code>/etc/sysconfig/iptables-config</code>文件)</li>
<li><strong>INVALID</strong>：如果一个包没有办法被识别,或者这个包没有任何状态,那么这个包的状态就是INVALID,我们可以主动屏蔽状态为INVALID的报文.</li>
<li><strong>UNTRACKED</strong>：报文的状态为untracked时,表示报文未被追踪,当报文的状态为Untracked时通常表示无法找到相关的连接.</li>
</ul>
<p><code>iptables -t filter -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code></p>
<h3 id="23-黑白名单机制"><a class="header" href="#23-黑白名单机制">2.3 黑白名单机制</a></h3>
<p>白名单机制: 我们就要把所有人都当做坏人,只放行好人.
黑名单机制: 我们就要把所有人都当成好人,只拒绝坏人.</p>
<pre><code class="language-shell"># 更改链的默认规则
# -P 选项
$ iptables -t filter -P INPUT DROP
</code></pre>
<h3 id="24-自定义链"><a class="header" href="#24-自定义链">2.4 自定义链</a></h3>
<p>自定义链并不能直接使用,而是需要被默认链引用才能够使用</p>
<pre><code class="language-shell"># 创建自定义链,
# -N
# 表示在filter表中增加一个NEW_CHAIN的链
# NOTE: 但是自定义链并未被引用
$ iptables -t filter -N NEW_CHAIN

# 引用
# NEW_CHAIN被INPUT链引用.
# 表明所有目的端口为80的报文由NEW_CHAIN去匹配
$ iptables -I INPUT -p tcp --dport 80 -j NEW_CHAIN

# 重命名自定义链
# -E  可以修改自定义链名
iptables  -t filter -E NEW_CHAIN MY_CHAIN

# 删除自定义链
# -X 删除对应的自定义链
# 首先得删除引用,使自定义链引用为0,
# 其次清空自定义链规则
# 最后删除自定义链
$ iptables -t filter -D INPUT 1
$ iptables -t filter -F MY_CHAIN
$ iptables -t filter -X MY_CHAIN
</code></pre>
<h3 id="25-网络防火墙"><a class="header" href="#25-网络防火墙">2.5 网络防火墙</a></h3>
<p>防火墙从逻辑上讲, 可以分为<strong>主机防火墙</strong>与<strong>网络防火墙</strong>。</p>
<p>​主机防火墙：针对于单个主机进行防护。
​网络防火墙： 往往处于网络入口或边缘, 针对于网络入口进行防护, 服务于防火墙背后的本地局域网。</p>
<pre><code class="language-shell">#如果想要iptables作为网络防火墙,iptables所在主机开启核心转发功能,以便能够转发报文.
#使用如下命令查看当前主机是否已经开启了核心转发,0表示为开启,1表示已开启
cat /proc/sys/net/ipv4/ip_forward
#使用如下两种方法均可临时开启核心转发,立即生效,但是重启网络配置后会失效.
方法一：echo 1 &gt; /proc/sys/net/ipv4/ip_forward
方法二：sysctl -w net.ipv4.ip_forward=1
#使用如下方法开启核心转发功能,重启网络服务后永久生效.
配置/etc/sysctl.conf文件(centos7中配置/usr/lib/sysctl.d/00-system.conf文件),在配置文件中将 net.ipv4.ip_forward设置为1
 
#由于iptables此时的角色为"网络防火墙",所以需要在filter表中的FORWARD链中设置规则.
#可以使用"白名单机制",先添加一条默认拒绝的规则,然后再为需要放行的报文设置规则.
#配置规则时需要考虑"方向问题",针对请求报文与回应报文,考虑报文的源地址与目标地址,源端口与目标端口等.
#示例为允许网络内主机访问网络外主机的web服务与sshd服务.
iptables -A FORWARD -j REJECT
iptables -I FORWARD -s 10.1.0.0/16 -p tcp --dport 80 -j ACCEPT
iptables -I FORWARD -d 10.1.0.0/16 -p tcp --sport 80 -j ACCEPT
iptables -I FORWARD -s 10.1.0.0/16 -p tcp --dport 22 -j ACCEPT
iptables -I FORWARD -d 10.1.0.0/16 -p tcp --sport 22 -j ACCEPT
 
#可以使用state扩展模块,对上述规则进行优化,使用如下配置可以省略许多"回应报文放行规则".
iptables -A FORWARD -j REJECT
iptables -I FORWARD -s 10.1.0.0/16 -p tcp --dport 80 -j ACCEPT
iptables -I FORWARD -s 10.1.0.0/16 -p tcp --dport 22 -j ACCEPT
iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></pre>
<h3 id="26-动作"><a class="header" href="#26-动作">2.6 动作</a></h3>
<p>"动作"与"匹配条件"一样,也有"基础"与"扩展"之分,使用扩展动作也需要借助扩展模块,但是,扩展动作可以<strong>直接使用</strong>,不用像使用"扩展匹配条件"那样指定特定的模块.</p>
<p><code>ACCEPT</code>与<code>DROP</code>都属于基础动作,而<code>REJECT</code>则属于扩展动作.</p>
<h4 id="261-动作reject"><a class="header" href="#261-动作reject">2.6.1 动作REJECT</a></h4>
<p>动作也有自己的选项,以下以REJECT为例.</p>
<pre><code class="language-shell">iptables -I INPUT 2 -j REJECT --reject-with icmp-host-unreachable
</code></pre>
<p>REJECT动作的常用选项为<code>--reject-with</code>,设置提示信息</p>
<ul>
<li>icmp-port-unreachable(不设置任何值时,默认此值)</li>
<li>icmp-net-unreachable</li>
<li>icmp-host-unreachable</li>
<li>icmp-proto-unreachable</li>
<li>icmp-net-prohibited</li>
<li>icmp-host-pro-hibited</li>
<li>icmp-admin-prohibited</li>
</ul>
<h4 id="262-动作log"><a class="header" href="#262-动作log">2.6.2 动作LOG</a></h4>
<p>使用<code>LOG</code>动作,可以将符合条件的报文的相关信息记录到日志中,但当前报文具体是被"接受",还是被"拒绝",都由后面的规则控制,
换句话说,LOG动作只负责记录匹配到的报文的相关信息,不负责对报文的其他处理,如果想要对报文进行进一步的处理,可以在之后设置具体规则,进行进一步的处理</p>
<pre><code class="language-shell">iptables -I INPUT -p tcp --dport 22 -j LOG
</code></pre>
<p>可以查看<code>/var/log/messages</code>
也可以将相关信息记录在指定的文件中,以防止<code>iptables</code>的相关信息与其他日志信息相混淆,修改<code>/etc/rsyslog.conf</code>文件(或者<code>/etc/syslog.conf</code>),
在rsyslog配置文件中添加如下配置即可.</p>
<pre><code class="language-shell">#报文相关信息会记录在 /var/log/iptables.log文
$ vim /etc/rsyslog.conf
kern.warning /var/log/iptables.log
# 服务重启生效
$ service rsyslog restart
</code></pre>
<p><code>LOG</code>动作也有自己的选项,常用选项如下
<code>--log-level</code>选项可以指定记录日志的日志级别,可用级别有<strong>emerg,alert,crit,error,warning,notice,info,debug</strong>.
<code>--log-prefix</code>选项可以给记录到的相关信息添加"标签"之类的信息,以便区分各种记录到的报文信息,方便在分析时进行过滤.
注：<code>--log-prefix</code>对应的值不能超过29个字符.</p>
<h4 id="263-动作snat"><a class="header" href="#263-动作snat">2.6.3 动作SNAT</a></h4>
<p><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code>开始核心转发</p>
<p><code>iptables -t nat -A POSTROUTING -s 10.1.0.0/16 -j SNAT --to-source 192.168.1.146</code>
意思是将来自于<code>10.1.0.0/16</code>网段的报文的源地址改为公司的公网IP地址.</p>
<h4 id="264-动作dnat"><a class="header" href="#264-动作dnat">2.6.4 动作DNAT</a></h4>
<p><code>iptables -t -I PREROUTING -d 192.168.1.146 -p tcp --dport 3389 -j DNAT --to-destination10.1.0.6:3389</code>
意思是当外网主机访问公司公网IP的3389时,其报文的目标地址与端口将会被映射到10.1.0.6:3389上.</p>
<h4 id="265-动作masquerade"><a class="header" href="#265-动作masquerade">2.6.5 动作MASQUERADE</a></h4>
<p><code>MASQUERADE</code>会动态的将源地址转换为可用的IP地址,其实与SNAT实现的功能完全一致,都是修改源地址,只不过SNAT需要指明将报文的源地址改为哪个IP,而<em>MASQUERADE则不用指定明确的IP,会动态的将报文的源地址修改为指定网卡上可用的IP地址</em>.</p>
<p><code>iptables -t nat - POSTROUTING -s 10.1.0.0/16 -o eno50332184 -j MQSQUERADE</code>
表示通过外网网卡出去的报文在经过<code>POSTROUTING</code>链时,会自动将报文的源地址修改为外网网卡上可用的IP地址,这时,即使外网网卡中的公网IP地址发生了改变,也能够正常的、动态的将内部主机的报文的源IP映射为对应的公网IP.</p>
<h4 id="266-动作redirect"><a class="header" href="#266-动作redirect">2.6.6 动作REDIRECT</a></h4>
<p>使用REDIRECT动作可以在本机上进行端口映射
比如,将本机的80端口映射到本机的8080端口上</p>
<p><code>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</code></p>
<p>经过上述规则映射后,当别的机器访问本机的80端口时,报文会被重定向到本机的8080端口上.</p>
<p><strong>NOTE</strong>: <code>REDIRECT</code>规则只能定义在<code>PREROUTING</code>链或者<code>OUTPUT</code>链中.</p>
<h3 id="27-总结"><a class="header" href="#27-总结">2.7 总结</a></h3>
<p><strong>1</strong>. 规则的顺序非常重要.</p>
<blockquote>
<p>如果报文已经被前面的规则匹配到,IPTABLES则会对报文执行对应的动作,通常是ACCEPT或者REJECT,报文被放行或拒绝以后,即使后面的规则也能匹配到刚才放行或拒绝的报文,也没有机会再对报文执行相应的动作了(前面规则的动作为LOG时除外),所以,<strong>针对相同服务的规则,更严格的规则应该放在前面</strong>.</p>
</blockquote>
<p><strong>2</strong>. 当规则中有多个匹配条件时,条件之间默认存在"与"的关系.</p>
<blockquote>
<p>如果一条规则中包含了多个匹配条件,那么报文必须同时满足这个规则中的所有匹配条件,报文才能被这条规则匹配到.</p>
</blockquote>
<p><strong>3</strong>. 在不考虑1的情况下,应该将更容易且经常被匹配到的规则放置在前面.</p>
<blockquote>
<p>比如,你写了两条规则,一条针对sshd服务,一条针对web服务.
假设,一天之内,有20000个请求访问web服务,有200个请求访问sshd服务,
那么,应该将针对web服务的规则放在前面,针对sshd的规则放在后面,因为访问web服务的请求频率更高.
如果将sshd的规则放在前面,当报文是访问web服务时,sshd的规则也要白白的验证一遍,由于访问web服务的频率更高,白白耗费的资源就更多.
如果web服务的规则放在前面,由于访问web服务的频率更高,所以无用功会比较少.
换句话说就是,在没有顺序要求的情况下,不同类别的规则,被匹配次数多的、匹配频率高的规则应该放在前面.</p>
</blockquote>
<p><strong>4</strong>. 当<code>IPTABLES</code>所在主机作为网络防火 墙时,在配置规则时,应着重考虑方向性,双向都要考虑,从外到内,从内到外.</p>
<p><strong>5</strong>. 在配置<code>IPTABLES</code>白名单时,往往会将链的默认策略设置为ACCEPT,通过在链的最后设置<code>REJECT</code>规则实现白名单机制,而不是将链的默认策略设置为<code>DROP</code>,如果将链的默认策略设置为<code>DROP</code>,当链中的规则被清空时,管理员的请求也将会被<code>DROP</code>掉.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netcat"><a class="header" href="#netcat">netcat</a></h1>
<p><code>nc</code>全名叫 <code>netcat</code>, 它可以用来完成很多的网络功能, 譬如端口扫描、建立TCP/UDP连接, 数据传输、网络调试等等, 因此, 它也常被称为网络工具的 <strong>瑞士军刀</strong> .</p>
<h2 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h2>
<pre><code class="language-shell">$ nc -h
OpenBSD netcat (Debian patchlevel 1.187-1ubuntu0.1)
usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl]
      [-m minttl] [-O length] [-P proxy_username] [-p source_port]
      [-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout]
      [-X proxy_protocol] [-x proxy_address[:port]]       [destination] [port]
</code></pre>
<blockquote>
<ul>
<li>-4：只使用 IPv4 地址</li>
<li>-6：只使用 IPv6 地址</li>
<li>-l：启动本地监听</li>
<li>-n：不使用 DNS 解析</li>
<li>-p：指定源端口</li>
<li>-s：指定源 IP 地址</li>
<li>-u：使用 UDP, 默认是 TCP</li>
<li>-v：显示详细信息</li>
<li>-w：设定超时时间（只适合用在 Client 端）</li>
<li>-d：禁止从标准输入读取数据, 也就是客户端输入数据不会发送到服务端</li>
<li>-k：让服务端保持连接, 不断开</li>
</ul>
</blockquote>
<h2 id="建立本地会话"><a class="header" href="#建立本地会话">建立本地会话</a></h2>
<pre><code class="language-shell"># 模拟server端
# -v ：输出详细信息
# -l ：指定监听地址和端口
$ nc -v -l 127.0.0.1 6000

# 模拟client端
# -p : 指定源端口
$ nc -v -p 5000 localhost 6000
</code></pre>
<h2 id="发送文件"><a class="header" href="#发送文件">发送文件</a></h2>
<p>假设服务端有一个 <code>out.txt</code> 的空文件, 而客户端有一个<code>in.txt</code> 文件, 含有数据：<code>hello server</code>.</p>
<pre><code class="language-shell"># Server 端接收文件
$ nc localhost 6000 &gt; out.txt

# Client 端发送文件
nc localhost 6000 &lt; in.txt
</code></pre>
<h2 id="支持udp和ipv6连接"><a class="header" href="#支持udp和ipv6连接">支持UDP和IPv6连接</a></h2>
<pre><code class="language-shell"># server端
$ nc -u -6 -l localhost 6000
# client 端
$ nc -u -6 localhost 6000
</code></pre>
<h2 id="端口扫描"><a class="header" href="#端口扫描">端口扫描</a></h2>
<pre><code class="language-shell"># 扫描 192.168.1.3 上 1-100 端口区间, 有哪些端口是开放的
$ nc -vz 192.168.0.117 1-100
</code></pre>
<blockquote>
<p>如果我们想扫描多个服务器上的多个端口是否开放, 可以写一个脚本来完成</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netstat"><a class="header" href="#netstat">netstat</a></h1>
<p><code>Netstat</code>是控制台命令,是一个监控TCP/IP网络的非常有用的工具, 它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。</p>
<p><code>Netstat</code>用于显示与IP、TCP、UDP和ICMP协议相关的统计数据, 一般用于检验本机各端口的网络连接情况。</p>
<h2 id="1-输出信息描述"><a class="header" href="#1-输出信息描述">1. 输出信息描述</a></h2>
<pre><code class="language-shell">$ netstat
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 k8sdev.sui:sun-sr-https k8sdev.suiyi.com.:34880 SYN_RECV
tcp        0      0 k8sdev.suiyi.com.c:2379 10.1.62.21:47910        ESTABLISHED
tcp        0      0 k8sdev.suiyi.com.c:2379 k8sdev.suiyi.com.:37790 ESTABLISH
...
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  3      [ ]         DGRAM                    18442    /run/systemd/notify
unix  2      [ ]         DGRAM                    18444    /run/systemd/cgroups-agen
</code></pre>
<p>1、<strong>Active Internet connections</strong> 有源TCP连接, 其中"Recv-Q"和"Send-Q"指接收队列和发送队列。</p>
<p>这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</p>
<p>2、<strong>Active UNIX domain sockets</strong> 有源Unix域套接口(和网络套接字一样, 但是只能用于本机通信, 性能可以提高一倍)。</p>
<p>列名解释：</p>
<ul>
<li><code>Proto</code>：显示连接使用的<em>协议</em>。</li>
<li><code>RefCnt</code>：表示连接到本套接口上的<em>进程号</em>。</li>
<li><code>Types</code>：显示套接口的<em>类型</em>。</li>
<li><code>State</code>：显示套接口当前的<em>状态</em>。</li>
<li><code>Path</code>：表示连接到套接口的其它<em>进程使用的路径名</em>。</li>
</ul>
<h2 id="2-常见参数"><a class="header" href="#2-常见参数">2. 常见参数</a></h2>
<blockquote>
<p><code>-a</code> (all) 显示所有选项, 默认不显示LISTEN相关。
<code>-t</code> (tcp) 仅显示tcp相关选项。
<code>-u</code> (udp) 仅显示udp相关选项。
<code>-n</code> 拒绝显示别名, 能显示数字的全部转化成数字。
<code>-l</code> 仅列出有在 Listen (监听) 的服务状态。</p>
<p><code>-p</code> 显示建立相关链接的程序名
<code>-r</code> 显示路由信息, 路由表
<code>-e</code> 显示扩展信息, 例如uid等
<code>-s</code> 按各个协议进行统计
<code>-c</code> 每隔一个固定时间, 执行该netstat命令。</p>
<p>NOTE: <strong>LISTEN</strong>和<strong>LISTENING</strong>的状态只有用<code>-a</code>或者<code>-l</code>才能看到.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcpdump"><a class="header" href="#tcpdump">tcpdump</a></h1>
<blockquote>
<p>参考:</p>
<ul>
<li><a href="https://www.cnblogs.com/bakari/p/10748721.html">Linux 网络命令必知必会之 tcpdump, 一份完整的抓包指南请查收！</a></li>
</ul>
</blockquote>
<p><strong>tcpdump</strong> 是一款 Linux 平台的抓包工具。它可以抓取涵盖整个 TCP/IP 协议族的数据包, 支持针对网络层、协议、主机、端口的过滤, 并提供 and、or、not 等逻辑语句来过滤无用的信息。</p>
<h2 id="1-tcpdump命令选项"><a class="header" href="#1-tcpdump命令选项">1. tcpdump命令选项</a></h2>
<pre><code class="language-shell">root@swift:~# tcpdump -h
tcpdump version 4.9.3
libpcap version 1.8.1
OpenSSL 1.1.1  11 Sep 2018
Usage: tcpdump [-aAbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ]
		[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]
		[ -i interface ] [ -j tstamptype ] [ -M secret ] [ --number ]
		[ -Q in|out|inout ]
		[ -r file ] [ -s snaplen ] [ --time-stamp-precision precision ]
		[ --immediate-mode ] [ -T type ] [ --version ] [ -V file ]
		[ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ]
		[ -Z user ] [ expression ]
</code></pre>
<blockquote>
<ul>
<li><code>-A</code> 只使用 ASCII 打印报文的全部数据, 不要和 <code>-X</code> 一起使用, 获取 http 可以用 <code>tcpdump -nSA port 80</code></li>
<li><code>-b</code> 在数据链路层上选择协议, 包括 ip, arp, rarp, ipx 等</li>
<li><code>-c</code> 指定<strong>要抓取包的数量</strong></li>
<li><code>-D</code> 列出<strong>操作系统所有可以用于抓包的接口</strong></li>
<li><code>-e</code> <strong>输出链路层报头</strong></li>
<li><code>-i </code>指定<strong>监听的网卡</strong>, <code>-i any</code> 显示所有网卡</li>
<li><code>-n</code> 表示<strong>不解析主机名</strong>, 直接用 IP 显示, 默认是用 hostname 显示</li>
<li><code>-nn</code> 表示<strong>不解析主机名和端口</strong>, 直接用端口号显示, 默认显示是端口号对应的服务名</li>
<li><code>-p</code> <strong>关闭接口的混杂模式</strong></li>
<li><code>-P</code> 指定<strong>抓取的包是流入的包还是流出的</strong>, 可以指定参数 <code>in</code>, <code>out</code>, <code>inout</code> 等, 默认是 <code>inout</code></li>
<li><code>-q</code> 快速打印输出, 即只输出少量的协议相关信息</li>
<li><code>-s len</code>设置<strong>要抓取数据包长度为 len</strong>, 默认只会截取前 96bytes 的内容, <code>-s 0</code> 的话, 会截取全部内容。</li>
<li><code>-S</code> 将 <strong>TCP 的序列号以绝对值形式输出</strong>, 而不是相对值</li>
<li><code>-t</code> <strong>不要打印时间戳</strong></li>
<li><code>-vv</code> <strong>输出详细信息</strong>（比如 tos、ttl、checksum等）</li>
<li><code>-X</code> 同时用<strong>hex 和 ascii 显示报文内容</strong></li>
<li><code>-XX</code> 同 -X, 但<strong>同时显示以太网头部</strong></li>
</ul>
</blockquote>
<h2 id="2-过滤器"><a class="header" href="#2-过滤器">2. 过滤器</a></h2>
<p><code>tcpdump</code> 提供了灵活的语法可以精确获取我们关心的数据, 这些语法说得专业点就是过滤器。</p>
<p>过滤器简单可分为三类：<code>协议（proto）</code>,<code>传输方向（dir）</code>和<code>类型（type）</code>。</p>
<p><img src="pickup/../assets/202205071133428.png" alt="tcpdump" /></p>
<ul>
<li><code>proto</code>：可选有 **ip, arp, rarp, tcp, udp, icmp, ether **等, 默认是所有协议的包</li>
<li><code>dir</code>：可选有 <strong>src, dst, src or dst, src and dst</strong>, 默认为 src or dst</li>
<li><code>type</code>：可选有 <strong>host, net, port, portrange</strong>（端口范围, 比如 21-42）, 默认为 host</li>
</ul>
<h2 id="3tcpdump输出保存成文件"><a class="header" href="#3tcpdump输出保存成文件">3.tcpdump输出保存成文件</a></h2>
<p>tcpdump 提供了将抓取的数据保存到文件的功能, 查看文件就方便分析多了, 而且还能与其他图形工具一起配合分析, 比如 wireshark、Snort 等。<code>.pcap</code> 格式的文件需要用 wireshark、Snort 等工具查看, 使用 <code>vim</code> 或 <code>cat</code> 会出现乱码。</p>
<ul>
<li><code>-w</code>选项表示把数据报文输出到文件</li>
</ul>
<pre><code class="language-shell">$ tcpdump -w capture_file.pcap port 80 # 把所有 80 端口的数据导出到文件
</code></pre>
<ul>
<li><code>-r </code>选项表示读取文件里的数据报文, 显示到屏幕上</li>
</ul>
<pre><code class="language-shell">$ tcpdump -nXr capture_file.pcap host host1
</code></pre>
<h2 id="tcpdump的输出格式"><a class="header" href="#tcpdump的输出格式">tcpdump的输出格式</a></h2>
<blockquote>
<p>系统时间 源主机.端口 &gt; 目标主机.端口 数据包参数</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jq详解"><a class="header" href="#jq详解">jq详解</a></h1>
<blockquote>
<p>官方文档: <a href="https://stedolan.github.io/jq/manual/">jq</a></p>
</blockquote>
<h2 id="1-基本过滤"><a class="header" href="#1-基本过滤">1. 基本过滤</a></h2>
<ul>
<li>
<p>Identity: <code>.</code>  这是个标识符,</p>
</li>
<li>
<p>Object Identifier-Index: <code>.foo</code>, <code>.foo.bar</code>, 如果key包含特殊字符,要用双引号包裹</p>
</li>
<li>
<p>Optional Object Identifier-Index: <code>.foo?</code>, 同 <code>.foo</code>,当不是数组或对象时忽略错误</p>
</li>
<li>
<p>Generic Object Index: <code>.[&lt;string&gt;]</code>, 查找字段<code>.["foo"]</code>,(<code>.foo</code>是简写版)</p>
</li>
<li>
<p>Array Index: <code>.[&lt;value&gt;]</code></p>
</li>
<li>
<p>Array/String Slice: <code>.[10:15]</code>, 索引10~15的切片</p>
</li>
<li>
<p>Array/Object Value Iterator: <code>.[]</code>, 返回整个数组</p>
</li>
<li>
<p><code>.[]?</code> 同 <code>.[]</code>,当不是数组或对象时忽略错误</p>
</li>
<li>
<p>Comma: <code>,</code>, 两个同时过滤用逗号分隔,将按顺序获得输出</p>
</li>
<li>
<p>Pipe: <code>|</code>, 结合两个过滤.</p>
</li>
<li>
<p>Parenthesis: <code>()</code></p>
</li>
</ul>
<h2 id="2-类型和值"><a class="header" href="#2-类型和值">2. 类型和值</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-语法"><a class="header" href="#shell-语法">shell 语法</a></h1>
<h3 id="1-注释"><a class="header" href="#1-注释">1. 注释</a></h3>
<pre><code class="language-shell"># 这是一个单行注释

:&lt;&lt;EOF
这是多行注释
这是多行注释
这是多行注释
EOF

:&lt;&lt;'
这是多行注释
这是多行注释
这是多行注释
'

:&lt;&lt;!
这是多行注释
这是多行注释
这是多行注释
!
</code></pre>
<h3 id="2-变量"><a class="header" href="#2-变量">2. 变量</a></h3>
<p>定义变量时,变量名不加美元符号,**NOTE: 变量名和等号之间不能有空格.**使用时变量前加美元符号.可加<code>{}</code>分离边界</p>
<pre><code class="language-shell">your_name="tom"
echo $your_name

myUrl="https://www.google.com"
readonly myUrl # 只读变量

unset variable_name # 删除变量

</code></pre>
<h3 id="3-字符串"><a class="header" href="#3-字符串">3. 字符串</a></h3>
<p>字符串可用单引号或双引号,也可不用引号.</p>
<p>单引号限制:</p>
<ul>
<li>单引号里的任何字符都会原样输出, 单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行）, 但可成对出现, 作为字符串拼接使用。</li>
</ul>
<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<pre><code class="language-shell">str='this is a string'
str="Hello, I know you are \"$your_name\"! \n"
echo ${#str} # 获取字符串长度
echo ${str:1:4} 提取子字符串
echo `expr index $str io` # 查找子字符串
</code></pre>
<h3 id="4-数组"><a class="header" href="#4-数组">4. 数组</a></h3>
<p>bash支持一维数组（不支持多维数组）, 并且没有限定数组的大小。</p>
<pre><code class="language-shell">array_name=(value0 value1 value2 value3)
echo array_name[0]  
echo array_name[@] #获取所有元素
length=${#array_name[@]} #  取得数组元素的个数
length=${#array_name[*]} #  取得数组元素的个数
lengthn=${#array_name[n]} # 取得数组单个元素的长度
</code></pre>
<h3 id="5-传递参数"><a class="header" href="#5-传递参数">5. 传递参数</a></h3>
<p>执行 Shell 脚本时, 向脚本传递参数, 脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数处理</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">$#</td><td style="text-align: left">传递到脚本的参数个数</td></tr>
<tr><td style="text-align: left">$*</td><td style="text-align: left">以一个单字符串显示所有向脚本传递的参数。 如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</td></tr>
<tr><td style="text-align: left">$$</td><td style="text-align: left">脚本运行的当前进程ID号</td></tr>
<tr><td style="text-align: left">$!</td><td style="text-align: left">后台运行的最后一个进程的ID号</td></tr>
<tr><td style="text-align: left">$@</td><td style="text-align: left">与$*相同, 但是使用时加引号, 并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。</td></tr>
<tr><td style="text-align: left">$-</td><td style="text-align: left">显示Shell使用的当前选项, 与<a href="https://www.runoob.com/linux/linux-comm-set.html">set命令</a>功能相同。</td></tr>
<tr><td style="text-align: left">$?</td><td style="text-align: left">显示最后命令的退出状态。0表示没有错误, 其他任何值表明有错误。</td></tr>
</tbody></table>
</div>
<p>$* 与 $@ 区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3, , 则 " * " 等价于 "1 2 3"（传递了一个参数）, 而 "@" 等价于 "1" "2" "3"（传递了三个参数）。</li>
</ul>
<h3 id="6-运算符"><a class="header" href="#6-运算符">6. 运算符</a></h3>
<p>Shell 和其他编程语言一样, 支持多种运算符, 包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<h4 id="a-算术运算符"><a class="header" href="#a-算术运算符">a. 算术运算符</a></h4>
<p>原生bash不支持简单的数学运算, 但是可以通过其他命令来实现, 例如 <code>awk</code> 和 <code>expr</code>, <code>expr </code>最常用。</p>
<p>两点注意：</p>
<ul>
<li>表达式和运算符之间要有<strong>空格</strong>, 例如 2+2 是不对的, 必须写成 2 + 2, 这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 **`` ** 包含, 注意这个字符不是常用的单引号, 在 Esc 键下边。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">+</td><td style="text-align: left">加法</td><td style="text-align: left"><code>expr $a + $b</code> 结果为 30。</td></tr>
<tr><td style="text-align: left">-</td><td style="text-align: left">减法</td><td style="text-align: left"><code>expr $a - $b</code> 结果为 -10。</td></tr>
<tr><td style="text-align: left">*</td><td style="text-align: left">乘法</td><td style="text-align: left"><code>expr $a \* $b</code> 结果为  200。</td></tr>
<tr><td style="text-align: left">/</td><td style="text-align: left">除法</td><td style="text-align: left"><code>expr $b / $a</code> 结果为 2。</td></tr>
<tr><td style="text-align: left">%</td><td style="text-align: left">取余</td><td style="text-align: left"><code>expr $b % $a</code> 结果为 0。</td></tr>
<tr><td style="text-align: left">=</td><td style="text-align: left">赋值</td><td style="text-align: left">a=$b 将把变量 b 的值赋给 a。</td></tr>
<tr><td style="text-align: left">==</td><td style="text-align: left">相等。用于比较两个数字, 相同则返回 true。</td><td style="text-align: left">[ $a == $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">!=</td><td style="text-align: left">不相等。用于比较两个数字, 不相同则返回 true。</td><td style="text-align: left">[ $a != $b ] 返回 true。</td></tr>
</tbody></table>
</div>
<p>**注意：**条件表达式要放在方括号之间, 并且要有空格, 例如: <strong>[$a==$b]</strong> 是错误的, 必须写成 <strong>[ $a == $b ]</strong>。</p>
<h4 id="b-关系运算符"><a class="header" href="#b-关系运算符">b. 关系运算符</a></h4>
<p>关系运算符<strong>只支持数字, 不支持字符串, 除非字符串的值是数字</strong>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">-eq</td><td style="text-align: left">检测两个数是否相等, 相等返回 true。</td><td style="text-align: left">[ $a -eq $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">-ne</td><td style="text-align: left">检测两个数是否不相等, 不相等返回 true。</td><td style="text-align: left">[ $a -ne $b ] 返回 true。</td></tr>
<tr><td style="text-align: left">-gt</td><td style="text-align: left">检测左边的数是否大于右边的, 如果是, 则返回 true。</td><td style="text-align: left">[ $a -gt $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">-lt</td><td style="text-align: left">检测左边的数是否小于右边的, 如果是, 则返回 true。</td><td style="text-align: left">[ $a -lt $b ] 返回 true。</td></tr>
<tr><td style="text-align: left">-ge</td><td style="text-align: left">检测左边的数是否大于等于右边的, 如果是, 则返回 true。</td><td style="text-align: left">[ $a -ge $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">-le</td><td style="text-align: left">检测左边的数是否小于等于右边的, 如果是, 则返回 true。</td><td style="text-align: left">[ $a -le $b ] 返回 true。</td></tr>
</tbody></table>
</div>
<h4 id="c-布尔运算符"><a class="header" href="#c-布尔运算符">c. 布尔运算符</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">!</td><td style="text-align: left">非运算, 表达式为 true 则返回 false, 否则返回 true。</td><td style="text-align: left">[ ! false ] 返回 true。</td></tr>
<tr><td style="text-align: left">-o</td><td style="text-align: left">或运算, 有一个表达式为 true 则返回 true。</td><td style="text-align: left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr>
<tr><td style="text-align: left">-a</td><td style="text-align: left">与运算, 两个表达式都为 true 才返回 true。</td><td style="text-align: left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr>
</tbody></table>
</div>
<h4 id="d-逻辑运算符"><a class="header" href="#d-逻辑运算符">d. 逻辑运算符</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">&amp;&amp;</td><td style="text-align: left">逻辑的 AND</td><td style="text-align: left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr>
<tr><td style="text-align: left">||</td><td style="text-align: left">逻辑的 OR</td><td style="text-align: left">[[ $a -lt 100 || $b -gt 100 ]] 返回 true</td></tr>
</tbody></table>
</div>
<h4 id="e-字符串运算符"><a class="header" href="#e-字符串运算符">e. 字符串运算符</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">=</td><td style="text-align: left">检测两个字符串是否相等, 相等返回 true。</td><td style="text-align: left">[ $a = $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">!=</td><td style="text-align: left">检测两个字符串是否相等, 不相等返回 true。</td><td style="text-align: left">[ $a != $b ] 返回 true。</td></tr>
<tr><td style="text-align: left">-z</td><td style="text-align: left">检测字符串长度是否为0, 为0返回 true。</td><td style="text-align: left">[ -z $a ] 返回 false。</td></tr>
<tr><td style="text-align: left">-n</td><td style="text-align: left">检测字符串长度是否不为 0, 不为 0 返回 true。</td><td style="text-align: left">[ -n "$a" ] 返回 true。</td></tr>
<tr><td style="text-align: left">$</td><td style="text-align: left">检测字符串是否为空, 不为空返回 true。</td><td style="text-align: left">[ $a ] 返回 true。</td></tr>
</tbody></table>
</div>
<h4 id="f-文件测试运算符"><a class="header" href="#f-文件测试运算符">f. 文件测试运算符</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">-b file</td><td style="text-align: left">检测文件是否是块设备文件, 如果是, 则返回 true。</td><td style="text-align: left">[ -b $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-c file</td><td style="text-align: left">检测文件是否是字符设备文件, 如果是, 则返回 true。</td><td style="text-align: left">[ -c $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-d file</td><td style="text-align: left">检测文件是否是目录, 如果是, 则返回 true。</td><td style="text-align: left">[ -d $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-f file</td><td style="text-align: left">检测文件是否是普通文件（既不是目录, 也不是设备文件）, 如果是, 则返回 true。</td><td style="text-align: left">[ -f $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-g file</td><td style="text-align: left">检测文件是否设置了 SGID 位, 如果是, 则返回 true。</td><td style="text-align: left">[ -g $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-k file</td><td style="text-align: left">检测文件是否设置了粘着位(Sticky Bit), 如果是, 则返回 true。</td><td style="text-align: left">[ -k $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-p file</td><td style="text-align: left">检测文件是否是有名管道, 如果是, 则返回 true。</td><td style="text-align: left">[ -p $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-u file</td><td style="text-align: left">检测文件是否设置了 SUID 位, 如果是, 则返回 true。</td><td style="text-align: left">[ -u $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-r file</td><td style="text-align: left">检测文件是否可读, 如果是, 则返回 true。</td><td style="text-align: left">[ -r $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-w file</td><td style="text-align: left">检测文件是否可写, 如果是, 则返回 true。</td><td style="text-align: left">[ -w $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-x file</td><td style="text-align: left">检测文件是否可执行, 如果是, 则返回 true。</td><td style="text-align: left">[ -x $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-s file</td><td style="text-align: left">检测文件是否为空（文件大小是否大于0）, 不为空返回 true。</td><td style="text-align: left">[ -s $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-e file</td><td style="text-align: left">检测文件（包括目录）是否存在, 如果是, 则返回 true。</td><td style="text-align: left">[ -e $file ] 返回 true。</td></tr>
</tbody></table>
</div>
<p>其他检查符：</p>
<ul>
<li><strong>-S</strong>: 判断某文件是否 socket。</li>
<li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li>
</ul>
<h3 id="7-流程控制"><a class="header" href="#7-流程控制">7. 流程控制</a></h3>
<p>流程控制可用<code>break</code>和<code>continue</code> 控制循环</p>
<pre><code class="language-shell"># if 语句
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
# for 循环
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
# 或
for var in item1 item2 ... itemN; do command1; command2… done;

# while  循环
while condition
do
    command
done

# 无限循环
while :
do
    command
done
# 或
while true
do
    command
done
# 或
for (( ; ; ))

# until 循环
until condition
do
    command
done

# case 多选择语句
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac
</code></pre>
<h3 id="8-函数"><a class="header" href="#8-函数">8. 函数</a></h3>
<ul>
<li>
<p>函数返回值在调用该函数后通过 <code>$?</code> 来获得</p>
</li>
<li>
<p>调用函数时可以向其传递参数。在函数体内部, 通过 $n 的形式来获取参数的值, 例如, $1表示第一个参数, $2表示第二个参数</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数处理</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">$#</td><td style="text-align: left">传递到脚本或函数的参数个数</td></tr>
<tr><td style="text-align: left">$*</td><td style="text-align: left">以一个单字符串显示所有向脚本传递的参数</td></tr>
<tr><td style="text-align: left">$$</td><td style="text-align: left">脚本运行的当前进程ID号</td></tr>
<tr><td style="text-align: left">$!</td><td style="text-align: left">后台运行的最后一个进程的ID号</td></tr>
<tr><td style="text-align: left">$@</td><td style="text-align: left">与$*相同, 但是使用时加引号, 并在引号中返回每个参数。</td></tr>
<tr><td style="text-align: left">$-</td><td style="text-align: left">显示Shell使用的当前选项, 与set命令功能相同。</td></tr>
<tr><td style="text-align: left">$?</td><td style="text-align: left">显示最后命令的退出状态。0表示没有错误, 其他任何值表明有错误</td></tr>
</tbody></table>
</div>
<pre><code class="language-shell">[ function ] funname [()] {
    action;
    [return int;]
}
</code></pre>
<h3 id="9-输入输出重定向"><a class="header" href="#9-输入输出重定向">9. 输入输出重定向</a></h3>
<p>如果希望执行某个命令, 但又不希望在屏幕上显示输出结果, 那么可以将输出重定向到 <code>/dev/null</code></p>
<p>如果希望屏蔽 stdout 和 stderr,可以这么写<code>command &gt; /dev/null 2&gt;&amp;1</code>.</p>
<p>**注意：**0 是标准输入(STDIN),1 是标准输出(STDOUT),2 是标准错误输出(STDERR.)这里的 <strong>2</strong> 和 <strong>&gt;</strong> 之间不可以有空格, <strong>2&gt;</strong> 是一体的时候才表示错误输出。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">command &gt; file</td><td style="text-align: left">将输出重定向到 file。</td></tr>
<tr><td style="text-align: left">command &lt; file</td><td style="text-align: left">将输入重定向到 file。</td></tr>
<tr><td style="text-align: left">command &gt;&gt; file</td><td style="text-align: left">将输出以追加的方式重定向到 file。</td></tr>
<tr><td style="text-align: left">n &gt; file</td><td style="text-align: left">将文件描述符为 n 的文件重定向到 file。</td></tr>
<tr><td style="text-align: left">n &gt;&gt; file</td><td style="text-align: left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr>
<tr><td style="text-align: left">n &gt;&amp; m</td><td style="text-align: left">将输出文件 m 和 n 合并。</td></tr>
<tr><td style="text-align: left">n &lt;&amp; m</td><td style="text-align: left">将输入文件 m 和 n 合并。</td></tr>
<tr><td style="text-align: left">&lt;&lt; tag</td><td style="text-align: left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr>
</tbody></table>
</div>
<blockquote>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN）, 1 是标准输出（STDOUT）, 2 是标准错误输出（STDERR）。</p>
</blockquote>
<h3 id="10-文件包含"><a class="header" href="#10-文件包含">10. 文件包含</a></h3>
<pre><code class="language-shell">. filename   # 注意点号(.)和文件名中间有一空格
或
source filename
# 例
#使用 . 号来引用test1.sh 文件
. ./test1.sh
# 或者使用以下包含文件代码
# source ./test1.sh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cron语法"><a class="header" href="#cron语法">cron语法</a></h1>
<h2 id="一--linux下的表达式"><a class="header" href="#一--linux下的表达式">一.  linux下的表达式</a></h2>
<pre><code> |─────────────  minute  (0  -  59)  
 |  |────────────  hour  (0  -  23) 
 |  |  |───────────  day  of  month  (1  -  31)  
 |  |  |  |──────────  month  (1  -  12)  
 |  |  |  |  |────────  day  of  week  (0  -  6)  (Sunday  to  Saturday;   7  is  also  Sunday)  
 |  |  |  |  | 
 |  |  |  |  | 
 *  *  *  *  *  command  to  execute
</code></pre>
<h2 id="二-表达式详解"><a class="header" href="#二-表达式详解">二. 表达式详解</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Required</th><th>Allowed values</th><th>Allowed special characters</th><th>Remarks</th></tr></thead><tbody>
<tr><td>Seconds</td><td>Optional</td><td>0-59</td><td><code>* , - /</code></td><td>-</td></tr>
<tr><td>Minutes</td><td>Yes</td><td>0-59</td><td><code>* , - /</code></td><td>-</td></tr>
<tr><td>Hours</td><td>Yes</td><td>0-23</td><td><code>* , - /</code></td><td>-</td></tr>
<tr><td>Day of month</td><td>Yes</td><td>1-31</td><td><code>* , - / ? L W</code></td><td>-</td></tr>
<tr><td>Month</td><td>Yes</td><td>1-12 or JAN-DEC</td><td><code>* , - /</code></td><td>-</td></tr>
<tr><td>Day of week</td><td>Yes</td><td>0-6 or SUN-SAT</td><td><code>* , - / ? L #</code></td><td>-</td></tr>
<tr><td>Year</td><td>Optional</td><td>1970–2099</td><td><code>* , - /</code></td><td>This field is not supported in standard</td></tr>
</tbody></table>
</div>
<p>Cron表达式在标准中,有5个字段, <strong>Year</strong>字段在不是标准支持,在Cron格式的某些使用中, 模式的开头还有一个秒字段。 在这种情况下, CRON表达式是一个包含6或7个字段的字符串。</p>
<ul>
<li>
<p><strong>Asterisk(<code>*</code>)</strong>: 星号表示cron表达式将匹配该字段的所有值. 在<code>Month</code>域中使用星号将表示每个月。</p>
</li>
<li>
<p><strong>Comma(<code>,</code>)</strong>: 逗号用于分隔列表中的项. "<code>MON,WED,FRI</code>"在第(day of week)域中表示Mondays,Wednesdays and Fridays.</p>
</li>
<li>
<p><strong>Hyphen(<code>-</code>)</strong>: 连字符定义范围。例如,<code>2000-2010</code>表示2000年至2010年(包括2010年)的每一年。</p>
</li>
<li>
<p><strong>Percent(<code>％</code>)</strong> : 除非使用反斜杠(<code>\</code>)进行转义, 否则命令中的百分号（％）会更改为新行字符, 并且将第一个％之后的所有数据作为标准输入发送至命令。[10]</p>
</li>
<li>
<p>非标准的字符</p>
<ul>
<li>
<p><code>L</code>:  代表“最后”,</p>
<blockquote>
<p>在<code>Day-of-week</code>字段中使用时,它允许您指定诸如给定月份的“最后一个星期五”(“5L”)这样的结构。</p>
<p>在“<code>Day-of-month</code>”字段中, 它指定该月的最后一天。</p>
</blockquote>
</li>
<li>
<p><code>W</code>:  只在<code>Day-of-month</code>字段中允许使用<code>W</code>字符,此字符用于指定最接近给定日期的有效工作日(星期一至星期五)。</p>
<blockquote>
<p>例如, 如果您要指定“ 15W”作为<code>Day-of-month</code>字段的值, 则含义是：“离月15日最近的工作日”。</p>
<p>如果15号是星期六, 那么触发器将在14号星期五触发。</p>
<p>如果15日是星期日, 则触发器将在16日星期一触发。</p>
<p>如果15号是星期二, 那么它将在15号星期二触发。</p>
<p>但是, 如果您指定“ 1W”作为月份的值, 并且第一个是星期六, 则触发器将在第3个星期一触发, 因为它不会“跳过”一个月日的边界。 仅当月份中的某天是一天, 而不是范围或天数列表时, 才可以指定“ W”字符</p>
</blockquote>
</li>
<li>
<p><strong>Hash(<code>#</code>)</strong>: 只能在<code>Day-of-week</code>字段中允许使用<code>＃</code>, 并且后面必须跟一个1到5之间的数字,它允许您指定诸如给定月份的“第二个星期五”这样的结构. 例如, 在<code>Day-of-week</code>字段中输入<code>6#3</code>表示每月的第三个星期五。</p>
</li>
<li>
<p><strong>Question(<code>?</code>)</strong>:  在某些实现中,代替<code>*</code>来保留<code>Day-of-month</code>或<code>Day-of-week</code>域为空白. 其它某些的Cron实现用来匹配当时Cron的启动的时间, 例如,如果cron在上午8:25启动, 则<code>? ? * * * *</code>将更新为<code>25 8 * * * *</code>, 并且cron在每天的这个时间运行这个命令.</p>
</li>
<li>
<p><strong>Slash(<code>/</code>)</strong>: 可以将斜线与范围组合以指定步长值. 例如: <code>Minutes</code>字段中的<code>*/5</code>表示每5分钟显示一次.</p>
</li>
</ul>
</li>
</ul>
<h2 id="三-非标准的预定义调度定义"><a class="header" href="#三-非标准的预定义调度定义">三. 非标准的预定义调度定义</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Entry</th><th>Description</th><th>Equivalent to</th></tr></thead><tbody>
<tr><td><code>@yearly (or @annually)</code></td><td>Run once a year at midnight of 1 January</td><td><code>0 0 1 1 *</code></td></tr>
<tr><td><code>@monthly</code></td><td>Run once a month at midnight of the first day of the month</td><td><code>0 0 1 * *</code></td></tr>
<tr><td><code>@weekly</code></td><td>Run once a week at midnight on Sunday morning</td><td><code>0 0 * * 0</code></td></tr>
<tr><td><code>@daily</code></td><td>Run once a day at midnight</td><td><code>0 0 * * *</code></td></tr>
<tr><td><code>@hourly</code></td><td>Run once an hour at the beginning of the hour</td><td><code>0 * * * *</code></td></tr>
<tr><td><code>@reboot</code></td><td>Run at startup</td><td>N/A</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="yaml语法"><a class="header" href="#yaml语法">yaml语法</a></h1>
<h2 id="格式数据类型"><a class="header" href="#格式数据类型">格式数据类型</a></h2>
<p>常量,对象,数据</p>
<h2 id="格式要求"><a class="header" href="#格式要求">格式要求</a></h2>
<ul>
<li><code>#</code>表示注释</li>
<li>大小写敏感</li>
<li>缩进表示层级关系</li>
<li>缩进只能使用空格,不能使用TAB,不要求空格个数,只需要相同层级左对齐,(2个或4个空格)</li>
</ul>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<h3 id="对象"><a class="header" href="#对象">对象</a></h3>
<ul>
<li>键值对: <code>key:value</code></li>
<li>层级关系</li>
</ul>
<pre><code class="language-yaml">key:
    child-key: value
    child-key2: value2
</code></pre>
<ul>
<li>流式(flow)语法,上面可表示</li>
</ul>
<pre><code class="language-yaml">key:{child-key: value,  child-key2: value2}
</code></pre>
<ul>
<li>复杂对象格式, 可使用问号加一个空格代表一个复杂的key, 配合一个冒号加一个空格代表一个值</li>
</ul>
<pre><code class="language-yaml">?
  - complexkey1
  - complexkey2
:
  - complexvalue1
  - complexvalue2
</code></pre>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<ul>
<li>短横线加一个空格代表一个数组项</li>
</ul>
<pre><code class="language-yaml">hobby:
    - java
    - go
</code></pre>
<pre><code class="language-yaml">-
  - java
  - go
# 理解为[[java,go]]
</code></pre>
<ul>
<li>复杂</li>
</ul>
<pre><code class="language-yaml">companies:
  -
    id: 1
    name: company1
    price: 200W
  -
    id: 2
     name: company2
</code></pre>
<h3 id="常量"><a class="header" href="#常量">常量</a></h3>
<ul>
<li>boolean
<ul>
<li>TRUE,true,True均可以</li>
<li>FALSE,false,False均可以</li>
</ul>
</li>
<li>float
<ul>
<li>3.14</li>
<li>6.8523015e+5  #可以使用科学计数法</li>
</ul>
</li>
<li>整数
<ul>
<li>123</li>
<li>0b1010_0111_0100_1010_1110    #二进制表</li>
</ul>
</li>
<li>string
<ul>
<li>哈哈</li>
<li>'Hello world'  #可以使用双引号或者单引号包裹特殊字符</li>
<li>字符串可以拆成多行, 每一行会被转化成一个空格</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">  newline
  newline2
</code></pre>
<ul>
<li>date
<ul>
<li>2018-07-17    #日期必须使用ISO 8601格式, 即yyyy-MM-dd</li>
</ul>
</li>
<li>datetime
<ul>
<li>2018-07-17T19:02:31+08:00    #时间使用ISO 8601格式, 时间和日期之间使用T连接, 最后使用+代表时区</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protobuf语法"><a class="header" href="#protobuf语法">Protobuf语法</a></h1>
<blockquote>
<p><a href="https://developers.google.cn/protocol-buffers">官方文档</a></p>
</blockquote>
<h2 id="一-定义消息类型"><a class="header" href="#一-定义消息类型">一. 定义消息类型</a></h2>
<p><code>.proto</code>文件定义消息类型</p>
<pre><code class="language-protobuf">syntax = "proto3";
// option go_package = ".;pb";
/* 查询请求*/
message SearchRequest {
      reserved 4, 15, 9 to 11;
      string query = 1; // 查询
      int32 page_number = 2;
      int32 result_per_page = 3;
}

message SearchResponse {
      repeated Result results = 1;
}

message Result {
      string url = 1;
      string title = 2;
      repeated string snippets = 3;
}
</code></pre>
<ul>
<li>
<p>第一行定义了使用的<code>protobuf</code>的协议的版本,如果不设置,则为proto2版本. 文件第一行必须非空,非注释行</p>
</li>
<li>
<p>可选定义go的包名</p>
</li>
<li>
<p>采用C/C++风格的注释,即使<code>//</code>和<code>/**/</code>.</p>
</li>
<li>
<p><code>SearchRequest</code>定义了三个域(名称/值对),每个字段都有一个名称和一个类型</p>
<ul>
<li>
<p>每个字段都有对应的标量类型( [scalar types](#二. 标量类型(scalar types)))</p>
</li>
<li>
<p>每一个字段都定有唯一数值编号. 这些字段用于标识二进制编码的域位置,一旦定义并使用后,不应该再修改.</p>
<blockquote>
<ul>
<li>
<p>字段数值编号<strong>1-15</strong>只使用一个字节进行编码,包括字段数值编号和字段类型.</p>
</li>
<li>
<p>字段数值编号<strong>16-2047</strong>将使用两个字节进行编码</p>
</li>
<li>
<p>最小的字段编号为1,最大2^29 - 1, or 536,870,911.</p>
</li>
<li>
<p><strong>19000-19999</strong> (<strong>FieldDescriptor::kFirstReservedNumber</strong>-<strong>FieldDescriptor::kLastReservedNumber</strong>)为<code>protobuf</code>保留字段,不可使用.</p>
<p>对于频繁出现的消息最好使用<strong>1-15</strong>,切记为将来可能添加的频繁出现的元素留出一些空间</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>字段规则</p>
<ul>
<li><code>singular</code>: 字段为0或1个,这是默认规则.</li>
<li><code>repeated</code>: 该字段可以在格式良好的消息中重复任意次数(包括0),重复值的顺序将保留. 在<code>proto3</code>中, 默认情况下, 标量数字类型的<code>repeated</code>字段使用打包编码</li>
</ul>
</li>
</ul>
</li>
<li>
<p>保留字段<code>reserved</code>, 可以采用保留编号或保留字段名的方式,进行保留, 当删除一些旧的编号或字段时,可以防止后续使用,引起不必要的bug.</p>
</li>
<li>
<p>可以使用其它消息类型作为字段. 如<code>Result</code>在<code>SearchResponse</code>里使用</p>
</li>
<li>
<p>使用 <a href="https://developers.google.cn/protocol-buffers/docs/proto3#generating">protocol buffer compiler</a> 编译将产生对应的代码</p>
</li>
</ul>
<h2 id="二-标量类型scalar-types"><a class="header" href="#二-标量类型scalar-types">二. 标量类型(scalar types)</a></h2>
<p><a href="https://developers.google.cn/protocol-buffers/docs/proto3#scalar">scalar types</a></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">.proto</th><th style="text-align: left">Notes</th><th style="text-align: left">C++</th><th style="text-align: left">Go</th><th style="text-align: left">Dart</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>double</code></td><td style="text-align: left"></td><td style="text-align: left">double</td><td style="text-align: left">float64</td><td style="text-align: left">double</td></tr>
<tr><td style="text-align: left"><code>float</code></td><td style="text-align: left"></td><td style="text-align: left">float</td><td style="text-align: left">float32</td><td style="text-align: left">double</td></tr>
<tr><td style="text-align: left"><code>int32</code></td><td style="text-align: left">使用变长编码,负数编码效率低下,如果字段可能有负数,使用sint32</td><td style="text-align: left">int32</td><td style="text-align: left">int32</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><code>int64</code></td><td style="text-align: left">使用变长编码,负数编码效率低下,如果字段可能有负数,使用sint64</td><td style="text-align: left">int64</td><td style="text-align: left">int64</td><td style="text-align: left">Int64</td></tr>
<tr><td style="text-align: left"><code>uint32</code></td><td style="text-align: left">使用变长编码</td><td style="text-align: left">uint32</td><td style="text-align: left">uint32</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><code>uint64</code></td><td style="text-align: left">使用变长编码</td><td style="text-align: left">uint64</td><td style="text-align: left">uint64</td><td style="text-align: left">Int64</td></tr>
<tr><td style="text-align: left"><code>sint32</code></td><td style="text-align: left">使用变长编码。有符号的整型。它们比int32编码负数效率更高</td><td style="text-align: left">int32</td><td style="text-align: left">int32</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><code>sint64</code></td><td style="text-align: left">使用变长编码。有符号的整型。它们比int64编码负数效率更高</td><td style="text-align: left">int64</td><td style="text-align: left">int64</td><td style="text-align: left">Int64</td></tr>
<tr><td style="text-align: left"><code>fixed32</code></td><td style="text-align: left">固定4字节编码,如果值大于2^28比uint32编码效率更高</td><td style="text-align: left">uint32</td><td style="text-align: left">uint32</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><code>fixed64</code></td><td style="text-align: left">固定8字节编码,如果值大于2^68比uint32编码效率更高</td><td style="text-align: left">uint64</td><td style="text-align: left">uint64</td><td style="text-align: left">Int64</td></tr>
<tr><td style="text-align: left"><code>sfixed32</code></td><td style="text-align: left">固定4字节</td><td style="text-align: left">int32</td><td style="text-align: left">int32</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left"><code>sfixed64</code></td><td style="text-align: left">固定8字节</td><td style="text-align: left">int64</td><td style="text-align: left">int64</td><td style="text-align: left">Int64</td></tr>
<tr><td style="text-align: left"><code>bool</code></td><td style="text-align: left"></td><td style="text-align: left">bool</td><td style="text-align: left">bool</td><td style="text-align: left">bool</td></tr>
<tr><td style="text-align: left"><code>string</code></td><td style="text-align: left">utf-8或ASCII编码,长度不应超过2^32</td><td style="text-align: left">string</td><td style="text-align: left">string</td><td style="text-align: left">String</td></tr>
<tr><td style="text-align: left"><code>bytes</code></td><td style="text-align: left">包含任意的字节,长度不应超过2^32</td><td style="text-align: left">string</td><td style="text-align: left">[]byte</td><td style="text-align: left">List</td></tr>
</tbody></table>
</div>
<h2 id="三-默认值"><a class="header" href="#三-默认值">三. 默认值</a></h2>
<p>解析消息时, 如果编码的消息不包含特定的单数元素, 则已解析对象中的相应字段将设置为该字段的默认值。 这些默认值是特定于类型的：</p>
<ul>
<li>string: 空字符串</li>
<li>bytes: 空字节流.</li>
<li>bools: false.</li>
<li>numeric types: 0</li>
<li>enums: 枚举的第一个值,且必须为0.</li>
<li>message fields: 取决于所用的语言(See <a href="https://developers.google.cn/protocol-buffers/docs/reference/overview">generated code guide</a>)</li>
</ul>
<h2 id="四-枚举"><a class="header" href="#四-枚举">四. 枚举</a></h2>
<pre><code class="language-protobuf">message SearchRequest {
      string query = 1;
      int32 page_number = 2;
      int32 result_per_page = 3;
      enum Corpus {
            option allow_alias = true;
            UNIVERSAL = 0;
            WEB = 1;
            IMAGES = 2;
            LOCAL = 3;
            AliasLocal = 3,
      }
      Corpus corpus = 4;
}
</code></pre>
<p>如您所见, Corpus枚举的第一个常量映射为零：每个枚举定义必须包含一个映射为零的常量作为其第一个元素。 这是因为：</p>
<ul>
<li>必须有一个零值, 以便我们可以使用0作为数字默认值。</li>
<li>零值必须是第一个元素, 以便与<code>proto2</code>语义兼容, 其中第一个枚举值始终是默认值。</li>
<li>您可以通过将相同的值分配给不同的枚举常量来定义别名. 首先你得设置<code>allow_alias</code>为<code>true</code></li>
<li>枚举值的范围为32位整型,采用 <a href="https://developers.google.cn/protocol-buffers/docs/encoding">varint encoding</a> 编码,不建议采用负数.</li>
</ul>
<h2 id="五-导入定义"><a class="header" href="#五-导入定义">五. 导入定义</a></h2>
<pre><code class="language-protobuf">import "myproject/other_protos.proto";
</code></pre>
<p>默认情况下, 您只能使用直接导入的<code>.proto</code>文件中的定义。 但是, 有时您可能需要将<code>.proto</code>文件移动到新位置。</p>
<p>现在, 您可以直接在原始位置放置一个虚拟的<code>.proto</code>文件, 而不是直接移动<code>.proto</code>文件并一次更改所有呼叫站点, 而是使用导入<code>import public</code>将所有导入转发到新位置。</p>
<p>任何导入包含导入<code>import public</code>的原型的人都可以可传递地依赖导入<code>import public</code>依赖项。 例如</p>
<pre><code class="language-protobuf">// new.proto
// All definitions are moved here
</code></pre>
<pre><code class="language-protobuf">// old.proto
// This is the proto that all clients are importing.
import public "new.proto";
import "other.proto";
</code></pre>
<pre><code class="language-protobuf">// client.proto
import "old.proto";
// You use definitions from old.proto and new.proto, but not other.proto
</code></pre>
<p>协议编译器使用<code>-I /-proto_path</code>标志在协议编译器命令行中指定的一组目录中搜索导入的文件。</p>
<p>如果未给出任何标志, 它将在调用编译器的目录中查找。 通常, 应将<code>--proto_path</code>标志设置为项目的根目录, 并对所有导入使用完全限定的名称。</p>
<h2 id="六-其它内置类型定义"><a class="header" href="#六-其它内置类型定义">六. 其它内置类型定义</a></h2>
<h3 id="1-any"><a class="header" href="#1-any">1. Any</a></h3>
<p><code>Any</code>消息类型使您可以将消息用作嵌入式类型, 而无需定义它们的<code>.proto</code>。</p>
<p><code>Any</code>包含任意序列化消息（以字节为单位）以及URL, URL作为该消息的类型并解析为该消息的类型的全局唯一标识符。</p>
<pre><code class="language-protobuf">import "google/protobuf/any.proto";

message ErrorStatus {
      string message = 1;
      repeated google.protobuf.Any details = 2;
}
</code></pre>
<h3 id="2-oneof"><a class="header" href="#2-oneof">2. Oneof</a></h3>
<p>如果您有一则消息包含许多字段, 并且最多可以同时设置一个字段, 则可以使用oneof功能强制执行此行为并节省内存。</p>
<p>可以添加任何字段到<code>oneof</code>,除了<code>map</code>和<code>repeated</code></p>
<pre><code class="language-protobuf">message SampleMessage {
      oneof test_oneof {
            string name = 4;
            SubMessage sub_message = 9;
      }
}
</code></pre>
<h3 id="3-maps"><a class="header" href="#3-maps">3. Maps</a></h3>
<p>如果要在数据定义中创建关联映射, 则协议缓冲区提供了方便的快捷方式语法：</p>
<pre><code class="language-protobuf">map&lt;key_type, value_type&gt; map_field = N;
</code></pre>
<ul>
<li><code>key_type</code>可以是任何integral或string类型(除了float和bytes之外),<code>enum</code>不是有效的<code>key_type</code></li>
<li><code>value_type</code>可以是除<code>Maps</code>以外的任何类型。</li>
</ul>
<pre><code class="language-protobuf">map&lt;string, Project&gt; projects = 3;
</code></pre>
<ul>
<li>
<p>映射字段不能重复。</p>
</li>
<li>
<p>map值的编码顺序和迭代顺序是未定义的, 因此您不能依赖于map处于特定的顺序。</p>
</li>
<li>
<p>当为<code>.proto</code>生成文本格式时, 地图将按键排序。 数字键按数字排序。</p>
</li>
<li>
<p>从数据解析或合并时, 如果存在重复的映射键, 则使用最后看到的键。 从文本格式解析时, 如果键重复, 则解析可能会失败。</p>
</li>
<li>
<p>如果为映射字段提供键但没有值, 则序列化字段时的行为取决于语言。 在C ++, Java和Python中, 类型的默认值是序列化的, 而在其他语言中, 则没有序列化的值。</p>
</li>
</ul>
<h2 id="七-包定义"><a class="header" href="#七-包定义">七. 包定义</a></h2>
<p>可以在<code>.proto</code>文件中添加可选的包说明符, 以防止协议消息类型之间的名称冲突。</p>
<pre><code class="language-protobuf">package foo.bar;
message Open { ... }
</code></pre>
<p>在Go中, 除非您在<code>.proto</code>文件中明确提供了<code>go_package</code>选项, 否则该包将用作Go包名称</p>
<h2 id="八-定义服务"><a class="header" href="#八-定义服务">八. 定义服务</a></h2>
<p>如果要将消息类型与RPC(远程过程调用)系统一起使用, 则可以在<code>.proto</code>文件中定义RPC服务接口, 并且协议protocolbuf编译器将以您选择的语言生成服务接口代码和存根。</p>
<p>例如, 如果要使用接收<code>SearchRequest</code>并返回<code>SearchResponse</code>的方法来定义RPC服务, 则可以在<code>.proto</code>文件中定义它, 如下所示：</p>
<pre><code class="language-protobuf">service SearchService {
      rpc Search(SearchRequest) returns (SearchResponse);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ansible-基本使用"><a class="header" href="#ansible-基本使用">ansible 基本使用</a></h1>
<blockquote>
<pre><code class="language-sh">ansible &lt;host-pattern&gt; [-m module_name] [-a args]
</code></pre>
</blockquote>
<h2 id="一-架构和原理"><a class="header" href="#一-架构和原理">一. 架构和原理</a></h2>
<h2 id="二-常用模块"><a class="header" href="#二-常用模块">二. 常用模块</a></h2>
<h3 id="1-command-默认"><a class="header" href="#1-command-默认">1. command 默认</a></h3>
<p><code>ansible &lt;host-pattern&gt; -a 'ls /'</code></p>
<h3 id="2-shell"><a class="header" href="#2-shell">2. shell</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m shell -a 'ls /'</code></p>
<h3 id="3-script-在远程主机执行脚本"><a class="header" href="#3-script-在远程主机执行脚本">3. script 在远程主机执行脚本</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m script -a 'path/xx.sh'</code></p>
<h3 id="4-copy-复制文件到远程主机"><a class="header" href="#4-copy-复制文件到远程主机">4. copy 复制文件到远程主机</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m copy -a 'src=path/srcfile dest=path/destfile backup=yes'</code></p>
<h3 id="5-fetch-从远程主机取文件到本机"><a class="header" href="#5-fetch-从远程主机取文件到本机">5. fetch 从远程主机取文件到本机</a></h3>
<p>不支持,可以考虑目录可以先进行tar压缩</p>
<p><code>ansible &lt;host-pattern&gt; -m fetch -a 'src=path/srcfile dest=path/destfile'</code></p>
<h3 id="6-file-设置文件目录的属性"><a class="header" href="#6-file-设置文件目录的属性">6. file 设置文件/目录的属性</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m file -a 'name=path/file state=touch'</code></p>
<h3 id="7-hostname-修改主机名"><a class="header" href="#7-hostname-修改主机名">7. hostname 修改主机名</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m hostname -a 'name=newhostname'</code></p>
<h3 id="8-cron-计划任务"><a class="header" href="#8-cron-计划任务">8. cron 计划任务</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m cron -a 'minute=* job=""/usr/bin/wall fbi warn" name=warning'</code></p>
<h3 id="9-apt-ubuntudebian包管理"><a class="header" href="#9-apt-ubuntudebian包管理">9. apt ubuntu/debian包管理</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m apt -a 'name=dstat update_cache=yes upgrade=yes'</code></p>
<h3 id="10-service-服务管理"><a class="header" href="#10-service-服务管理">10. service 服务管理</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m service -a 'name=httpd enabled=yes state=[stated|stopped|reloaded|restarted]'</code></p>
<h3 id="11-user-用户管理"><a class="header" href="#11-user-用户管理">11. user 用户管理</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m user -a 'name=user1 comment="test user" uid=2048 home=/home/user1 group=root'</code></p>
<h3 id="12-group-组管理"><a class="header" href="#12-group-组管理">12. group 组管理</a></h3>
<p><code>ansible &lt;host-pattern&gt; -m group -a "name=testgroup system=yes"</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glob-匹配规则"><a class="header" href="#glob-匹配规则">glob 匹配规则</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Glob_(programming)#cite_note-5">glob</a> wiki</li>
</ul>
<h2 id="1-语法"><a class="header" href="#1-语法">1. 语法</a></h2>
<p>最常用的通配符是<code>*</code>, <code>?</code>,和<code>[...]</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Wildcard</th><th style="text-align: center">Description</th><th style="text-align: center">Example</th><th style="text-align: center">Matches</th><th style="text-align: center">Does not match</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>*</code></td><td style="text-align: center">匹配任意数量的字符, 包括空</td><td style="text-align: center"><code>Law*</code></td><td style="text-align: center"><code>Law</code>, <code>Laws</code>, or <code>Lawyer</code></td><td style="text-align: center"><code>GrokLaw</code>, <code>La</code>, or <code>aw</code></td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"><code>*Law*</code></td><td style="text-align: center"><code>Law</code>, <code>GrokLaw</code>, or <code>Lawyer</code>.</td><td style="text-align: center"><code>La</code>, or <code>aw</code></td></tr>
<tr><td style="text-align: center"><code>?</code></td><td style="text-align: center">匹配单个字符</td><td style="text-align: center"><code>?at</code></td><td style="text-align: center"><code>Cat</code>, <code>cat</code>, <code>Bat</code> or <code>bat</code></td><td style="text-align: center"><code>at</code></td></tr>
<tr><td style="text-align: center"><code>[abc]</code></td><td style="text-align: center">匹配括号内的字符</td><td style="text-align: center"><code>[CB]at</code></td><td style="text-align: center"><code>Cat</code> or <code>Bat</code></td><td style="text-align: center"><code>cat</code>, <code>bat</code> or <code>CBat</code></td></tr>
<tr><td style="text-align: center"><code>[a-z]</code></td><td style="text-align: center">匹配括号内给的字符范围</td><td style="text-align: center"><code>Letter[0-9]</code></td><td style="text-align: center"><code>Letter0</code>, <code>Letter1</code>, <code>Letter2</code> up to <code>Letter9</code></td><td style="text-align: center"><code>Letters</code>, <code>Letter</code> or <code>Letter10</code></td></tr>
</tbody></table>
</div>
<p>一般情况下, 路径分隔符(Linux/Unix, MacOS上的<code>/</code>或Windows的<code>\</code>)是从不匹配的,但是一些shell,比如Bash是允许用户规避此问题.</p>
<p><strong>Unix-like</strong></p>
<p>在 <a href="https://en.wikipedia.org/wiki/Unix-like">Unix-like</a> 系统, 在<code>[...]</code>上有两个附加含义.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Wildcard</th><th style="text-align: center">Description</th><th style="text-align: center">Example</th><th style="text-align: center">Matches</th><th style="text-align: center">Does not match</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>[!abc]</code></td><td style="text-align: center">匹配不在括号内的字符</td><td style="text-align: center"><code>[!C]at</code></td><td style="text-align: center"><code>Bat</code>, <code>bat</code>, or <code>cat</code></td><td style="text-align: center"><code>Cat</code></td></tr>
<tr><td style="text-align: center"><code>[!a-z]</code></td><td style="text-align: center">匹配不在括号内给的字符范围</td><td style="text-align: center"><code>Letter[!3-5]</code></td><td style="text-align: center"><code>Letter1</code>, <code>Letter2</code>, <code>Letter6</code> up to <code>Letter9</code> and <code>Letterx</code> etc.</td><td style="text-align: center"><code>Letter3</code>, <code>Letter4</code>, <code>Letter5</code> or <code>Letterxx</code></td></tr>
</tbody></table>
</div>
<p><code>Bash</code>支持以下扩展:</p>
<ul>
<li><code>**</code>: 递归匹配</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nats"><a class="header" href="#nats">NATS</a></h1>
<p>特性:</p>
<ul>
<li>Core NATS</li>
<li>JetStream</li>
</ul>
<p>优势:</p>
<ul>
<li>边缘与云原生消息系统, <code>CNCF</code>毕业项目, 社区活跃度高, 文档完善.</li>
<li><code>golang</code>编写, 服务端程序极小, 不到20M.</li>
<li>支持客户端的语言非常多, 主流语言基本都支持.</li>
<li>支持内存级的<code>Core NATS</code>, 有发布-订阅, 请求-回复(类似RPC), 队列组等功能</li>
<li>支持持久化的<code>JetStream</code>, 在<code>Core NATS</code>之上提供消息持久化, 消息确认, 消息重试, 消息保序等机制, 另外还提供<code>Key-Value</code>存储, 对象存储功能.
<ul>
<li>每一个<code>Stream</code>独立提供丰富的配置</li>
<li>每一个<code>Stream</code>的每一个<code>Consumer</code>独立提供丰富配置</li>
</ul>
</li>
<li>支持安全的身份验证和授权访问机制, 支持TLS, JWT-based zero trust security</li>
<li>支持集群, 可以水平扩展, 提供高可用, 高并发的消息系统</li>
<li>协议层面支持 TCP, MQTT, WebSockets</li>
</ul>
<h2 id="1-core-nats"><a class="header" href="#1-core-nats">1. Core NATS</a></h2>
<h3 id="11-publish-subscribe发布-订阅"><a class="header" href="#11-publish-subscribe发布-订阅">1.1 Publish-Subscribe(发布-订阅)</a></h3>
<p><img src="https://docs.nats.io/~gitbook/image?url=https%3A%2F%2F1487470910-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F-LqMYcZML1bsXrN3Ezg0%252Fuploads%252Fgit-blob-22d59af386038cc2717176561ffc95c63c295926%252Fpubsub.svg%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=1a700ae8&amp;sv=2" alt="ps" /></p>
<h3 id="12-request-reply请求-回复"><a class="header" href="#12-request-reply请求-回复">1.2 Request-Reply(请求-回复)</a></h3>
<p><img src="https://docs.nats.io/~gitbook/image?url=https%3A%2F%2F1487470910-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F-LqMYcZML1bsXrN3Ezg0%252Fuploads%252Fgit-blob-dc10798d4afca301adba55c1e85c599b25a2ae24%252Freqrepl.svg%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=4fdca5ce&amp;sv=2" alt="rr" /></p>
<h3 id="13-queuegroup队列组"><a class="header" href="#13-queuegroup队列组">1.3 QueueGroup(队列组)</a></h3>
<p><img src="https://docs.nats.io/~gitbook/image?url=https%3A%2F%2F1487470910-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F-LqMYcZML1bsXrN3Ezg0%252Fuploads%252Fgit-blob-62652b3e6dd556e3cb1c3bb474ec10038334c600%252Fqueue.svg%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=ab76b046&amp;sv=2" alt="qg" /></p>
<h2 id="2-jetstream"><a class="header" href="#2-jetstream">2. JetStream</a></h2>
<p><code>JetStream</code>在<code>Core NATS</code>基本功能的基础上实现新的功能和更高的服务质量.</p>
<h3 id="21-streams"><a class="header" href="#21-streams">2.1 Streams</a></h3>
<h4 id="211-replay-policies重放策略"><a class="header" href="#211-replay-policies重放策略">2.1.1 Replay policies(重放策略)</a></h4>
<p>JetStream 消费者支持多种重放策略, 具体取决于消费应用程序是否希望接收策略:</p>
<ul>
<li>存储在<code>stream</code>中的所有消息, 可以完整重放, 也可以选择重放策略(即重放速度):
<ul>
<li><code>instant</code>: (以最快的速度向消费者发送消息).</li>
<li><code>original</code>: (这意味着消息将以发布到流中的速度传送给消费者, 这对于暂存生产流量非常有用. )</li>
</ul>
</li>
<li>存储在<code>stream</code>中的最后一条消息, 或每个主题的最后一条消息 (因为流可以捕获多个主题).</li>
<li>从特定序列号开始.</li>
<li>从特定的开始时间开始.</li>
</ul>
<h4 id="212-retention-policies-and-limits保留政策和限制"><a class="header" href="#212-retention-policies-and-limits保留政策和限制">2.1.2 Retention policies and limits(保留政策和限制)</a></h4>
<h5 id="2121-limits限制"><a class="header" href="#2121-limits限制">2.1.2.1 Limits(限制)</a></h5>
<p>你可以对<code>stream</code>施加以下限制:</p>
<ul>
<li>最大消息年龄</li>
<li><code>stream</code>的最大总大小(字节)</li>
<li><code>stream</code>的消息最大总数量</li>
<li>单条消息的最大大小</li>
<li>还可以设置在任何给定时间点为<code>stream</code>定义的消费者数量限制</li>
</ul>
<p>您还必须选择一个丢弃策略, 该策略规定了一旦<code>stream</code>达到其限制之一并有新消息发布时应该发生的情况:</p>
<ul>
<li><code>discard old</code>: 表示<code>stream</code>将自动删除<code>stream</code>中最旧的消息, 为新消息腾出空间.</li>
<li><code>discard new</code>: 表示丢弃新消息 (JetStream 发布调用会返回错误消息, 表明已达到限制).</li>
</ul>
<h5 id="2122-retention-policy保留策略"><a class="header" href="#2122-retention-policy保留策略">2.1.2.2 Retention policy(保留策略)</a></h5>
<p>您可以为每个<code>stream</code>选择所需的保留策略:</p>
<ul>
<li><code>limits</code>:  (默认)是提供流中消息的重播.</li>
<li><code>work queue</code>: 来提供<code>stream</code>中消息的只有一次的消费(消息流被用作共享队列, 消息被消费时会从队列中移除).</li>
<li><code>interest</code>: 是工作队列的一种变体, 它只保留对消息主题有兴趣 (流上当前定义的消费者)的消息. (只要有消费者尚未发送消息, 消息流中就会一直保留消息)</li>
</ul>
<p>请注意, 无论选择哪种保留策略, <code>Limits</code> (和丢弃策略)始终生效.</p>
<h4 id="213-persistent-and-consistent-distributed-storage持久且一致的分布式存储"><a class="header" href="#213-persistent-and-consistent-distributed-storage持久且一致的分布式存储">2.1.3 Persistent and Consistent distributed storage(持久且一致的分布式存储)</a></h4>
<p>您可以根据自己的需要选择消息存储的持久化和弹性.</p>
<ul>
<li><code>Memory storage</code>.</li>
<li><code>File storage</code>.</li>
<li><code>Replication</code> (1 (none), 2, 3) between nats servers for Fault Tolerance.</li>
</ul>
<h3 id="22-consumers消费者"><a class="header" href="#22-consumers消费者">2.2 Consumers(消费者)</a></h3>
<p><code>Core NATS</code>提供最多一次的交付保证, 而<code>JetStream</code>的消费者则不同, 它可以提供至少一次的交付保证.</p>
<h4 id="221-dispatch-type---pullpush分发类型---拉模式推模式"><a class="header" href="#221-dispatch-type---pullpush分发类型---拉模式推模式">2.2.1 Dispatch type - Pull/Push(分发类型 - 拉模式/推模式)</a></h4>
<ul>
<li><code>push</code>: 基于推送模式的, 即向指定主题发送消息</li>
<li><code>pull</code>: 基于拉模式的, 即允许客户按需请求批量消息</li>
</ul>
<h4 id="222-ordered-consumers有序消费者"><a class="header" href="#222-ordered-consumers有序消费者">2.2.2 Ordered Consumers(有序消费者)</a></h4>
<p>有序消费者是推/拉消费者的默认类型, 专为希望有效消费数据流以进行数据检查或分析的应用程序而设计.</p>
<ul>
<li>总是短暂的</li>
<li>无确认（如果检测到间隙, 则重新创建消费者）</li>
<li>自动流量控制/拉动处理</li>
<li>单线程调度</li>
<li>无负载平衡</li>
</ul>
<h4 id="223-persistence---durableephemeral持久性---持久短暂"><a class="header" href="#223-persistence---durableephemeral持久性---持久短暂">2.2.3 Persistence - Durable/Ephemeral(持久性 - 持久/短暂)</a></h4>
<p>除了可以选择推式或拉式外, 消费者还可以是短暂的或持久的.</p>
<h3 id="224-ackpolicy应答策略"><a class="header" href="#224-ackpolicy应答策略">2.2.4 AckPolicy(应答策略)</a></h3>
<p>策略选择包括:</p>
<ul>
<li><code>AckExplicit</code>:  默认策略. 每条报文都必须确认. 建议使用该策略以获得最高的可靠性和功能性.</li>
<li><code>AckNone</code>: 不需要确认；服务器假定在发送时确认.</li>
<li><code>AckAll</code>: 只确认系列中收到的最后一条信息；之前的所有信息都会自动确认. 将确认 Pull Consumer 所有订阅者的所有待确认信息.</li>
</ul>
<p>如果需要确认, 但在<code>AckWait</code>窗口内未收到, 则会重新发送报文.</p>
<h3 id="225-deliverpolicy分发策略"><a class="header" href="#225-deliverpolicy分发策略">2.2.5 DeliverPolicy(分发策略)</a></h3>
<p>策略选择包括:</p>
<ul>
<li><code>DeliverAll</code>: 默认策略. 从信息流中最早可用的信息开始接收.</li>
<li><code>DeliverLast</code>: 从流中添加的最后一条信息开始接收, 或从符合消费者筛选主题（如果已定义）的最后一条信息开始接收.</li>
<li><code>DeliverLastPerSubject</code>: 从当前信息流中每个过滤主题的最新信息开始接收.</li>
<li><code>DeliverNew</code>: 开始接收消费者创建后创建的信息.</li>
<li><code>DeliverByStartSequence</code>: 从具有指定序列号的第一条信息开始. 消费者必须指定定义序列号的<code>OptStartSeq</code>.</li>
<li><code>DeliverByStartTime</code>: 从指定时间或之后的信息开始接收. 消费者必须指定定义开始时间的<code>OptStartTime</code>.</li>
</ul>
<h3 id="226-maxackpending"><a class="header" href="#226-maxackpending">2.2.6 MaxAckPending</a></h3>
<p><code>MaxAckPending</code>功能提供流量控制, 同时适用于推式和拉式消费者.
对于推送消费者, <code>MaxAckPending</code>是唯一的流量控制形式.
对于拉式消费者, 客户端驱动的消息传递会与订阅者建立隐式一对一流量控制.
为获得高吞吐量, 请将 <code>MaxAckPending</code>设置为较高值.对于因外部服务导致延迟较高的应用, 可使用较低的值并调整 <code>AckWait</code> 以避免重新交付.</p>
<h3 id="227-filtersubjects"><a class="header" href="#227-filtersubjects">2.2.7 FilterSubjects</a></h3>
<p>过滤主题可在向客户端发送信息前对信息进行服务器端过滤.</p>
<h2 id="3-jetstream例子"><a class="header" href="#3-jetstream例子">3. JetStream例子</a></h2>
<h3 id="创建一个stream"><a class="header" href="#创建一个stream">创建一个<code>stream</code></a></h3>
<pre><code class="language-shell">nats stream add \
    com_msg \                               &lt;-- stream名称
    --subjects "com.msg.*" \                &lt;-- 订阅的主题
    --storage file \                        &lt;-- 存储类型, file/memory
    --retention "work" \                    &lt;-- 保留策略, limits/interest/work  
    --discard old \                         &lt;-- 丢弃策略, old/new, 当消息达到限制数据后, 如何处理消息
    --max-msgs -1 \                         &lt;-- 最大消息数量, -1 表示无限制
    --max-msgs-per-subject -1 \             &lt;-- 每个主题的最大消息数量, -1 表示无限制, 超过限制按丢弃策略处理
    --max-bytes -1 \                        &lt;-- 所有消息总的最大大小, -1 表示无限制
    --max-msg-size -1 \                     &lt;-- 单条消息的最大大小, -1 表示无限制
    --max-ages 1y \                         &lt;-- 最大消息年龄, 超过限制按丢弃策略处理
    --dupe-window 2m0s \                    &lt;-- 重复消息窗口, 根据Msg-Id的header头信息判断唯一消息的时间
    --no-allow-rollup \                     &lt;-- 是否允许通过header卷起消息, --allow-rollup为允许
    --deny-delete \                         &lt;-- 是否允许通过API删除消息, --no-deny-delete为允许
    --deny-purge \                          &lt;-- 是否允许通过API清除消息, --no-deny-purge为允许
    --replicas                              &lt;-- 消息副本数, 集群使用
</code></pre>
<h4 id="创建一个consumer"><a class="header" href="#创建一个consumer">创建一个<code>Consumer</code></a></h4>
<pre><code class="language-shell">nats consumer add \
    com_msg \                           &lt;-- stream名称
    com_msg_consumer \                  &lt;-- consumer名称
    --filter-subject "com.msg.*" \      &lt;-- 过滤stream中的主题
    --deliver all \                     &lt;-- 如何处理stream中的消息, 见下表
    --ack explicit \                    &lt;-- 消息确认方式, none/all/explicit
    --replay instant \                  &lt;-- 消息重放机制, instant/original
    --max-deliver -1 \                  &lt;-- 最大交付次数, -1 表示没有正确的ack就不停的投递消息
    --max-pending 0 \                   &lt;-- 最多允许存在多少条未投递成功, 正在重新投递的消息, 如果达到这个数, 将不再投递新消息
    --headers-only \                    &lt;-- 是否只投递header信息
    --target ""                         &lt;-- 推模式目标, 拉模式为空
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="私有仓库访问"><a class="header" href="#私有仓库访问">私有仓库访问</a></h2>
<pre><code class="language-shell">git config --global url."https://${username}:${token}@github.com".insteadof "https://github.com"
</code></pre>
<h2 id="1-配置"><a class="header" href="#1-配置">1. 配置</a></h2>
<pre><code class="language-shell">git config --global user.name "Your Name"
git config --global user.email "email@example.com"


[core]
        #  autocrlf
        # windows 和linux 换行符差异,需要配置换行符
        # windows 是CRLF
        # linux/mac是LF
        # 保存仓库永远为LF,在Windows工作空间都是CRLF, 在Mac/Linux工作空间都是LF.
        # windows配置`autocrlf = true`, 提交时自动CRLF转LF, 检出时自动将LF转CRLF
        # linux/mac配置`autocrlf = input`,提交时自动CRLF转LF, 检出时自动将保持LF.

        # safecrlf
        #拒绝提交包含混合换行符的文件
        safecrlf=true   
        #允许提交包含混合换行符的文件
        safecrlf=false
        #提交包含混合换行符的文件时给出警告
        safecrlf= warn

</code></pre>
<h2 id="2-暂存提交日志状态"><a class="header" href="#2-暂存提交日志状态">2. 暂存,提交,日志,状态</a></h2>
<pre><code class="language-shell">git add . # 提交所有到本地暂存区 
git commit -m "消息" # 提交到本地仓库
git status # 查看当前仓库状态
git log # 查看提交日志
git diff #查看差异化
</code></pre>
<h2 id="3-版本回退前进指定到相关版本"><a class="header" href="#3-版本回退前进指定到相关版本">3. 版本回退,前进,指定到相关版本</a></h2>
<pre><code class="language-shell">git reset --hard HEAD^ # 回退到上一个版本
git reset --hard hash值 # 回退到指定版本
git reflog # 查看最近回退的版本
</code></pre>
<h3 id="4-远程仓库"><a class="header" href="#4-远程仓库">4. 远程仓库</a></h3>
<pre><code class="language-shell">git remote add origin https://github.com/thinkgos/learngit.git
git push -u origin master
</code></pre>
<h3 id="5-分支代码冲突合并变基"><a class="header" href="#5-分支代码冲突合并变基">5. 分支,代码冲突,合并,变基.</a></h3>
<pre><code class="language-shell">git branch # 列出分支
git checkout dev # 检出分支
git checkout -b 分支 # 加上-b表示检出分支
git merge dev  # 合并dev分支到当前分支
</code></pre>
<h3 id="6-打标签"><a class="header" href="#6-打标签">6. 打标签</a></h3>
<pre><code class="language-shell">git tag # 列出所有标签
git tag v1.0.0 # 给当前分支打标签
git show v1.0.0 # 查看标签信息
git tag -d v0.9.0 # 删除某个标签
git push origin v1.0.0 #推送某个标签到远程 

# 如果标签已经推到远程
# 先删除本地
git tag -d v0.9.0
# 再删除远程
git push origin :refs/tags/v0.9.0
</code></pre>
<ol start="7">
<li>子模块</li>
</ol>
<pre><code class="language-shell"># 增加子模块
git submodule add  https://github.com/thinkgos/submodule.git libs/yoursubmodule

# 克隆含有子模块的项目,可通过增加 --recurse-submodules 来嵌入克隆子模块
git clone https://github.com/thinkgos/learngit.git
# 将子模块的项目克隆下来
git submodule update --init 
# 拉取子模块最新的推送
git submodule update --remote yoursubmodule
# 可以设置指定的分支并更新所有子模块
 git config -f .gitmodules submodule.DbConnector.branch stable
 git submodule update --remote
 # NOTE: git pull 命令会递归抓取子模块的更改,但不会更新子模块. 可以增加 --recurse-submodules
 # 为了完成所有更新,需要运行
 git submodule update --init --recursive
</code></pre>
<p><img src="pickup/../assets/202205071118094.png" alt="git_command" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rsa密钥"><a class="header" href="#rsa密钥">RSA密钥</a></h1>
<h2 id="der和pem编码"><a class="header" href="#der和pem编码">DER和PEM编码</a></h2>
<ul>
<li>DER： 基于二进制的编码。可以用CER或者CRT作为扩展名的的整数。比较合适的说法是“我有一个DER编码的证书”, 而不是“我有一个DER证书”</li>
<li>PEM： 基于ASCII(Base64)的编码。OpenSSL 使用 PEM 文件格式存储证书和密钥。</li>
</ul>
<p>PEM 实质上是 base64 编码的二进制内容, 再进行增加或裁剪特殊字符-、n、r、begin信息、end信息,如:</p>
<pre><code class="language-shell">-----BEGIN CERTIFICATE-----
内容
-----END CERTIFICATE-----
</code></pre>
<h2 id="pcksthe-public-key-cryptography-standards"><a class="header" href="#pcksthe-public-key-cryptography-standards">PCKS(The Public-Key Cryptography Standards)</a></h2>
<p>PKCS由美国RSA公司及其合作伙伴制定的一组公钥密码学标准, 其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。<br />
版本：现有PCKS1, PCKS3, PCKS5, PKCS6, PKCS7, PKCS8, PKCS9, PKCS10, PKCS11, PKCS12, PKCS13, PKCS14, PKCS15 等13个版本<br />
常用：PCKS1 和 PCKS8, 本文使用 PCKS8 标准<br />
注：由于PKCS内容规范设计二进制, 不方便使用, 所以一般转成base64 后, 用 pem 格式规范显示</p>
<ul>
<li>pcks1的pem格式头</li>
</ul>
<pre><code class="language-shell">//公钥
-----BEGIN RSA PUBLIC KEY-----
内容
-----END RSA PUBLIC KEY-----
//私钥
-----BEGIN RSA PRIVATE KEY-----
内容
-----END RSA PRIVATE KEY-----
</code></pre>
<ul>
<li>pcks8的pem格式头</li>
</ul>
<pre><code class="language-shell">//公钥
-----BEGIN PUBLIC KEY-----
内容
-----END PUBLIC KEY-----
//私钥
-----BEGIN PRIVATE KEY-----
内容
-----END PRIVATE KEY-----
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-ubuntu"><a class="header" href="#install-ubuntu">install ubuntu</a></h1>
<h2 id="修改软件源"><a class="header" href="#修改软件源">修改软件源</a></h2>
<h3 id="图形修改"><a class="header" href="#图形修改">图形修改</a></h3>
<p>系统设置 -&gt; 软件和更新 选择下载服务器 -&gt; "mirrors.aliyun.com"</p>
<h3 id="手动修改"><a class="header" href="#手动修改">手动修改</a></h3>
<p><code>/etc/apt/sources.list</code></p>
<p>替换默认的<code>http://archive.ubuntu.com/</code>为<code>http://mirrors.aliyun.com/</code></p>
<p>ubuntu22.04为以下配置</p>
<pre><code class="language-shell">deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse

# deb https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse
# deb-src https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse

deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
</code></pre>
<h2 id="安装基础软件"><a class="header" href="#安装基础软件">安装基础软件</a></h2>
<pre><code class="language-shell">sudo apt-get update
sudo apt-get upgrade
sudo apt-get install vim zsh git curl jq gcc make cmake tmux gcc12
</code></pre>
<h3 id="配置git"><a class="header" href="#配置git">配置git</a></h3>
<pre><code class="language-shell">git config --global user.name ""
git config --global user.email ""
</code></pre>
<p><code>.gitconfig</code></p>
<pre><code class="language-shell">[user]
    name = example 
    email = example@example.com
[core]
    # autocrlf
    # windows 和linux 换行符差异,需要配置换行符
    # windows 是CRLF
    # linux/mac是LF
    # 保存仓库永远为LF,在Windows工作空间都是CRLF, 在Mac/Linux工作空间都是LF.
    # windows配置`autocrlf = true`, 提交时自动CRLF转LF, 检出时自动将LF转CRLF
    # linux/mac配置`autocrlf = input`,提交时自动CRLF转LF, 检出时自动将保持LF.

    # safecrlf
    #拒绝提交包含混合换行符的文件
    safecrlf=true   
    #允许提交包含混合换行符的文件
    safecrlf=false
    #提交包含混合换行符的文件时给出警告
    safecrlf= warn
    autocrlf = input
    pager = delta
    editor = vim
[interactive]
    diffFilter = delta --color-only
[add.interactive]
    useBuiltin = false # required for git 2.37.0

[delta]
    navigate = true    # use n and N to move between diff sections
    light = false      # set to true if you're in a terminal w/ a light background color (e.g. the default macOS terminal)
    side-by-side = true
[merge]
    conflictstyle = diff3

[diff]
    colorMoved = default
</code></pre>
<p><code>.gitmessage</code></p>
<pre><code class="language-shell"># head: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;                                                                                                                                                            
# - type: feat, fix, doc, perf, style, refactor, test, chore, security, revert                                                                                                                
# - scope: can be empty (eg. if the change is a global or difficult to assign to a single component)                                                                                          
# - subject: start with verb (such as 'change'), 50-character line                                                                                                                            
#                                                                                                                                                                                             
# body: 72-character wrapped. This should answer:                                                                                                                                             
# * Why was this change necessary?                                                                                                                                                            
# * How does it address the problem?                                                                                                                                                          
# * Are there any side effects?                                                                                                                                                               
#                                                                                                                                                                                             
# footer:                                                                                                                                                                                     
# - Include a link to the ticket, if any.                                                                                                                                                     
# - BREAKING CHANGE
</code></pre>
<h3 id="安装输入法"><a class="header" href="#安装输入法">安装输入法</a></h3>
<pre><code class="language-shell">sudo apt update
sudo apt install fcitx5 fcitx5-chinese-addons fcitx-config-gtk 
</code></pre>
<p>配置<code>/etc/environment</code>中增加以下配置, 解决浏览器等软件无法使用的问题.</p>
<pre><code class="language-shell">GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=@im=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=ibus
</code></pre>
<p>配置 <strong>语言支持</strong> 为 <code>fcitx5</code></p>
<h3 id="安装gnome-tweaks"><a class="header" href="#安装gnome-tweaks">安装<code>gnome-tweaks</code></a></h3>
<pre><code class="language-shell">sudo apt install gnome-tweaks
</code></pre>
<h3 id="安装gnome-shell-extensions"><a class="header" href="#安装gnome-shell-extensions">安装<code>gnome-shell-extensions</code></a></h3>
<pre><code class="language-shell">sudo apt install gnome-shell-extensions 
</code></pre>
<h3 id="zsh配置"><a class="header" href="#zsh配置">zsh配置</a></h3>
<h4 id="设置zsh为默认"><a class="header" href="#设置zsh为默认">设置zsh为默认</a></h4>
<pre><code class="language-shell"># 设置默认shell, 需要重启
chsh -s $(which zsh)
</code></pre>
<h4 id="安装ohmyzsh"><a class="header" href="#安装ohmyzsh">安装<a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh</a></a></h4>
<p><code>sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></p>
<h4 id="配置zsh"><a class="header" href="#配置zsh">配置zsh</a></h4>
<pre><code class="language-shell"># zsh-syntax-highlighting
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
# zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
# 
git clone https://github.com/thinkgos/minority.git  .minority
# 软链接
ln -s ~/.minority/zshrc/.zshrc ~/.zshrc
ln -s ~/.minority/vim/.vimrc ~/.vimrc 
ln -s ~/.minority/zshrc/starship.toml ~/.config/starship.toml 
ln -s ~/.minority/minority/zellij ~/.config/zellij
</code></pre>
<h3 id="安装rust"><a class="header" href="#安装rust">安装rust</a></h3>
<p><a href="https://www.rust-lang.org/tools/install">Install Rust</a></p>
<pre><code class="language-shell">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<pre><code class="language-conf">[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"
replace-with = "ustc"

[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"
[registries.ustc]
index = "https://mirrors.ustc.edu.cn/crates.io-index"

[build]
rustc-wrapper = ".cargo/bin/sccache"
[target.x86_64-unknown-linux-gnu]
linker = "clang"
rustflags = ["-C", "link-arg=-fuse-ld=/usr/local/bin/mold"]
</code></pre>
<h3 id="安装go"><a class="header" href="#安装go">安装go</a></h3>
<h4 id="使用goup安装"><a class="header" href="#使用goup安装">使用<a href="https://github.com/thinkgos/goup-rs">goup</a>安装</a></h4>
<h4 id="配置-zshenv"><a class="header" href="#配置-zshenv">配置 <code>.zshenv</code></a></h4>
<pre><code class="language-shell"># goup
. "$HOME/.goup/env"
# go
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
</code></pre>
<h4 id="配置代理"><a class="header" href="#配置代理">配置代理</a></h4>
<pre><code class="language-shell">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="link"><a class="header" href="#link">Link</a></h1>
<h2 id="1-tcp-三次握手-tcp头部"><a class="header" href="#1-tcp-三次握手-tcp头部">1. tcp 三次握手, tcp头部</a></h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439650&amp;idx=5&amp;sn=12764c4477f850c3f5f627545c45ec40&amp;chksm=80bb1cd0b7cc95c6e3a52819cea3e1e36e17360a05fa5c8912c5299c98a9fa179d1681488487&amp;mpshare=1&amp;scene=1&amp;srcid=0115PDXWqhgsTG3xdDUHnULh&amp;sharer_sharetime=1610698449434&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AeJQQ3o6DtKmP2nChhsXVFo%3D&amp;pass_ticket=vv4RPcR8dxxyU9301O0W%2FRibxJcJxhfVMIYs2XVP8GtDsx4DABTV1WTp%2BZI6w3AJ&amp;wx_header=0#rd">图解TCP三次握手和四次挥手面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439692&amp;idx=4&amp;sn=8e616cf2e7cca18d1a6639c2111401de&amp;chksm=80bb1cbeb7cc95a804910499dd500385d7b7724177854a6d28e9f6e73ab154d37be5df3c72b9&amp;mpshare=1&amp;scene=1&amp;srcid=0115ZoC5vtytFKWL9pDOOiHZ&amp;sharer_sharetime=1610698640873&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AQGo6olwwmOWcrJ1OffWvPg%3D&amp;pass_ticket=vv4RPcR8dxxyU9301O0W%2FRibxJcJxhfVMIYs2XVP8GtDsx4DABTV1WTp%2BZI6w3AJ&amp;wx_header=0#rd">图解TCP重传、滑动窗口、流量控制、拥塞控制</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439830&amp;idx=4&amp;sn=1656ea642a03fba188308ab7b124ff1a&amp;chksm=80bb1c24b7cc953260cc2bea029ca60d802303b436306427f8172efbb1b729c2f2c9904bd6b6&amp;mpshare=1&amp;scene=1&amp;srcid=0115NoThktmIdt5Dcv3YTKnW&amp;sharer_sharetime=1610698649909&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AbBcToo0EQdMH9r0VpHjIvI%3D&amp;pass_ticket=vv4RPcR8dxxyU9301O0W%2FRibxJcJxhfVMIYs2XVP8GtDsx4DABTV1WTp%2BZI6w3AJ&amp;wx_header=0#rd">TCP 半连接队列和全连接队列满了如何应对</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NzEwNjI5OA==&amp;mid=2247484654&amp;idx=1&amp;sn=7fb25c0c2c980baf9e4efc7f56c538d9&amp;chksm=fd08fcfbca7f75edbc73f854771b66836456239fac0e5fc7a713878f92cc1db5881a28711f5d&amp;mpshare=1&amp;scene=1&amp;srcid=0114tnzpzqgZ5QQ6FfrFbz2u&amp;sharer_sharetime=1610698664483&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AePM%2BMwRumfmIJ7eQPQZUZY%3D&amp;pass_ticket=vv4RPcR8dxxyU9301O0W%2FRibxJcJxhfVMIYs2XVP8GtDsx4DABTV1WTp%2BZI6w3AJ&amp;wx_header=0#rd">TCP的内存开销</a></li>
</ul>
<h2 id="2-micro-services"><a class="header" href="#2-micro-services">2. micro services</a></h2>
<ul>
<li>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651437896&amp;idx=5&amp;sn=5b8ec41097be22f0cb399be110fe736e&amp;chksm=80bb65bab7ccecac89d52d2ae92905a9d8b885ef8fa698639e2373d49448d183ac2c25e1eb22&amp;scene=0&amp;xtrack=1&amp;exportkey=AeCEwqhXz49767GtgC85Fqc%3D&amp;pass_ticket=edom3%2BQWJv2%2F6ag8wwGj83w98nQSUN8ex7sdZB89cFp%2FbMiUGbmDvKeH%2BLBfXRK2#rd">图文并茂讲解分布式事务的实现原理</a></li>
</ul>
</li>
<li>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651437478&amp;idx=1&amp;sn=2187aacae7d92024d9abb4fb93828688&amp;chksm=80bb6754b7ccee42ea53ffbda70406bdc3f829029c6235112bd5fd006cabbff836f436d11e58&amp;scene=0&amp;xtrack=1&amp;exportkey=Aap2eWS0jqrpoKE4AVQ6l94%3D&amp;pass_ticket=edom3%2BQWJv2%2F6ag8wwGj83w98nQSUN8ex7sdZB89cFp%2FbMiUGbmDvKeH%2BLBfXRK2#rd">Go微服务全链路跟踪详解</a></li>
</ul>
</li>
<li>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651437770&amp;idx=2&amp;sn=ba2a02df8bb89c02c6e620df349731a3&amp;chksm=80bb6438b7cced2e7dbe9ab39c6b027326cefdd576e9108113228f097184dceabbc3061611f2&amp;scene=0&amp;xtrack=1&amp;exportkey=AWNQJk%2FbQMuYeE0W7IA5cYc%3D&amp;pass_ticket=edom3%2BQWJv2%2F6ag8wwGj83w98nQSUN8ex7sdZB89cFp%2FbMiUGbmDvKeH%2BLBfXRK2#rd">微服务架构原理分析</a></li>
</ul>
</li>
</ul>
<h2 id="3-algorithm"><a class="header" href="#3-algorithm">3. algorithm</a></h2>
<ul>
<li>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTEwNTE1Mw==&amp;mid=2247483996&amp;idx=1&amp;sn=5f22f8855690f0a1b9adc3402471c616&amp;chksm=c01423b2f763aaa45c1bc71c7e86e1e05c7d27b230cf0de9fc6330bd44b68ecea0b8255a0034&amp;scene=0&amp;xtrack=1&amp;exportkey=AWz484PUyWSEhkr5XWnRVWE%3D&amp;pass_ticket=edom3%2BQWJv2%2F6ag8wwGj83w98nQSUN8ex7sdZB89cFp%2FbMiUGbmDvKeH%2BLBfXRK2#rd">LRC缓存介绍与用法</a></li>
</ul>
</li>
<li>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;mid=2247487327&amp;idx=1&amp;sn=7172219769b69356c78f6b956760cb86&amp;chksm=fa24f037cd5379218f1002567d8c2f6d64a3bd6b3d21ce6dd3ee7e38b89b2bb026e3adb86bd0&amp;scene=0&amp;xtrack=1&amp;exportkey=ASEmKy0i163FV8waw8OKlbA%3D&amp;pass_ticket=edom3%2BQWJv2%2F6ag8wwGj83w98nQSUN8ex7sdZB89cFp%2FbMiUGbmDvKeH%2BLBfXRK2#rd">八种排序算法的思想</a></li>
</ul>
</li>
<li>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247487946&amp;idx=2&amp;sn=316a05a5e4a91c072c723ba597856dee&amp;chksm=fa0e7e4bcd79f75d718e02cc97d074b4d5c8614a6345ee66e1e46b7922e8764d097e67359890&amp;scene=0&amp;xtrack=1&amp;exportkey=AcXMtLcRcHvk%2BKneOJDIxEc%3D&amp;pass_ticket=edom3%2BQWJv2%2F6ag8wwGj83w98nQSUN8ex7sdZB89cFp%2FbMiUGbmDvKeH%2BLBfXRK2#rd">以后有面试官问你「密码学」, 你就把这篇文章扔给他</a></li>
</ul>
</li>
<li>
<p>红黑树</p>
<ul>
<li>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247489352&amp;idx=3&amp;sn=84a19965b224fd05f2ccd505beef890f&amp;chksm=fa0e78c9cd79f1df81ab6a3194d1dee7b4aa3e9a8109e22894e24b96168a448ff0164f12ae9d&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1591071849629&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AQ3cAAivJ1iOy24H%2BlVGZWw%3D&amp;pass_ticket=hnxYbcWTDsWM%2F87p7FMBmRfEvyyVh6II8QNe8UFDv5E5mySMhm4S3Vzaj6GoWG%2F5#rd">图解：什么是红黑树?(上篇)</a></li>
</ul>
</li>
<li>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247489352&amp;idx=4&amp;sn=498725b77ef8a7e79325c4175d809412&amp;chksm=fa0e78c9cd79f1dfc70a2df760f2f9366a74f3450e1785366d237afab1176aff2b38f0ca6c58&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1591071856823&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AXURQOXoBi5M6M7jxx4J81c%3D&amp;pass_ticket=hnxYbcWTDsWM%2F87p7FMBmRfEvyyVh6II8QNe8UFDv5E5mySMhm4S3Vzaj6GoWG%2F5#rd">图解：什么是红黑树?(中篇)</a></li>
</ul>
</li>
<li>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247489352&amp;idx=5&amp;sn=82d3ddf1c14cf9f5c81c76d2ae16c910&amp;chksm=fa0e78c9cd79f1df1c2acf6506b40c8fe5a70c1f5e2f93fcc0c797db0cec596f91b46a1a04e1&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1591071865638&amp;sharer_shareid=fbafc624aa53cd09857fb0861ac2a16d&amp;exportkey=AW6sRrjD2vNSf0ECh9%2B7DUU%3D&amp;pass_ticket=hnxYbcWTDsWM%2F87p7FMBmRfEvyyVh6II8QNe8UFDv5E5mySMhm4S3Vzaj6GoWG%2F5#rd">图解：什么是红黑树?(下篇)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="音视频"><a class="header" href="#音视频">音视频</a></h1>
<h2 id="sip"><a class="header" href="#sip">SIP</a></h2>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3261">sip-rfc3261</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3428">sip-message-rfc3428</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/691687606">sip</a></li>
</ul>
<h2 id="rtmp"><a class="header" href="#rtmp">RTMP</a></h2>
<h2 id="rtsp"><a class="header" href="#rtsp">RTSP</a></h2>
<ul>
<li><a href="https://blog.csdn.net/weixin_43147845/article/details/140851964">RTSP系列</a></li>
</ul>
<h2 id="srt"><a class="header" href="#srt">SRT</a></h2>
<h2 id="rtp"><a class="header" href="#rtp">RTP</a></h2>
<h2 id="sdp"><a class="header" href="#sdp">SDP</a></h2>
<p><code>session description protocol</code>, 会话描述协议, 媒体协商</p>
<h2 id="stun"><a class="header" href="#stun">STUN</a></h2>
<p><code>session traversal utilities for NAT</code>, NAT会话穿越应用程序, 网络信息交换, <code>RFC5839</code></p>
<h2 id="turn"><a class="header" href="#turn">TURN</a></h2>
<p><code>traversal using relays around NAT</code>, <code>RFC5839</code>扩展, 主要添加relay功能, 如果nat后, 与对等无法建立通信, 则需要公网服务器做中继</p>
<h2 id="ice"><a class="header" href="#ice">ICE</a></h2>
<p><code>STUN</code>+<code>TURN</code>的一个信令服务器</p>
<h2 id="ssdp"><a class="header" href="#ssdp">SSDP</a></h2>
<p><code>Simple Service Discovery Protocol</code>, 简单服务发现协议</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/draft-cai-ssdp-v1-03">draft-cai-ssdp-v1-03</a></li>
<li><a href="https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf">UPnp</a></li>
<li><a href="https://sunkx.blog.csdn.net/article/details/144061374">SIP系列详解</a></li>
</ul>
<h2 id="onvif"><a class="header" href="#onvif">ONVIF</a></h2>
<h2 id="gb28181"><a class="header" href="#gb28181">GB28181</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdp-1"><a class="header" href="#sdp-1">SDP</a></h1>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc4566">rfc4566</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8866">rfc8866</a></li>
</ul>
<p><code>SDP</code>协议是会话描述协议(Session Description Protocol)的缩写, 是一种会话描述格式, 一种描述流媒体初始化参数的格式, 为描述多媒体数据而设计.<br />
<code>SDP</code>协议完全是一种会话描述格式. <code>SDP</code>协议是文本形式, 采用UTF-8编码的ISO 10646字符集
<code>SDP</code>协议不支持会话内容或媒体编码的协商(<code>SDP</code>协议只是描述信息而不能协商的去更改信息), 所以在流媒体中只用来描述媒体信息, 媒体协商需要其它协议来完成.</p>
<h2 id="sdp协议描述符"><a class="header" href="#sdp协议描述符">SDP协议描述符</a></h2>
<p>①会话名和目的
②会话激活的时间区段
③构成会话的媒体信息(主叫和被叫的信息)
④接收这些媒体所需要的信息(地址, 端口, 格式)
⑤会话所用的宽带信息
⑥会话负责人的联系信息
⑦媒体信息(包括：媒体类型(视频, 音频等)、传送协议(RTP/UDP/IP H.320等)、媒体格式(H,264视频, MPEG视频等)、媒体地址和端口).</p>
<h3 id="sdp格式"><a class="header" href="#sdp格式">SDP格式</a></h3>
<p>一个<code>SDP</code>会话描述包括若干行<code>type=value</code>形式的文本.</p>
<ul>
<li><code>type</code>: 该字节为单字节(如: v, o,  m等)且区分大小写</li>
<li><code>value</code>: 为结构化文本的文本, 格式由<code>type</code>而定, 通常由若干分割符隔开的字段组成或者是一个字符串, 整个协议文本区分大小写.</li>
<li><code>=</code>: 等号两侧不允许有空格.</li>
</ul>
<pre><code class="language-yaml"># &lt;类型&gt;=&lt;值&gt;
＜type＞=&lt;value&gt; [CRLF] # (CRLF表示换行)
</code></pre>
<h3 id="sdp整体结构"><a class="header" href="#sdp整体结构">SDP整体结构</a></h3>
<p><code>SDP</code>由一个会话级描述(session level description)和多个媒体级描述(media level description)组成.</p>
<ul>
<li>会话级描述的作用域是整个会话, 在<code>SDP</code>中, 从 <strong>"v="</strong> 行开始到第一个 <strong>"m="</strong> 行之前都是属于会话级描述的内容.</li>
<li>媒体级描述对某个媒体流的内容进行描述, 例如某个音频流或者某个视频流, 从某个 <strong>"m="</strong> 行开始到下个 <strong>"m="</strong> 行之前是属于一个媒体级描述的内容.</li>
</ul>
<p>[下面带<code>*</code>号的是可选的, 其余的是必须的. 一般顺序也按照下面的顺序来排列. a=*是sdp协议扩展属性定义, 除上面以外的, 分解时其它的都可以扔掉. a=charset属性指定协议使用的字符集. 一般的是ISO-10646.]</p>
<pre><code class="language-yaml">Session description                                 # 会话描述
    v=  (protocol version)                          # 协议版本
    o=  (originator and session identifier)         # 发起者和会话标识符
    s=  (session name)                              # 会话名称
    i=* (session information)                       # 会话信息
    u=* (URI of description)                        # URI描述
    e=* (email address)                             # email地址
    p=* (phone number)                              # 电话号码
    c=* (connection information - not required if included in all media)  # 连接信息 ― 如果包含在所有媒体中, 则不需要该字段
    b=* (zero or more bandwidth information lines)  # 零或多个带宽信息行
    One or more time descriptions ("t=" and "r=" lines, see below) # 零或多个时间描述行
    z=* (time zone adjustments)                     # 时区调整
    k=* (encryption key)                            # 加密密钥 
    a=* (zero or more session attribute lines)      # 零或多个会话属性行
    Zero or more media descriptions                 # 零或多个媒体描述

Time description                                    # 时间描述
    t=  (time the session is active)                # 会话活动时间
    r=* (zero or more repeat times)                 # 零或多个重复时间

Media description, if present                       # 媒体描述, 如果有
    m=  (media name and transport address)          # 媒体名称和传输地址
    i=* (media title)                               # 媒体标题
    c=* (connection information - optional if included at session-level)  # 连接信息 — 如果包含在会话层则该字段可选
    b=* (zero or more bandwidth information lines)  # 带宽信息
    k=* (encryption key)                            # 加密密钥
    a=* (zero or more media attribute lines)        # 零或多个会话属性行
</code></pre>
<h4 id="v-protocol-version必选"><a class="header" href="#v-protocol-version必选">v: protocol version(必选)</a></h4>
<p><code>v</code>的含义是<code>SDP</code>协议的版本号，目前<code>v</code>都是<code>0</code>。</p>
<h3 id="o-originator-and-session-identifier必选"><a class="header" href="#o-originator-and-session-identifier必选">o: originator and session identifier(必选)</a></h3>
<p>会话所有者有关的参数</p>
<ul>
<li><code>username</code>: 会话发起者的名称。如果不提供则用"-"表示，用户名不能包含空格；</li>
<li><code>session-id</code>: 主叫方的会话标识符, 在整个会话中同必须唯一.</li>
<li><code>session-version</code>: 会话版本号，一般为 0；</li>
<li><code>nettype</code>: 网络类型，目前仅使用<code>IN</code>来表示Internet网络类型；</li>
<li><code>addrtype</code>: 地址类型，可以是<code>IPV4</code>和<code>IPV6</code>两种地址类型；</li>
<li><code>unicast-address</code>：会话发起者的IP地址;</li>
</ul>
<h3 id="s-session-name必选"><a class="header" href="#s-session-name必选">s: session name(必选)</a></h3>
<p>本次会话的标题或会话的名称, 没有的话使用-代替.</p>
<h3 id="i-session-information可选"><a class="header" href="#i-session-information可选">i: session information(可选)</a></h3>
<p>会话信息, 建议包括进来用于描述相应会话文字性说明.</p>
<h3 id="u-uri-of-description可选"><a class="header" href="#u-uri-of-description可选">u: URI of description(可选)</a></h3>
<p>url的描述信息.</p>
<h3 id="e-email-address可选"><a class="header" href="#e-email-address可选">e: email address(可选)</a></h3>
<p>邮件地址.</p>
<h3 id="p-phone-number可选"><a class="header" href="#p-phone-number可选">p: phone number(可选)</a></h3>
<p>电话号码.</p>
<h3 id="c-connection-information---not-required-if-included-in-all-media可选"><a class="header" href="#c-connection-information---not-required-if-included-in-all-media可选">c: connection information - not required if included in all media(可选)</a></h3>
<p>媒体连接信息</p>
<p><code>c=&lt;networktype&gt; &lt;address type&gt; &lt;connection address&gt;</code></p>
<ul>
<li><code>&lt;network type&gt;</code>: 网络类型，一般为<code>IN</code>, 表示”internet”</li>
<li><code>&lt;address type&gt;</code>: 地址类型，一般为<code>IP4</code>。</li>
<li><code>&lt;connection address&gt;</code>: 应用程序必须处理域名和ip地址两种情形。单播时，为域名或IP地址，推荐使用域名；多播，为IP地址，且IP后面必须有TTL（取值范围是0－255），地址和TTL决定了多播包被传播的范围。</li>
</ul>
<h3 id="b-zero-or-more-bandwidth-information-lines可选"><a class="header" href="#b-zero-or-more-bandwidth-information-lines可选">b: zero or more bandwidth information lines(可选)</a></h3>
<h3 id="one-or-more-time-descriptions"><a class="header" href="#one-or-more-time-descriptions">One or more time descriptions</a></h3>
<p>一或多个时间描述, 描述了会话的开始时间和结束时间。这个可以有行，指定多个不规则时间段，如果是规则的时间段，则r=属性可以使用</p>
<h4 id="t-time-the-session-is-active必选"><a class="header" href="#t-time-the-session-is-active必选">t: time the session is active(必选)</a></h4>
<p>会话的起始时间和结束时间（Time session starts and stops），如果没有规定这两个时间的话，都写为 0 即可。</p>
<h4 id="r-zero-or-more-repeat-times可选"><a class="header" href="#r-zero-or-more-repeat-times可选">r: zero or more repeat times(可选)</a></h4>
<p>重复次数, <code>r=&lt;repeat-interval&gt; &lt;active duration&gt; &lt;offsets from start-time&gt;</code></p>
<h3 id="z-time-zone-adjustments"><a class="header" href="#z-time-zone-adjustments">z: time zone adjustments</a></h3>
<h3 id="k-encryption-key"><a class="header" href="#k-encryption-key">k: encryption key</a></h3>
<h3 id="a-zero-or-more-session-attribute-lines"><a class="header" href="#a-zero-or-more-session-attribute-lines">a: zero or more session attribute lines</a></h3>
<h3 id="zero-or-more-media-descriptions"><a class="header" href="#zero-or-more-media-descriptions">Zero or more media descriptions</a></h3>
<p>媒体描述, 如果有</p>
<h4 id="m-media-name-and-transport-address必选"><a class="header" href="#m-media-name-and-transport-address必选">m: media name and transport address(必选)</a></h4>
<p>媒体名称和传输地址, <code>m=&lt;media&gt; &lt;port&gt;[/&lt;number of ports&gt;] &lt;transport&gt; &lt;fmt list&gt;</code></p>
<h4 id="i-media-title可选"><a class="header" href="#i-media-title可选">i: media title(可选)</a></h4>
<p>媒体标题</p>
<h4 id="c-connection-information---optional-if-included-at-session-level可选"><a class="header" href="#c-connection-information---optional-if-included-at-session-level可选">c: connection information - optional if included at session-level(可选)</a></h4>
<p>连接信息</p>
<h4 id="b-zero-or-more-bandwidth-information-lines可选-1"><a class="header" href="#b-zero-or-more-bandwidth-information-lines可选-1">b: zero or more bandwidth information lines(可选)</a></h4>
<p>带宽信息, <code>b=&lt;bwtype&gt;:&lt;bandwidth-value&gt;</code></p>
<h4 id="k-encryption-key可选"><a class="header" href="#k-encryption-key可选">k: encryption key(可选)</a></h4>
<p>加密密钥</p>
<h4 id="a-zero-or-more-media-attribute-lines可选"><a class="header" href="#a-zero-or-more-media-attribute-lines可选">a: zero or more media attribute lines(可选)</a></h4>
<p>零或多个会话属性行</p>
 <!-- k=已定义的方法有:  k=clear:<加密密钥>密钥没有变换;k=base64:<编码密钥>已编码, 因为它含有SDP禁用的字符;k=uri:<获得密钥的URI>;k=prompt.SDP没有提供密钥但该会话或媒体流是要求加密的. -->
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
